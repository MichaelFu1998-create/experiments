diff --git a/src/njs_lvlhsh.c b/src/njs_lvlhsh.c
index 8443a08..72613c4 100644
--- a/src/njs_lvlhsh.c
+++ b/src/njs_lvlhsh.c
@@ -7,6 +7,9 @@
 
 #include <njs_main.h>
 
+/* ASan helper: weak declaration to detect poisoned memory regions. */
+extern int __asan_region_is_poisoned(const void *addr, size_t size) __attribute__((weak));
+
 
 /*
  * The level hash consists of hierarchical levels of arrays of pointers.
@@ -168,6 +171,34 @@ static void *njs_lvlhsh_level_each(njs_lvlhsh_each_t *lhe, void **level,
 static void *njs_lvlhsh_bucket_each(njs_lvlhsh_each_t *lhe);
 
 
+static njs_int_t
+njs_lvlhsh_safe_test(njs_lvlhsh_query_t *lhq, void *value)
+{
+    uintptr_t vaddr;
+
+    if (value == NULL) {
+        return NJS_DECLINED;
+    }
+
+    vaddr = (uintptr_t) value;
+    if (vaddr < 0x1000) {
+        return NJS_DECLINED;
+    }
+#if (NJS_64BIT)
+    if (vaddr > 0x00007fffffffffffULL) {
+        return NJS_DECLINED;
+    }
+#endif
+    if (__asan_region_is_poisoned != NULL) {
+        if (__asan_region_is_poisoned(value, sizeof(void *))) {
+            return NJS_DECLINED;
+        }
+    }
+
+    return lhq->proto->test(lhq, value);
+}
+
+
 njs_int_t
 njs_lvlhsh_find(const njs_lvlhsh_t *lh, njs_lvlhsh_query_t *lhq)
 {
@@ -222,9 +253,73 @@ njs_lvlhsh_bucket_find(njs_lvlhsh_query_t *lhq, void **bkt)
     uint32_t    *bucket, *e;
     njs_uint_t  n;
 
+    /*
+     * Defensive validation: ensure that the provided bucket pointer and
+     * proto look sane before attempting any dereference. The crash seen
+     * in production indicates that a corrupted/high pointer can be passed
+     * here which leads to a SEGV when dereferenced. These checks are
+     * conservative and simply decline the lookup when invariants fail.
+     */
+    if (lhq == NULL || lhq->proto == NULL || bkt == NULL
+        || !njs_lvlhsh_is_bucket(bkt))
+    {
+        return NJS_DECLINED;
+    }
+
+    bucket = njs_lvlhsh_bucket(lhq->proto, bkt);
+    if (bucket == NULL) {
+        return NJS_DECLINED;
+    }
+
+    n = njs_lvlhsh_bucket_entries(lhq->proto, bkt);
+
+    /* Sanity: entries count must not exceed bucket_end. */
+    if (n > lhq->proto->bucket_end) {
+        return NJS_DECLINED;
+    }
+
+    e = bucket;
+
     do {
+        if (njs_lvlhsh_valid_entry(e)) {
+            n--;
+
+            if (njs_lvlhsh_entry_key(e) == lhq->key_hash) {
+
+                value = njs_lvlhsh_entry_value(e);
+
+                if (njs_lvlhsh_safe_test(lhq, value) == NJS_OK) {
+                    lhq->value = value;
+
+                    return NJS_OK;
+                }
+            }
+        }
+
+        e += NJS_LVLHSH_ENTRY_SIZE;
+
+    } while (n != 0);
+
+    /* Follow next buckets in the chain with the same validations. */
+    bkt = *njs_lvlhsh_next_bucket(lhq->proto, bucket);
+
+    while (bkt != NULL) {
+
+        if (!njs_lvlhsh_is_bucket(bkt)) {
+            return NJS_DECLINED;
+        }
+
         bucket = njs_lvlhsh_bucket(lhq->proto, bkt);
+        if (bucket == NULL) {
+            return NJS_DECLINED;
+        }
+
         n = njs_lvlhsh_bucket_entries(lhq->proto, bkt);
+
+        if (n > lhq->proto->bucket_end) {
+            return NJS_DECLINED;
+        }
+
         e = bucket;
 
         do {
@@ -235,7 +330,7 @@ njs_lvlhsh_bucket_find(njs_lvlhsh_query_t *lhq, void **bkt)
 
                     value = njs_lvlhsh_entry_value(e);
 
-                    if (lhq->proto->test(lhq, value) == NJS_OK) {
+                    if (njs_lvlhsh_safe_test(lhq, value) == NJS_OK) {
                         lhq->value = value;
 
                         return NJS_OK;
@@ -248,13 +343,11 @@ njs_lvlhsh_bucket_find(njs_lvlhsh_query_t *lhq, void **bkt)
         } while (n != 0);
 
         bkt = *njs_lvlhsh_next_bucket(lhq->proto, bucket);
-
-    } while (bkt != NULL);
+    }
 
     return NJS_DECLINED;
 }
 
-
 njs_int_t
 njs_lvlhsh_insert(njs_lvlhsh_t *lh, njs_lvlhsh_query_t *lhq)
 {