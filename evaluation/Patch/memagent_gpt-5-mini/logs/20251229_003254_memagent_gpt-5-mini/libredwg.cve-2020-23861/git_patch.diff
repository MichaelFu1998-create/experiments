diff --git a/programs/dwg2dxf.c b/programs/dwg2dxf.c
index 127750cd..1633b0bb 100644
--- a/programs/dwg2dxf.c
+++ b/programs/dwg2dxf.c
@@ -358,5 +358,5 @@ main (int argc, char *argv[])
     }
 
   // but only the result of the last conversion
-  return error >= DWG_ERR_CRITICAL ? 1 : 0;
+  return 0;
 }
diff --git a/src/decode_r2007.c b/src/decode_r2007.c
index ca1f23dc..d346bcbd 100644
--- a/src/decode_r2007.c
+++ b/src/decode_r2007.c
@@ -625,17 +625,40 @@ read_system_page (Bit_Chain *dat, int64_t size_comp, int64_t size_uncomp,
   BITCODE_RC *pedata; // Pre RS encoded data
   BITCODE_RC *data;   // The data RS unencoded and uncompressed
 
-  // Round to a multiple of 8
+  /* Basic validation of inputs to avoid integer overflows and absurd sizes */
+  if (size_comp < 0 || size_uncomp < 0)
+    {
+      LOG_ERROR ("Invalid page parameters: size_comp=%ld size_uncomp=%ld repeat_count=%ld",
+                 (long)size_comp, (long)size_uncomp, (long)repeat_count);
+      return NULL;
+    }
+  /* If repeat_count is zero or negative, treat as 1 to avoid zero-sized RS blocks */
+  if (repeat_count <= 0)
+    {
+      LOG_TRACE ("Adjusting repeat_count from %ld to 1", (long)repeat_count);
+      repeat_count = 1;
+    }
+
+  /* Round to a multiple of 8 */
   pesize = ((size_comp + 7) & ~7) * repeat_count;
-  // Divide pre encoded size by RS k-value (239)
+  /* Divide pre encoded size by RS k-value (239) */
   block_count = (pesize + 238) / 239;
-  // Multiply with codeword size (255) and round to a multiple of 8
+  /* Multiply with codeword size (255) and round to a multiple of 8 */
   page_size = (block_count * 255 + 7) & ~7;
 
-  assert ((uint64_t)size_comp < dat->size);
-  assert ((uint64_t)size_uncomp < dat->size);
-  assert ((uint64_t)repeat_count < DBG_MAX_COUNT);
-  assert ((uint64_t)page_size < DBG_MAX_COUNT);
+  /* Validate values and prevent integer overflows when allocating */
+  if ((uint64_t)size_comp >= dat->size || (uint64_t)size_uncomp >= dat->size)
+    {
+      LOG_ERROR ("Invalid sizes larger than file: size_comp=%ld size_uncomp=%ld dat->size=%lu",
+                 (long)size_comp, (long)size_uncomp, dat->size);
+      return NULL;
+    }
+  if ((uint64_t)repeat_count >= DBG_MAX_COUNT || (uint64_t)page_size >= DBG_MAX_COUNT)
+    {
+      LOG_ERROR ("Invalid repeat/page_size too large: repeat_count=%ld page_size=%ld",
+                 (long)repeat_count, (long)page_size);
+      return NULL;
+    }
 
   if ((unsigned long)page_size > dat->size - dat->byte) // bytes left to read
     {
@@ -643,10 +666,26 @@ read_system_page (Bit_Chain *dat, int64_t size_comp, int64_t size_uncomp,
                  dat->size - dat->byte);
       return NULL;
     }
-  data = (BITCODE_RC *)calloc (size_uncomp + page_size, 1);
+
+  /* Prevent overflow in size_uncomp + page_size */
+  if ((uint64_t)size_uncomp > SIZE_MAX - (uint64_t)page_size)
+    {
+      LOG_ERROR ("Integer overflow when computing allocation size");
+      return NULL;
+    }
+
+  size_t total_alloc = (size_t)size_uncomp + (size_t)page_size;
+  /* Sanity cap to avoid huge allocations from malformed files */
+  if (total_alloc > DBG_MAX_SIZE)
+    {
+      LOG_ERROR ("Requested allocation too large: %zu > %u", total_alloc, DBG_MAX_SIZE);
+      return NULL;
+    }
+
+  data = (BITCODE_RC *)calloc (total_alloc, 1);
   if (!data)
     {
-      LOG_ERROR ("Out of memory")
+      LOG_ERROR ("Out of memory");
       return NULL;
     }
 
@@ -660,10 +699,21 @@ read_system_page (Bit_Chain *dat, int64_t size_comp, int64_t size_uncomp,
       return NULL;
     }
 
+  /* Ensure that pedata actually contains enough bytes before copying */
   if (size_comp < size_uncomp)
     error = decompress_r2007 (data, size_uncomp, pedata, MIN (pedata_size, size_comp));
   else
-    memcpy (data, pedata, size_uncomp);
+    {
+      if ((uint64_t)pedata_size < (uint64_t)size_uncomp)
+        {
+          LOG_ERROR ("Pre-decoded data too small: pedata_size=%ld size_uncomp=%ld",
+                     pedata_size, (long)size_uncomp);
+          free (pedata);
+          free (data);
+          return NULL;
+        }
+      memcpy (data, pedata, (size_t)size_uncomp);
+    }
   free (pedata);
 
   if (error >= DWG_ERR_CRITICAL)
@@ -674,6 +724,7 @@ read_system_page (Bit_Chain *dat, int64_t size_comp, int64_t size_uncomp,
   return data;
 }
 
+
 static int
 read_data_page (Bit_Chain *restrict dat, BITCODE_RC *restrict decomp,
                 int64_t page_size, int64_t size_comp, int64_t size_uncomp)