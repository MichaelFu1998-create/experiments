diff --git a/libheif/uncompressed_image.cc b/libheif/uncompressed_image.cc
index 5218165..7bd5778 100644
--- a/libheif/uncompressed_image.cc
+++ b/libheif/uncompressed_image.cc
@@ -627,9 +627,7 @@ Error UncompressedImageCodec::decode_uncompressed_image(const std::shared_ptr<co
       if (width >= maximum_image_width_limit || height >= maximum_image_height_limit) {
         std::stringstream sstr;
         sstr << "Image size " << width << "x" << height << " exceeds the maximum image size "
-             << maximum_image_width_limit << "x" << maximum_image_height_limit << "\n";
-
-        return Error(heif_error_Memory_allocation_error,
+             << maximum_image_width_limit << "x" << maximum_image_height_limit << "\n"; return Error(heif_error_Memory_allocation_error,
                      heif_suberror_Security_limit_exceeded,
                      sstr.str());
       }
@@ -650,8 +648,7 @@ Error UncompressedImageCodec::decode_uncompressed_image(const std::shared_ptr<co
 
   // if we miss a required box, show error
 
-  if (!found_ispe || !cmpd || !uncC) {
-    return Error(heif_error_Unsupported_feature,
+  if (!found_ispe || !cmpd || !uncC) { return Error(heif_error_Unsupported_feature,
                  heif_suberror_Unsupported_data_version,
                  "Missing required box for uncompressed codec");
   }
@@ -664,17 +661,15 @@ Error UncompressedImageCodec::decode_uncompressed_image(const std::shared_ptr<co
     return error;
   }
 
-  img = std::make_shared<HeifPixelImage>();
   heif_chroma chroma;
   heif_colorspace colourspace;
   error = get_heif_chroma_uncompressed(uncC, cmpd, &chroma, &colourspace);
   if (error) {
     return error;
   }
-  img->create(width, height,
-              colourspace,
-              chroma);
 
+  // Build channel list and offsets WITHOUT allocating image planes yet. This allows us to
+  // validate that uncompressed_data contains enough bytes before allocating memory.
   std::vector<heif_channel> channels;
   std::map<heif_channel, uint32_t> channel_to_pixelOffset;
 
@@ -684,37 +679,30 @@ Error UncompressedImageCodec::decode_uncompressed_image(const std::shared_ptr<co
     uint16_t component_type = cmpd->get_components()[component_index].component_type;
     if (component_type == component_type_Y ||
         component_type == component_type_monochrome) {
-      img->add_plane(heif_channel_Y, width, height, component.component_bit_depth);
       channels.push_back(heif_channel_Y);
       channel_to_pixelOffset.emplace(heif_channel_Y, componentOffset);
     }
     else if (component_type == component_type_Cb) {
-      img->add_plane(heif_channel_Cb, width, height, component.component_bit_depth);
       channels.push_back(heif_channel_Cb);
       channel_to_pixelOffset.emplace(heif_channel_Cb, componentOffset);
     }
     else if (component_type == component_type_Cr) {
-      img->add_plane(heif_channel_Cr, width, height, component.component_bit_depth);
       channels.push_back(heif_channel_Cr);
       channel_to_pixelOffset.emplace(heif_channel_Cr, componentOffset);
     }
     else if (component_type == component_type_red) {
-      img->add_plane(heif_channel_R, width, height, component.component_bit_depth);
       channels.push_back(heif_channel_R);
       channel_to_pixelOffset.emplace(heif_channel_R, componentOffset);
     }
     else if (component_type == component_type_green) {
-      img->add_plane(heif_channel_G, width, height, component.component_bit_depth);
       channels.push_back(heif_channel_G);
       channel_to_pixelOffset.emplace(heif_channel_G, componentOffset);
     }
     else if (component_type == component_type_blue) {
-      img->add_plane(heif_channel_B, width, height, component.component_bit_depth);
       channels.push_back(heif_channel_B);
       channel_to_pixelOffset.emplace(heif_channel_B, componentOffset);
     }
     else if (component_type == component_type_alpha) {
-      img->add_plane(heif_channel_Alpha, width, height, component.component_bit_depth);
       channels.push_back(heif_channel_Alpha);
       channel_to_pixelOffset.emplace(heif_channel_Alpha, componentOffset);
     }
@@ -723,6 +711,57 @@ Error UncompressedImageCodec::decode_uncompressed_image(const std::shared_ptr<co
     componentOffset++;
   }
 
+  // Perform conservative size checks before allocating image planes.
+  size_t expected_min_size = 0;
+  const size_t up_bytes_per_channel = (size_t)width * (size_t)height;
+  if (uncC->get_interleave_type() == interleave_type_component) {
+    // Planar: at minimum each channel will have width*height bytes (for 8-bit).
+    expected_min_size = channels.size() * up_bytes_per_channel;
+  } else {
+    // For pixel or row interleaved data, expect at least width*height*bytes_per_pixel
+    size_t bytes_per_pixel = get_bytes_per_pixel(uncC);
+    expected_min_size = (size_t)width * (size_t)height * bytes_per_pixel;
+  }
+
+  if (uncompressed_data.size() < expected_min_size) {
+    return Error(heif_error_Invalid_input, heif_suberror_Invalid_parameter_value, "Uncompressed data too small");
+  }
+
+  // Now create the image and allocate planes.
+  auto new_img = std::make_shared<HeifPixelImage>();
+  new_img->create(width, height,
+              colourspace,
+              chroma);
+
+  for (Box_uncC::Component component : uncC->get_components()) {
+    uint16_t component_index = component.component_index;
+    uint16_t component_type = cmpd->get_components()[component_index].component_type;
+    if (component_type == component_type_Y ||
+        component_type == component_type_monochrome) {
+      new_img->add_plane(heif_channel_Y, width, height, component.component_bit_depth);
+    }
+    else if (component_type == component_type_Cb) {
+      new_img->add_plane(heif_channel_Cb, width, height, component.component_bit_depth);
+    }
+    else if (component_type == component_type_Cr) {
+      new_img->add_plane(heif_channel_Cr, width, height, component.component_bit_depth);
+    }
+    else if (component_type == component_type_red) {
+      new_img->add_plane(heif_channel_R, width, height, component.component_bit_depth);
+    }
+    else if (component_type == component_type_green) {
+      new_img->add_plane(heif_channel_G, width, height, component.component_bit_depth);
+    }
+    else if (component_type == component_type_blue) {
+      new_img->add_plane(heif_channel_B, width, height, component.component_bit_depth);
+    }
+    else if (component_type == component_type_alpha) {
+      new_img->add_plane(heif_channel_Alpha, width, height, component.component_bit_depth);
+    }
+
+    // TODO: other component types
+  }
+
   // TODO: properly interpret uncompressed_data per uncC config, subsampling etc.
   uint32_t bytes_per_channel = width * height;
   uint32_t numTileColumns = uncC->get_number_of_tile_columns();
@@ -741,9 +780,14 @@ Error UncompressedImageCodec::decode_uncompressed_image(const std::shared_ptr<co
     long unsigned int bytes_per_tile = content_bytes_per_tile + tile_padding;
     for (uint32_t c = 0; c < channels.size(); c++) {
       int stride;
-      uint8_t* dst = img->get_plane(channels[c], &stride);
+      uint8_t* dst = new_img->get_plane(channels[c], &stride);
       if ((numTileRows == 1) && (numTileColumns == 1) && (((uint32_t) stride) == width)) {
-        memcpy(dst, uncompressed_data.data() + c * bytes_per_channel, bytes_per_channel);
+        size_t src_off = (size_t)c * (size_t)bytes_per_channel;
+        size_t avail = 0;
+        if (src_off < uncompressed_data.size()) avail = uncompressed_data.size() - src_off;
+        size_t copy_len = std::min(avail, (size_t)bytes_per_channel);
+        if (copy_len > 0) memcpy(dst, uncompressed_data.data() + src_off, copy_len);
+        if (copy_len < (size_t)bytes_per_channel) memset(dst + copy_len, 0, (size_t)bytes_per_channel - copy_len);
       }
       else {
         int pixel_offset = channel_to_pixelOffset[channels[c]];
@@ -754,8 +798,16 @@ Error UncompressedImageCodec::decode_uncompressed_image(const std::shared_ptr<co
             uint32_t tile_idx = tile_idx_y * numTileColumns + tile_idx_x;
             long unsigned int tile_base_offset = tile_idx * bytes_per_tile;
             long unsigned int src_offset = tile_base_offset + pixel_offset * tile_width * tile_height;
-            long unsigned int dst_offset = row * stride + col;
-            memcpy(dst + dst_offset, uncompressed_data.data() + src_offset /** + row * tile_width **/, tile_width);   // TODO: ** is a hack
+            long unsigned int dst_offset = (long unsigned int)row * (unsigned int)stride + col;
+            size_t avail = 0;
+            if (src_offset < uncompressed_data.size()) avail = uncompressed_data.size() - src_offset;
+            size_t copy_len = std::min(avail, (size_t)tile_width);
+            size_t dst_total = (size_t)stride * (size_t)height;
+            size_t dst_space = 0;
+            if ((size_t)dst_offset < dst_total) dst_space = dst_total - (size_t)dst_offset;
+            if (copy_len > dst_space) copy_len = dst_space;
+            if (copy_len > 0) memcpy(dst + dst_offset, uncompressed_data.data() + src_offset /** + row * tile_width **/, copy_len);
+            if (copy_len < (size_t)tile_width) memset(dst + dst_offset + copy_len, 0, (size_t)tile_width - copy_len);
           }
         }
       }
@@ -770,7 +822,7 @@ Error UncompressedImageCodec::decode_uncompressed_image(const std::shared_ptr<co
     for (uint32_t c = 0; c < channels.size(); c++) {
       int pixel_offset = channel_to_pixelOffset[channels[c]];
       int stride;
-      uint8_t* dst = img->get_plane(channels[c], &stride);
+      uint8_t* dst = new_img->get_plane(channels[c], &stride);
       for (uint32_t row = 0; row < height; row++) {
         long unsigned int tile_row_idx = row % tile_height;
         size_t tile_row_offset = tile_width * tile_row_idx * channels.size();
@@ -781,6 +833,12 @@ Error UncompressedImageCodec::decode_uncompressed_image(const std::shared_ptr<co
           size_t tile_offset = tile_row_offset + tile_col * pixel_stride + pixel_offset;
           size_t src_offset = tile_base_offset + tile_offset;
           uint32_t dstPixelIndex = row * stride + col;
+          if (src_offset >= uncompressed_data.size()) {
+            new_img.reset(); return Error(heif_error_Invalid_input, heif_suberror_Invalid_parameter_value, "Uncompressed data too small for pixel copy");
+          }
+          if ((size_t)dstPixelIndex >= (size_t)stride * (size_t)height) {
+            new_img.reset(); return Error(heif_error_Invalid_input, heif_suberror_Invalid_parameter_value, "Destination index out of range");
+          }
           dst[dstPixelIndex] = src[src_offset];
         }
         for (; col < (uint32_t) stride; col++) {
@@ -797,7 +855,7 @@ Error UncompressedImageCodec::decode_uncompressed_image(const std::shared_ptr<co
     for (uint32_t c = 0; c < channels.size(); c++) {
       int pixel_offset = channel_to_pixelOffset[channels[c]];
       int stride;
-      uint8_t* dst = img->get_plane(channels[c], &stride);
+      uint8_t* dst = new_img->get_plane(channels[c], &stride);
       for (uint32_t row = 0; row < height; row++) {
         long unsigned int tile_row_idx = row % tile_height;
         size_t tile_row_offset = tile_width * (tile_row_idx * channels.size() + pixel_offset);
@@ -808,7 +866,15 @@ Error UncompressedImageCodec::decode_uncompressed_image(const std::shared_ptr<co
           size_t tile_offset = tile_row_offset + tile_col;
           size_t src_offset = tile_base_offset + tile_offset;
           uint32_t dst_offset = row * stride + col;
-          memcpy(dst + dst_offset, uncompressed_data.data() + src_offset, tile_width);
+          size_t avail = 0;
+          if (src_offset < uncompressed_data.size()) avail = uncompressed_data.size() - src_offset;
+          size_t copy_len = std::min(avail, (size_t)tile_width);
+          size_t dst_total = (size_t)stride * (size_t)height;
+          size_t dst_space = 0;
+          if ((size_t)dst_offset < dst_total) dst_space = dst_total - (size_t)dst_offset;
+          if (copy_len > dst_space) copy_len = dst_space;
+          if (copy_len > 0) memcpy(dst + dst_offset, uncompressed_data.data() + src_offset, copy_len);
+          if (copy_len < (size_t)tile_width) memset(dst + dst_offset + copy_len, 0, (size_t)tile_width - copy_len);
         }
         for (; col < (uint32_t) stride; col++) {
           uint32_t dstPixelIndex = row * stride + col;
@@ -826,7 +892,7 @@ Error fill_cmpd_and_uncC(std::shared_ptr<Box_cmpd>& cmpd, std::shared_ptr<Box_un
   if (colourspace == heif_colorspace_YCbCr) {
     if (!(image->has_channel(heif_channel_Y) && image->has_channel(heif_channel_Cb) && image->has_channel(heif_channel_Cr)))
     {
-      return Error(heif_error_Unsupported_feature,
+       return Error(heif_error_Unsupported_feature,
                    heif_suberror_Unsupported_data_version,
                    "Invalid colourspace / channel combination - YCbCr");
     }
@@ -859,7 +925,7 @@ Error fill_cmpd_and_uncC(std::shared_ptr<Box_cmpd>& cmpd, std::shared_ptr<Box_un
     }
     else
     {
-      return Error(heif_error_Unsupported_feature,
+       return Error(heif_error_Unsupported_feature,
                    heif_suberror_Unsupported_data_version,
                    "Unsupported YCbCr sub-sampling type");
     }
@@ -885,7 +951,7 @@ Error fill_cmpd_and_uncC(std::shared_ptr<Box_cmpd>& cmpd, std::shared_ptr<Box_un
           (image->get_chroma_format() == heif_chroma_interleaved_RRGGBB_LE) ||
           (image->get_chroma_format() == heif_chroma_interleaved_RRGGBBAA_BE) ||
           (image->get_chroma_format() == heif_chroma_interleaved_RRGGBBAA_LE))) {
-      return Error(heif_error_Unsupported_feature,
+       return Error(heif_error_Unsupported_feature,
                    heif_suberror_Unsupported_data_version,
                    "Unsupported colourspace / chroma combination - RGB");
     }
@@ -1006,7 +1072,7 @@ Error fill_cmpd_and_uncC(std::shared_ptr<Box_cmpd>& cmpd, std::shared_ptr<Box_un
   }
   else
   {
-    return Error(heif_error_Unsupported_feature,
+     return Error(heif_error_Unsupported_feature,
                  heif_suberror_Unsupported_data_version,
                  "Unsupported colourspace");
   }
@@ -1106,7 +1172,7 @@ Error UncompressedImageCodec::encode_uncompressed_image(const std::shared_ptr<He
     }
     else
     {
-      return Error(heif_error_Unsupported_feature,
+       return Error(heif_error_Unsupported_feature,
                    heif_suberror_Unsupported_data_version,
                    "Unsupported RGB chroma");
     }
@@ -1136,7 +1202,7 @@ Error UncompressedImageCodec::encode_uncompressed_image(const std::shared_ptr<He
   }
   else
   {
-    return Error(heif_error_Unsupported_feature,
+     return Error(heif_error_Unsupported_feature,
               heif_suberror_Unsupported_data_version,
               "Unsupported colourspace");
   }
@@ -1145,5 +1211,6 @@ Error UncompressedImageCodec::encode_uncompressed_image(const std::shared_ptr<He
   ispe->set_size(src_image->get_width(), src_image->get_height());
   heif_file->add_property(out_image->get_id(), ispe, true);
 
+
   return Error::Ok;
 }