diff --git a/config.h b/config.h
new file mode 100644
index 0000000..be48641
--- /dev/null
+++ b/config.h
@@ -0,0 +1,136 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Define if building universal (internal helper macro) */
+/* #undef AC_APPLE_UNIVERSAL_BUILD */
+
+/* Define if you want to use libfaad together with Digital Radio Mondiale
+   (DRM) */
+/* #undef DRM */
+
+/* Define if you want support for Digital Radio Mondiale (DRM) parametric
+   stereo */
+/* #undef DRM_PS */
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define HAVE_DLFCN_H 1
+
+/* Define to 1 if you have the <errno.h> header file. */
+#define HAVE_ERRNO_H 1
+
+/* Define if needed */
+/* #undef HAVE_FLOAT32_T */
+
+/* Define to 1 if you have the <float.h> header file. */
+#define HAVE_FLOAT_H 1
+
+/* Define to 1 if you have the `getpwuid' function. */
+#define HAVE_GETPWUID 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define if you have the IOKit API */
+/* #undef HAVE_IOKIT_IOKITLIB_H */
+
+/* Define to 1 if you have the <limits.h> header file. */
+#define HAVE_LIMITS_H 1
+
+/* Define if you have C99's lrintf function. */
+#define HAVE_LRINTF 1
+
+/* Define to 1 if you have the <mathf.h> header file. */
+/* #undef HAVE_MATHF_H */
+
+/* Define to 1 if you have the `memcpy' function. */
+#define HAVE_MEMCPY 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the `strchr' function. */
+#define HAVE_STRCHR 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the `strsep' function. */
+#define HAVE_STRSEP 1
+
+/* Define to 1 if you have the <sysfs/libsysfs.h> header file. */
+/* #undef HAVE_SYSFS_LIBSYSFS_H */
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#define HAVE_SYS_TIME_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to the sub-directory where libtool stores uninstalled libraries. */
+#define LT_OBJDIR ".libs/"
+
+/* Name of package */
+#define PACKAGE "faad2"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT ""
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "faad2"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "faad2 2.8.8"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "faad2"
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL ""
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "2.8.8"
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
+#define TIME_WITH_SYS_TIME 1
+
+/* Version number of package */
+#define VERSION "2.8.8"
+
+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
+   significant byte first (like Motorola and SPARC, unlike Intel). */
+#if defined AC_APPLE_UNIVERSAL_BUILD
+# if defined __BIG_ENDIAN__
+#  define WORDS_BIGENDIAN 1
+# endif
+#else
+# ifndef WORDS_BIGENDIAN
+/* #  undef WORDS_BIGENDIAN */
+# endif
+#endif
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
+/* #undef inline */
+#endif
+
+/* Define to `long int' if <sys/types.h> does not define. */
+/* #undef off_t */
diff --git a/libfaad/sbr_hfadj.c b/libfaad/sbr_hfadj.c
index 3f310b8..9353014 100644
--- a/libfaad/sbr_hfadj.c
+++ b/libfaad/sbr_hfadj.c
@@ -39,6 +39,7 @@
 #include "sbr_hfadj.h"
 
 #include "sbr_noise.h"
+#include <stdlib.h>
 
 
 /* static function declarations */
@@ -58,8 +59,18 @@ uint8_t hf_adjustment(sbr_info *sbr, qmf_t Xsbr[MAX_NTSRHFG][64]
 #endif
                       ,uint8_t ch)
 {
-    ALIGN sbr_hfadj_info adj = {{{0}}};
     uint8_t ret = 0;
+    /* allocate larger adj on heap to avoid stack-buffer-overflow for malformed inputs */
+    typedef struct {
+        real_t G_lim_boost[MAX_L_E][64];
+        real_t Q_M_lim_boost[MAX_L_E][64];
+        real_t S_M_boost[MAX_L_E][64];
+    } sbr_hfadj_info_safe;
+
+    sbr_hfadj_info_safe *adj_safe = (sbr_hfadj_info_safe*)calloc(1, sizeof(sbr_hfadj_info_safe));
+    if (!adj_safe) return 1;
+    sbr_hfadj_info *adj = (sbr_hfadj_info*)adj_safe;
+
 
     if (sbr->bs_frame_class[ch] == FIXFIX)
     {
@@ -76,18 +87,19 @@ uint8_t hf_adjustment(sbr_info *sbr, qmf_t Xsbr[MAX_NTSRHFG][64]
             sbr->l_A[ch] = sbr->L_E[ch] + 1 - sbr->bs_pointer[ch];
     }
 
-    ret = estimate_current_envelope(sbr, &adj, Xsbr, ch);
-    if (ret > 0)
-        return 1;
+    ret = estimate_current_envelope(sbr, adj, Xsbr, ch);
+    if (ret > 0) { free(adj_safe); return 1; }
 
-    calculate_gain(sbr, &adj, ch);
+    calculate_gain(sbr, adj, ch);
 
 #ifdef SBR_LOW_POWER
-    calc_gain_groups(sbr, &adj, deg, ch);
-    aliasing_reduction(sbr, &adj, deg, ch);
+    calc_gain_groups(sbr, adj, deg, ch);
+    aliasing_reduction(sbr, adj, deg, ch);
 #endif
 
-    hf_assembly(sbr, &adj, Xsbr, ch);
+    hf_assembly(sbr, adj, Xsbr, ch);
+
+    free(adj_safe);
 
     return 0;
 }
@@ -438,6 +450,15 @@ static real_t find_log2_Qplus1(sbr_info *sbr, uint8_t k, uint8_t l, uint8_t ch)
 
 static void calculate_gain(sbr_info *sbr, sbr_hfadj_info *adj, uint8_t ch)
 {
+    /* Clamp M/kx to safe bounds to avoid out-of-bounds indexing from malformed input */
+    if ((int)sbr->kx < 0) sbr->kx = 0;
+    if (sbr->M > 64) sbr->M = 64;
+    if ((int)sbr->M + (int)sbr->kx > 64) {
+        if (sbr->kx >= 64) sbr->kx = 0;
+        if (sbr->M > 64) sbr->M = 64;
+        if ((int)sbr->M + (int)sbr->kx > 64) sbr->M = 64 - sbr->kx;
+    }
+
     /* log2 values of limiter gains */
     static real_t limGain[] = {
         REAL_CONST(-1.0), REAL_CONST(0.0), REAL_CONST(1.0), REAL_CONST(33.219)
@@ -447,10 +468,10 @@ static void calculate_gain(sbr_info *sbr, sbr_hfadj_info *adj, uint8_t ch)
     uint8_t current_t_noise_band = 0;
     uint8_t S_mapped;
 
-    ALIGN real_t Q_M_lim[MAX_M];
-    ALIGN real_t G_lim[MAX_M];
+    ALIGN real_t Q_M_lim[64];
+    ALIGN real_t G_lim[64];
     ALIGN real_t G_boost;
-    ALIGN real_t S_M[MAX_M];
+    ALIGN real_t S_M[64];
 
 
     for (l = 0; l < sbr->L_E[ch]; l++)
@@ -670,20 +691,20 @@ static void calculate_gain(sbr_info *sbr, sbr_hfadj_info *adj, uint8_t ch)
             {
                 /* apply compensation to gain, noise floor sf's and sinusoid levels */
 #ifndef SBR_LOW_POWER
-                adj->G_lim_boost[l][m] = pow2_fix((G_lim[m] + G_boost) >> 1);
+                if ((int)m >= 0 && (int)m < MAX_M) { adj-> = pow2_fix((G_lim[m] + G_boost) >> 1); }
 #else
                 /* sqrt() will be done after the aliasing reduction to save a
                  * few multiplies
                  */
-                adj->G_lim_boost[l][m] = pow2_fix(G_lim[m] + G_boost);
+                if ((int)m >= 0 && (int)m < MAX_M) { adj-> = pow2_fix(G_lim[m] + G_boost); }
 #endif
-                adj->Q_M_lim_boost[l][m] = pow2_fix((Q_M_lim[m] + G_boost) >> 1);
+                if ((int)m >= 0 && (int)m < MAX_M) { adj-> = pow2_fix((Q_M_lim[m] + G_boost) >> 1); }
 
                 if (S_M[m] != LOG2_MIN_INF)
                 {
-                    adj->S_M_boost[l][m] = pow2_int((S_M[m] + G_boost) >> 1);
+                    if ((int)m >= 0 && (int)m < MAX_M) { adj-> = pow2_int((S_M[m] + G_boost) >> 1); }
                 } else {
-                    adj->S_M_boost[l][m] = 0;
+                    if ((int)m >= 0 && (int)m < MAX_M) { adj-> = 0; }
                 }
             }
         }
@@ -904,6 +925,15 @@ static real_t find_log2_Qplus1(sbr_info *sbr, uint8_t k, uint8_t l, uint8_t ch)
 
 static void calculate_gain(sbr_info *sbr, sbr_hfadj_info *adj, uint8_t ch)
 {
+    /* Clamp M/kx to safe bounds to avoid out-of-bounds indexing from malformed input */
+    if ((int)sbr->kx < 0) sbr->kx = 0;
+    if (sbr->M > 64) sbr->M = 64;
+    if ((int)sbr->M + (int)sbr->kx > 64) {
+        if (sbr->kx >= 64) sbr->kx = 0;
+        if (sbr->M > 64) sbr->M = 64;
+        if ((int)sbr->M + (int)sbr->kx > 64) sbr->M = 64 - sbr->kx;
+    }
+
     /* log2 values of limiter gains */
     static real_t limGain[] = { -1.0, 0.0, 1.0, 33.219 };
     uint8_t m, l, k;
@@ -911,10 +941,10 @@ static void calculate_gain(sbr_info *sbr, sbr_hfadj_info *adj, uint8_t ch)
     uint8_t current_t_noise_band = 0;
     uint8_t S_mapped;
 
-    ALIGN real_t Q_M_lim[MAX_M];
-    ALIGN real_t G_lim[MAX_M];
+    ALIGN real_t Q_M_lim[64];
+    ALIGN real_t G_lim[64];
     ALIGN real_t G_boost;
-    ALIGN real_t S_M[MAX_M];
+    ALIGN real_t S_M[64];
 
 
     for (l = 0; l < sbr->L_E[ch]; l++)
@@ -1129,20 +1159,20 @@ static void calculate_gain(sbr_info *sbr, sbr_hfadj_info *adj, uint8_t ch)
             {
                 /* apply compensation to gain, noise floor sf's and sinusoid levels */
 #ifndef SBR_LOW_POWER
-                adj->G_lim_boost[l][m] = QUANTISE2REAL(pow2((G_lim[m] + G_boost) / 2.0));
+                if ((int)m >= 0 && (int)m < MAX_M) { adj-> = QUANTISE2REAL(pow2((G_lim[m] + G_boost) / 2.0)); }
 #else
                 /* sqrt() will be done after the aliasing reduction to save a
                  * few multiplies
                  */
-                adj->G_lim_boost[l][m] = QUANTISE2REAL(pow2(G_lim[m] + G_boost));
+                if ((int)m >= 0 && (int)m < MAX_M) { adj-> = QUANTISE2REAL(pow2(G_lim[m] + G_boost)); }
 #endif
-                adj->Q_M_lim_boost[l][m] = QUANTISE2REAL(pow2((Q_M_lim[m] + 10 + G_boost) / 2.0));
+                if ((int)m >= 0 && (int)m < MAX_M) { adj-> = QUANTISE2REAL(pow2((Q_M_lim[m] + 10 + G_boost) / 2.0)); }
 
                 if (S_M[m] != LOG2_MIN_INF)
                 {
-                    adj->S_M_boost[l][m] = QUANTISE2REAL(pow2((S_M[m] + 10 + G_boost) / 2.0));
+                    if ((int)m >= 0 && (int)m < MAX_M) { adj-> = QUANTISE2REAL(pow2((S_M[m] + 10 + G_boost) / 2.0)); }
                 } else {
-                    adj->S_M_boost[l][m] = 0;
+                    if ((int)m >= 0 && (int)m < MAX_M) { adj-> = 0; }
                 }
             }
         }
@@ -1153,16 +1183,25 @@ static void calculate_gain(sbr_info *sbr, sbr_hfadj_info *adj, uint8_t ch)
 
 static void calculate_gain(sbr_info *sbr, sbr_hfadj_info *adj, uint8_t ch)
 {
+    /* Clamp M/kx to safe bounds to avoid out-of-bounds indexing from malformed input */
+    if ((int)sbr->kx < 0) sbr->kx = 0;
+    if (sbr->M > 64) sbr->M = 64;
+    if ((int)sbr->M + (int)sbr->kx > 64) {
+        if (sbr->kx >= 64) sbr->kx = 0;
+        if (sbr->M > 64) sbr->M = 64;
+        if ((int)sbr->M + (int)sbr->kx > 64) sbr->M = 64 - sbr->kx;
+    }
+
     static real_t limGain[] = { 0.5, 1.0, 2.0, 1e10 };
     uint8_t m, l, k;
 
     uint8_t current_t_noise_band = 0;
     uint8_t S_mapped;
 
-    ALIGN real_t Q_M_lim[MAX_M];
-    ALIGN real_t G_lim[MAX_M];
+    ALIGN real_t Q_M_lim[64];
+    ALIGN real_t G_lim[64];
     ALIGN real_t G_boost;
-    ALIGN real_t S_M[MAX_M];
+    ALIGN real_t S_M[64];
 
     for (l = 0; l < sbr->L_E[ch]; l++)
     {
@@ -1330,20 +1369,20 @@ static void calculate_gain(sbr_info *sbr, sbr_hfadj_info *adj, uint8_t ch)
             {
                 /* apply compensation to gain, noise floor sf's and sinusoid levels */
 #ifndef SBR_LOW_POWER
-                adj->G_lim_boost[l][m] = sqrt(G_lim[m] * G_boost);
+                if ((int)m >= 0 && (int)m < MAX_M) { adj-> = sqrt(G_lim[m] * G_boost); }
 #else
                 /* sqrt() will be done after the aliasing reduction to save a
                  * few multiplies
                  */
-                adj->G_lim_boost[l][m] = G_lim[m] * G_boost;
+                if ((int)m >= 0 && (int)m < MAX_M) { adj-> = G_lim[m] * G_boost; }
 #endif
-                adj->Q_M_lim_boost[l][m] = sqrt(Q_M_lim[m] * G_boost);
+                if ((int)m >= 0 && (int)m < MAX_M) { adj-> = sqrt(Q_M_lim[m] * G_boost); }
 
                 if (S_M[m] != 0)
                 {
-                    adj->S_M_boost[l][m] = sqrt(S_M[m] * G_boost);
+                    if ((int)m >= 0 && (int)m < MAX_M) { adj-> = sqrt(S_M[m] * G_boost); }
                 } else {
-                    adj->S_M_boost[l][m] = 0;
+                    if ((int)m >= 0 && (int)m < MAX_M) { adj-> = 0; }
                 }
             }
         }
@@ -1461,7 +1500,7 @@ static void aliasing_reduction(sbr_info *sbr, sbr_hfadj_info *adj, real_t *deg,
                     alpha = deg[m];
                 }
 
-                adj->G_lim_boost[l][m-sbr->kx] = MUL_C(alpha, G_target) +
+                int _idx = (int)m - (int)sbr->kx; if (_idx >= 0 && _idx < MAX_M) adj->G_lim_boost[l][_idx] = MUL_C(alpha, G_target) +
                     MUL_C((COEF_CONST(1)-alpha), adj->G_lim_boost[l][m-sbr->kx]);
 
                 /* acc: integer */
@@ -1486,9 +1525,9 @@ static void aliasing_reduction(sbr_info *sbr, sbr_hfadj_info *adj, real_t *deg,
             for(m = sbr->f_group[l][(k<<1)]; m < sbr->f_group[l][(k<<1) + 1]; m++)
             {
 #ifdef FIXED_POINT
-                adj->G_lim_boost[l][m-sbr->kx] = MUL_Q2(acc, adj->G_lim_boost[l][m-sbr->kx]);
+                int _idx = (int)m - (int)sbr->kx; if (_idx >= 0 && _idx < MAX_M) adj->G_lim_boost[l][_idx] = MUL_Q2(acc, adj->G_lim_boost[l][m-sbr->kx]);
 #else
-                adj->G_lim_boost[l][m-sbr->kx] = acc * adj->G_lim_boost[l][m-sbr->kx];
+                int _idx = (int)m - (int)sbr->kx; if (_idx >= 0 && _idx < MAX_M) adj->G_lim_boost[l][_idx] = acc * adj->G_lim_boost[l][m-sbr->kx];
 #endif
             }
         }
@@ -1502,9 +1541,9 @@ static void aliasing_reduction(sbr_info *sbr, sbr_hfadj_info *adj, real_t *deg,
                  m < sbr->f_table_lim[sbr->bs_limiter_bands][k+1]; m++)
             {
 #ifdef FIXED_POINT
-                 adj->G_lim_boost[l][m] = SBR_SQRT_Q2(adj->G_lim_boost[l][m]);
+                 if ((int)m >= 0 && (int)m < MAX_M) { adj-> = SBR_SQRT_Q2(adj->G_lim_boost[l][m]); }
 #else
-                 adj->G_lim_boost[l][m] = sqrt(adj->G_lim_boost[l][m]);
+                 if ((int)m >= 0 && (int)m < MAX_M) { adj-> = sqrt(adj->G_lim_boost[l][m]); }
 #endif
             }
         }
@@ -1574,8 +1613,11 @@ static void hf_assembly(sbr_info *sbr, sbr_hfadj_info *adj,
 #endif
 
             /* load new values into ringbuffer */
-            memcpy(sbr->G_temp_prev[ch][sbr->GQ_ringbuf_index[ch]], adj->G_lim_boost[l], sbr->M*sizeof(real_t));
-            memcpy(sbr->Q_temp_prev[ch][sbr->GQ_ringbuf_index[ch]], adj->Q_M_lim_boost[l], sbr->M*sizeof(real_t));
+            /* normalize ringbuffer index to avoid out-of-bounds in case of corrupted/uninitialized values */
+            int _gb = (int)sbr->GQ_ringbuf_index[ch];
+            if (_gb < 0 || _gb >= 5) _gb = 0;
+            memcpy(sbr->G_temp_prev[ch][_gb], adj->G_lim_boost[l], sbr->M*sizeof(real_t));
+            memcpy(sbr->Q_temp_prev[ch][_gb], adj->Q_M_lim_boost[l], sbr->M*sizeof(real_t));
 
             for (m = 0; m < sbr->M; m++)
             {
@@ -1587,15 +1629,15 @@ static void hf_assembly(sbr_info *sbr, sbr_hfadj_info *adj,
 #ifndef SBR_LOW_POWER
                 if (h_SL != 0)
                 {
-                	uint8_t ri = sbr->GQ_ringbuf_index[ch];
+                    /* compute safe base index and use explicit modulo to avoid negative or out-of-range indices */
+                    int ri_base = ((int)sbr->GQ_ringbuf_index[ch] + 5) % 5;
+                    int _ri;
                     for (n = 0; n <= 4; n++)
                     {
                         real_t curr_h_smooth = h_smooth[n];
-                        ri++;
-                        if (ri >= 5)
-                            ri -= 5;
-                        G_filt += MUL_F(sbr->G_temp_prev[ch][ri][m], curr_h_smooth);
-                        Q_filt += MUL_F(sbr->Q_temp_prev[ch][ri][m], curr_h_smooth);
+                        _ri = (ri_base + 1 + n) % 5;
+                        G_filt += MUL_F(sbr->G_temp_prev[ch][_ri][m], curr_h_smooth);
+                        Q_filt += MUL_F(sbr->Q_temp_prev[ch][_ri][m], curr_h_smooth);
                     }
                } else {
 #endif
@@ -1735,9 +1777,10 @@ static void hf_assembly(sbr_info *sbr, sbr_hfadj_info *adj,
             fIndexSine = (fIndexSine + 1) & 3;
 
             /* update the ringbuffer index used for filtering G and Q with h_smooth */
-            sbr->GQ_ringbuf_index[ch]++;
-            if (sbr->GQ_ringbuf_index[ch] >= 5)
-                sbr->GQ_ringbuf_index[ch] = 0;
+            _gb++;
+            if (_gb >= 5)
+                _gb = 0;
+            sbr->GQ_ringbuf_index[ch] = (int8_t)_gb;
         }
     }