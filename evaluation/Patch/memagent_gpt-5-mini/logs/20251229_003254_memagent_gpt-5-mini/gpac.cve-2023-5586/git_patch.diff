diff --git a/src/filter_core/filter_pck.c b/src/filter_core/filter_pck.c
index b093e8a70..2f69c71f2 100644
--- a/src/filter_core/filter_pck.c
+++ b/src/filter_core/filter_pck.c
@@ -101,6 +101,15 @@ static void pck_queue_enum(void *udta, void *item)
 
 static GF_FilterPacket *gf_filter_pck_new_alloc_internal(GF_FilterPid *pid, u32 data_size, u8 **data)
 {
+	if (!pid) {
+		GF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, ("NULL PID passed to gf_filter_pck_new_alloc_internal\n"));
+		return NULL;
+	}
+	if (!pid->filter) {
+		GF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, ("NULL filter in PID passed to gf_filter_pck_new_alloc_internal\n"));
+		return NULL;
+	}
+
 	GF_FilterPacket *pck=NULL;
 	GF_FilterPacket *closest=NULL;
 	u32 count, max_reservoir_size;
@@ -110,7 +119,7 @@ static GF_FilterPacket *gf_filter_pck_new_alloc_internal(GF_FilterPid *pid, u32
 		return NULL;
 	}
 
-	count = gf_fq_count(pid->filter->pcks_alloc_reservoir);
+	count = pid->filter->pcks_alloc_reservoir ? gf_fq_count(pid->filter->pcks_alloc_reservoir) : 0;
 
 	if (count) {
 		//don't let reservoir grow too large (may happen if burst of packets are stored/consumed in the upper chain)