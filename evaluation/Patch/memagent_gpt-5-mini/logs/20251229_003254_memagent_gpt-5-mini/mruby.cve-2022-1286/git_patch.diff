diff --git a/src/vm.c b/src/vm.c
index 5f2ef779a..d975dcd0c 100644
--- a/src/vm.c
+++ b/src/vm.c
@@ -284,10 +284,12 @@ mrb_env_unshare(mrb_state *mrb, struct REnv *e)
     if (!MRB_ENV_ONSTACK_P(e)) return;
     if (e->cxt != mrb->c) return;
     if (e == mrb_vm_ci_env(mrb->c->cibase)) return; /* for mirb */
-    p = (mrb_value *)mrb_malloc(mrb, sizeof(mrb_value)*len);
+    p = (mrb_value *)mrb_malloc(mrb, sizeof(mrb_value) * (len + 1));
     if (len > 0) {
       stack_copy(p, e->stack, len);
     }
+    /* ensure extra slot to prevent off-by-one reads */
+    SET_NIL_VALUE(p[len]);
     e->stack = p;
     MRB_ENV_CLOSE(e);
     mrb_write_barrier(mrb, (struct RBasic *)e);
@@ -1249,6 +1251,11 @@ RETRY_TRY_BLOCK:
     }
 
     CASE(OP_LOADL, BB) {
+      /* guard against malformed irep pool index */
+      if (!pool || b >= irep->plen) {
+        regs[a] = mrb_nil_value();
+        NEXT;
+      }
       switch (pool[b].tt) {   /* number */
       case IREP_TT_INT32:
         regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i32);
@@ -1843,7 +1850,7 @@ RETRY_TRY_BLOCK:
       else {
         struct REnv *e = uvenv(mrb, lv-1);
         if (!e) goto L_NOSUPER;
-        if (MRB_ENV_LEN(e) <= m1+r+m2+1)
+        if (MRB_ENV_LEN(e) <= m1+r+m2+2)
           goto L_NOSUPER;
         stack = e->stack + 1;
       }
@@ -2733,6 +2740,11 @@ RETRY_TRY_BLOCK:
     }
 
     CASE(OP_SYMBOL, BB) {
+      /* guard against malformed irep pool index */
+      if (!pool || b >= irep->plen) {
+        regs[a] = mrb_nil_value();
+        NEXT;
+      }
       size_t len;
       mrb_sym sym;
 
@@ -2749,6 +2761,11 @@ RETRY_TRY_BLOCK:
     }
 
     CASE(OP_STRING, BB) {
+      /* guard against malformed irep pool index */
+      if (!pool || b >= irep->plen) {
+        regs[a] = mrb_str_new_capa(mrb, 0);
+        NEXT;
+      }
       mrb_int len;
 
       mrb_assert((pool[b].tt&IREP_TT_NFLAG)==0);