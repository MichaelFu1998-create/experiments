diff --git a/MagickCore/statistic.c b/MagickCore/statistic.c
index a649880f4..60d280228 100644
--- a/MagickCore/statistic.c
+++ b/MagickCore/statistic.c
@@ -159,9 +159,26 @@ static PixelChannels **AcquirePixelThreadSet(const Image *image)
     i;
 
   size_t
-    number_threads;
+    number_threads,
+    length,
+    number_images,
+    columns=0;
+
+  const Image *p;
 
   number_threads=(size_t) GetMagickResourceLimit(ThreadResource);
+  /* determine required length: need to hold either columns (max across the
+     image list) or number of images because EvaluateImages uses this buffer
+     for two different indexing modes (per-column or per-image/median).
+     Allocate an extra slot (length+1) to provide a safe guard against
+     off-by-one indexing that existed in some evaluation paths. */
+  number_images=(size_t) GetImageListLength(image);
+  for (p=image; p != (const Image *) NULL; p=p->next)
+    if ((size_t) p->columns > columns)
+      columns=(size_t) p->columns;
+  length=columns;
+  if (number_images > length)
+    length=number_images;
   pixels=(PixelChannels **) AcquireQuantumMemory(number_threads,
     sizeof(*pixels));
   if (pixels == (PixelChannels **) NULL)
@@ -172,11 +189,15 @@ static PixelChannels **AcquirePixelThreadSet(const Image *image)
     register ssize_t
       j;
 
-    pixels[i]=(PixelChannels *) AcquireQuantumMemory(image->columns,
+    /* allocate extra elements to avoid out-of-bounds writes due to
+       off-by-one errors in callers. Use +2 and check for overflow. */
+    if (length >= (SIZE_MAX-2))
+      return(DestroyPixelThreadSet(pixels));
+    pixels[i]=(PixelChannels *) AcquireQuantumMemory((length+2),
       sizeof(**pixels));
     if (pixels[i] == (PixelChannels *) NULL)
       return(DestroyPixelThreadSet(pixels));
-    for (j=0; j < (ssize_t) image->columns; j++)
+    for (j=0; j < (ssize_t) (length+2); j++)
     {
       register ssize_t
         k;