diff --git a/src/interp/binary-reader-interp.cc b/src/interp/binary-reader-interp.cc
index 47a2d256..f2196d1a 100644
--- a/src/interp/binary-reader-interp.cc
+++ b/src/interp/binary-reader-interp.cc
@@ -295,7 +295,7 @@ class BinaryReaderInterp : public BinaryReaderNop {
                             Index* out_drop_count,
                             Index* out_keep_count);
   Result GetReturnDropKeepCount(Index* out_drop_count, Index* out_keep_count);
-  Result GetReturnCallDropKeepCount(const FuncType&,
+  Result GetReturnCallDropKeepCount(const FuncType*,
                                     Index keep_extra,
                                     Index* out_drop_count,
                                     Index* out_keep_count);
@@ -431,11 +431,14 @@ Result BinaryReaderInterp::GetReturnDropKeepCount(Index* out_drop_count,
   return Result::Ok;
 }
 
-Result BinaryReaderInterp::GetReturnCallDropKeepCount(const FuncType& func_type,
+Result BinaryReaderInterp::GetReturnCallDropKeepCount(const FuncType* func_type,
                                                       Index keep_extra,
                                                       Index* out_drop_count,
                                                       Index* out_keep_count) {
-  Index keep_count = static_cast<Index>(func_type.params.size()) + keep_extra;
+  Index keep_count = keep_extra;
+  if (func_type) {
+    keep_count += static_cast<Index>(func_type->params.size());
+  }
   CHECK_RESULT(GetDropCount(keep_count, 0, out_drop_count));
   *out_drop_count += validator_.GetLocalCount();
   *out_keep_count = keep_count;
@@ -504,6 +507,12 @@ Result BinaryReaderInterp::OnImportFunc(Index import_index,
                                         Index func_index,
                                         Index sig_index) {
   CHECK_RESULT(validator_.OnFunction(GetLocation(), Var(sig_index)));
+  if (sig_index >= module_.func_types.size()) {
+    PrintError("Invalid signature index in OnImportFunc: %u",
+               sig_index);
+    return Result::Ok;
+  }
+
   FuncType& func_type = module_.func_types[sig_index];
   module_.imports.push_back(ImportDesc{ImportType(
       std::string(module_name), std::string(field_name), func_type.Clone())});
@@ -558,7 +567,7 @@ Result BinaryReaderInterp::OnImportTag(Index import_index,
                                        Index tag_index,
                                        Index sig_index) {
   CHECK_RESULT(validator_.OnTag(GetLocation(), Var(sig_index)));
-  FuncType& func_type = module_.func_types[sig_index];
+    FuncType& func_type = module_.func_types[sig_index];
   TagType tag_type{TagAttr::Exception, func_type.params};
   module_.imports.push_back(ImportDesc{ImportType(
       std::string(module_name), std::string(field_name), tag_type.Clone())});
@@ -655,7 +664,7 @@ Result BinaryReaderInterp::OnTagCount(Index count) {
 
 Result BinaryReaderInterp::OnTagType(Index index, Index sig_index) {
   CHECK_RESULT(validator_.OnTag(GetLocation(), Var(sig_index)));
-  FuncType& func_type = module_.func_types[sig_index];
+    FuncType& func_type = module_.func_types[sig_index];
   TagType tag_type{TagAttr::Exception, func_type.params};
   module_.tags.push_back(TagDesc{tag_type});
   tag_types_.push_back(tag_type);
@@ -1110,11 +1119,16 @@ Result BinaryReaderInterp::OnCallIndirectExpr(Index sig_index,
 }
 
 Result BinaryReaderInterp::OnReturnCallExpr(Index func_index) {
-  FuncType& func_type = func_types_[func_index];
+  FuncType func_type = (func_index < func_types_.size()) ? func_types_[func_index] : FuncType{{}, {}};
+  if (func_index >= func_types_.size()) {
+    PrintError("Invalid function index in OnReturnCallExpr: %u", func_index);
+    // Skip emitting instructions for invalid function index to continue parsing.
+    return Result::Ok;
+  }
 
   Index drop_count, keep_count, catch_drop_count;
   CHECK_RESULT(
-      GetReturnCallDropKeepCount(func_type, 0, &drop_count, &keep_count));
+      GetReturnCallDropKeepCount((func_index < func_types_.size()) ? &func_types_[func_index] : nullptr, 0, &drop_count, &keep_count));
   CHECK_RESULT(
       validator_.GetCatchCount(label_stack_.size() - 1, &catch_drop_count));
   // The validator must be run after we get the drop/keep counts, since it
@@ -1139,12 +1153,26 @@ Result BinaryReaderInterp::OnReturnCallExpr(Index func_index) {
 
 Result BinaryReaderInterp::OnReturnCallIndirectExpr(Index sig_index,
                                                     Index table_index) {
-  FuncType& func_type = module_.func_types[sig_index];
-
   Index drop_count, keep_count, catch_drop_count;
+  // Validate signature and table indices before accessing vectors.
+  if (sig_index >= module_.func_types.size()) {
+    PrintError("Invalid signature index in OnReturnCallIndirectExpr: %u",
+               sig_index);
+    // Recover from malformed input: continue parsing without emitting
+    // ReturnCallIndirect instruction to avoid crashes.
+    return Result::Ok;
+  }
+  if (table_index >= module_.tables.size()) {
+    PrintError("Invalid table index in OnReturnCallIndirectExpr: %u",
+               table_index);
+    // Recover from malformed input: continue parsing.
+    return Result::Ok;
+  }
+
+    FuncType& func_type = module_.func_types[sig_index];
   // +1 to include the index of the function.
   CHECK_RESULT(
-      GetReturnCallDropKeepCount(func_type, +1, &drop_count, &keep_count));
+      GetReturnCallDropKeepCount((sig_index < module_.func_types.size()) ? &module_.func_types[sig_index] : nullptr, +1, &drop_count, &keep_count));
   CHECK_RESULT(
       validator_.GetCatchCount(label_stack_.size() - 1, &catch_drop_count));
   // The validator must be run after we get the drop/keep counts, since it