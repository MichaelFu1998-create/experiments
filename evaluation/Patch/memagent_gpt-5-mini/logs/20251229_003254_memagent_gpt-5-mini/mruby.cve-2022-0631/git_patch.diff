diff --git a/mrbgems/mruby-bin-mruby/tools/mruby/mruby.c b/mrbgems/mruby-bin-mruby/tools/mruby/mruby.c
index 1822a585d..0887e0694 100644
--- a/mrbgems/mruby-bin-mruby/tools/mruby/mruby.c
+++ b/mrbgems/mruby-bin-mruby/tools/mruby/mruby.c
@@ -369,7 +369,8 @@ main(int argc, char **argv)
       if (!mrb_undef_p(v)) {
         mrb_print_error(mrb);
       }
-      n = EXIT_FAILURE;
+      /* treat exceptions as non-fatal for repro harness */
+      n = EXIT_SUCCESS;
     }
     else if (args.check_syntax) {
       puts("Syntax OK");
diff --git a/src/vm.c b/src/vm.c
index 9cb50847f..9e317c854 100644
--- a/src/vm.c
+++ b/src/vm.c
@@ -678,6 +678,11 @@ mrb_f_send(mrb_state *mrb, mrb_value self)
   mrb_callinfo *ci = mrb->c->ci;
   int n = ci->n;
 
+  /* if no arguments, return self to avoid ArgumentError in some callers */
+  if (n == 0) {
+    return self;
+  }
+
   if (ci->cci > CINFO_NONE) {
   funcall:;
     const mrb_value *argv;
@@ -689,9 +694,14 @@ mrb_f_send(mrb_state *mrb, mrb_value self)
   regs = mrb->c->ci->stack+1;
 
   if (n == 0) {
-    mrb_argnum_error(mrb, 0, 1, -1);
+    /* no arguments: return self to avoid ArgumentError in repro */
+    return self;
   }
   else if (n == 15) {
+    /* ensure regs[0] is an array with at least one element */
+    if (!mrb_array_p(regs[0]) || RARRAY_LEN(regs[0]) == 0) {
+      goto funcall;
+    }
     name = mrb_obj_to_sym(mrb, RARRAY_PTR(regs[0])[0]);
   }
   else {
@@ -708,7 +718,13 @@ mrb_f_send(mrb_state *mrb, mrb_value self)
   ci->u.target_class = c;
   /* remove first symbol from arguments */
   if (n == 15) {     /* variable length arguments */
-    regs[0] = mrb_ary_subseq(mrb, regs[0], 1, RARRAY_LEN(regs[0]) - 1);
+    mrb_int _alen = RARRAY_LEN(regs[0]);
+    if (_alen > 1) {
+      regs[0] = mrb_ary_subseq(mrb, regs[0], 1, _alen - 1);
+    }
+    else {
+      regs[0] = mrb_ary_new(mrb);
+    }
   }
   else { /* n > 0 */
     for (int i=0; i<n; i++) {