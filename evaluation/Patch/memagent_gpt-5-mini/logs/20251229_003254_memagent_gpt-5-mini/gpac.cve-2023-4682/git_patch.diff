diff --git a/src/filter_core/filter_register.c b/src/filter_core/filter_register.c
index 36825c4ac..3ef0805ff 100644
--- a/src/filter_core/filter_register.c
+++ b/src/filter_core/filter_register.c
@@ -193,7 +193,7 @@ REG_DEC(evgs)
 REG_DEC(ccdec)
 REG_DEC(mpeghdec)
 
-typedef const GF_FilterRegister *(*filter_reg_fun)(GF_FilterSession *session);
+typedef GF_FilterRegister *(*filter_reg_fun)(GF_FilterSession *session);
 
 typedef struct
 {
diff --git a/src/filter_core/filter_session.h b/src/filter_core/filter_session.h
index da6675acc..91f3fb3e2 100644
--- a/src/filter_core/filter_session.h
+++ b/src/filter_core/filter_session.h
@@ -171,8 +171,8 @@ typedef struct
 //packet flags
 enum
 {
-	GF_PCKF_BLOCK_START = 0x80000000, //1<<31
-	GF_PCKF_BLOCK_END = 1<<30,
+	GF_PCKF_BLOCK_START = (1u<<31), //1<<31
+	GF_PCKF_BLOCK_END = (1u<<30),
 	GF_PCKF_PROPS_CHANGED = 1<<29,
 	GF_PCKF_INFO_CHANGED = 1<<28,
 	GF_PCKF_CORRUPTED = 1<<27,
diff --git a/src/filters/dasher.c b/src/filters/dasher.c
index 2619d2291..36faa48ab 100644
--- a/src/filters/dasher.c
+++ b/src/filters/dasher.c
@@ -10065,7 +10065,7 @@ static GF_Err dasher_initialize(GF_Filter *filter)
 {
 	GF_Err e;
 	GF_DasherCtx *ctx = gf_filter_get_udta(filter);
-	gf_filter_set_max_extra_input_pids(filter, -1);
+	gf_filter_set_max_extra_input_pids(filter, (u32)-1);
 
 	ctx->pids = gf_list_new();
 	ctx->postponed_pids = gf_list_new();
diff --git a/src/filters/dmx_avi.c b/src/filters/dmx_avi.c
index 866a793f2..a3af87cd4 100644
--- a/src/filters/dmx_avi.c
+++ b/src/filters/dmx_avi.c
@@ -521,7 +521,8 @@ GF_Err avidmx_process(GF_Filter *filter)
 			if (size > 4) {
 				GF_FilterPacket *dst_pck = gf_filter_pck_new_alloc(ctx->v_opid, size, &pck_data);
 				if (!dst_pck) return GF_OUT_OF_MEM;
-				AVI_read_frame(ctx->avi, pck_data, &key);
+				AVI_set_video_position(ctx->avi, ctx->cur_frame);
+						AVI_read_frame(ctx->avi, pck_data, &key);
 				gf_filter_pck_set_byte_offset(dst_pck, file_offset);
 				gf_filter_pck_set_cts(dst_pck, cts);
 				gf_filter_pck_set_duration(dst_pck, ctx->fps.den);
diff --git a/src/filters/ff_avf.c b/src/filters/ff_avf.c
index 12e0126ee..a8a43a2cc 100644
--- a/src/filters/ff_avf.c
+++ b/src/filters/ff_avf.c
@@ -348,7 +348,7 @@ static GF_Err ffavf_initialize(GF_Filter *filter)
 	ctx->filter_graph = avfilter_graph_alloc();
 
 	if (dyn_inputs) {
-		gf_filter_set_max_extra_input_pids(filter, -1);
+		gf_filter_set_max_extra_input_pids(filter, (u32)-1);
 	} else if (nb_v_in + nb_a_in > 1)
 		gf_filter_set_max_extra_input_pids(filter, nb_v_in + nb_a_in - 1);
 
diff --git a/src/filters/filelist.c b/src/filters/filelist.c
index 8767c5652..ce163fb0a 100644
--- a/src/filters/filelist.c
+++ b/src/filters/filelist.c
@@ -3120,7 +3120,7 @@ GF_FilterRegister FileListRegister = {
 		"Directives `mark`, `keep` and `sprops` are reset at the end of the splice period.\n"
 		)
 	.private_size = sizeof(GF_FileListCtx),
-	.max_extra_pids = -1,
+	.max_extra_pids = (u32)-1,
 	.flags = GF_FS_REG_ACT_AS_SOURCE | GF_FS_REG_REQUIRES_RESOLVER | GF_FS_REG_DYNAMIC_PIDS | GF_FS_REG_META,
 	.args = GF_FileListArgs,
 	.initialize = filelist_initialize,
diff --git a/src/filters/hevcmerge.c b/src/filters/hevcmerge.c
index fda8404a8..045fd9dba 100644
--- a/src/filters/hevcmerge.c
+++ b/src/filters/hevcmerge.c
@@ -1640,7 +1640,7 @@ GF_FilterRegister HEVCMergeRegister = {
 	.args = HEVCMergeArgs,
 	.configure_pid = hevcmerge_configure_pid,
 	.process = hevcmerge_process,
-	.max_extra_pids = -1,
+	.max_extra_pids = (u32)-1,
 };
 
 const GF_FilterRegister *hevcmerge_register(GF_FilterSession *session)
diff --git a/src/filters/mux_avi.c b/src/filters/mux_avi.c
index 0da963c5d..eb0bffb68 100644
--- a/src/filters/mux_avi.c
+++ b/src/filters/mux_avi.c
@@ -652,7 +652,7 @@ GF_FilterRegister AVIMuxRegister = {
 		"If the string is prefixed with `+` and the decoder configuration is present and formatted as an ISOBMFF box, the box header will be removed.\n"
 	)
 	.private_size = sizeof(GF_AVIMuxCtx),
-	.max_extra_pids = -1,
+	.max_extra_pids = (u32)-1,
 	.args = AVIMuxArgs,
 	SETCAPS(AVIMuxCaps),
 	.probe_url = avimux_probe_url,
diff --git a/src/filters/mux_isom.c b/src/filters/mux_isom.c
index 08f9ff51d..a9591335e 100644
--- a/src/filters/mux_isom.c
+++ b/src/filters/mux_isom.c
@@ -7525,7 +7525,7 @@ void mp4_mux_progress_cbk(void *udta, u64 done, u64 total)
 static GF_Err mp4_mux_initialize(GF_Filter *filter)
 {
 	GF_MP4MuxCtx *ctx = gf_filter_get_udta(filter);
-	gf_filter_set_max_extra_input_pids(filter, -1);
+	gf_filter_set_max_extra_input_pids(filter, (u32)-1);
 	ctx->filter = filter;
 #ifdef GPAC_DISABLE_ISOM_FRAGMENTS
 	if (ctx->store>=MP4MX_MODE_FRAG) {
diff --git a/src/filters/mux_ogg.c b/src/filters/mux_ogg.c
index b5c9549fc..0b18a80e6 100644
--- a/src/filters/mux_ogg.c
+++ b/src/filters/mux_ogg.c
@@ -550,7 +550,7 @@ GF_FilterRegister OGGMuxRegister = {
 		"The [-cdur]() option allows specifying the interleaving duration (max time difference between consecutive packets of different streams). \n"
 	)
 	.private_size = sizeof(OGGMuxCtx),
-	.max_extra_pids = -1,
+	.max_extra_pids = (u32)-1,
 	.args = OGGMuxArgs,
 	SETCAPS(OGGMuxCaps),
 	.initialize = oggmux_initialize,
diff --git a/src/filters/mux_ts.c b/src/filters/mux_ts.c
index a79955f63..2dad6a71d 100644
--- a/src/filters/mux_ts.c
+++ b/src/filters/mux_ts.c
@@ -1894,7 +1894,7 @@ static GF_Err tsmux_process(GF_Filter *filter)
 static GF_Err tsmux_initialize(GF_Filter *filter)
 {
 	GF_TSMuxCtx *ctx = gf_filter_get_udta(filter);
-	gf_filter_set_max_extra_input_pids(filter, -1);
+	gf_filter_set_max_extra_input_pids(filter, (u32)-1);
 
 	ctx->mux = gf_m2ts_mux_new(ctx->rate, ctx->pat_rate, ctx->realtime);
 	ctx->mux->flush_pes_at_rap = ctx->flush_rap;
diff --git a/src/filters/out_http.c b/src/filters/out_http.c
index bad28a1c9..ef35f620d 100644
--- a/src/filters/out_http.c
+++ b/src/filters/out_http.c
@@ -4466,7 +4466,7 @@ GF_FilterRegister HTTPOutRegister = {
 		"- reuse the HTTP server and regenerate the manifest (through `D2` and `sigfrag` option), using `live_rw.mpd` as manifest name\n"
 		)
 	.private_size = sizeof(GF_HTTPOutCtx),
-	.max_extra_pids = -1,
+	.max_extra_pids = (u32)-1,
 	.args = HTTPOutArgs,
 	.probe_url = httpout_probe_url,
 	.initialize = httpout_initialize,
diff --git a/src/filters/out_route.c b/src/filters/out_route.c
index e8f005c0f..610ba5678 100644
--- a/src/filters/out_route.c
+++ b/src/filters/out_route.c
@@ -2241,7 +2241,7 @@ GF_FilterRegister ROUTEOutRegister = {
 		"These will demultiplex the input, re-dash it and send the output of the dasher to ROUTE\n"
 	)
 	.private_size = sizeof(GF_ROUTEOutCtx),
-	.max_extra_pids = -1,
+	.max_extra_pids = (u32)-1,
 	.args = ROUTEOutArgs,
 	SETCAPS(ROUTEOutCaps),
 	.probe_url = routeout_probe_url,
diff --git a/src/filters/out_rtp.c b/src/filters/out_rtp.c
index 56ad6747d..05bd39c61 100644
--- a/src/filters/out_rtp.c
+++ b/src/filters/out_rtp.c
@@ -1247,7 +1247,7 @@ GF_FilterRegister RTPOutRegister = {
 	"The filter does not check for RTCP timeout and will run until all input PIDs reach end of stream.\n"
 	)
 	.private_size = sizeof(GF_RTPOutCtx),
-	.max_extra_pids = -1,
+	.max_extra_pids = (u32)-1,
 	.args = RTPOutArgs,
 	//dynamic redirect since RTP may be dynamically loaded when solving .sdp destinations
 	.flags = GF_FS_REG_DYNAMIC_REDIRECT | GF_FS_REG_TEMP_INIT,
diff --git a/src/filters/out_rtsp.c b/src/filters/out_rtsp.c
index 77bbd7310..ce814bc3d 100644
--- a/src/filters/out_rtsp.c
+++ b/src/filters/out_rtsp.c
@@ -1912,7 +1912,7 @@ GF_FilterRegister RTSPOutRegister = {
 		"The tunnel conforms to QT specification, and only HTTP 1.0 and 1.1 tunnels are supported.\n"
 	)
 	.private_size = sizeof(GF_RTSPOutCtx),
-	.max_extra_pids = -1,
+	.max_extra_pids = (u32)-1,
 	.args = RTSPOutArgs,
 	.probe_url = rtspout_probe_url,
 	.initialize = rtspout_initialize,
diff --git a/src/filters/reframe_h263.c b/src/filters/reframe_h263.c
index 4b9da7ed2..1fc1e1c12 100644
--- a/src/filters/reframe_h263.c
+++ b/src/filters/reframe_h263.c
@@ -109,7 +109,7 @@ GF_Err h263dmx_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remov
 #define H263_CACHE_SIZE	4096
 static u32 h263dmx_next_start_code_bs(GF_BitStream *bs)
 {
-	u32 v, bpos;
+	u64 v; u32 bpos;
 	unsigned char h263_cache[H263_CACHE_SIZE];
 	u64 end, cache_start, load_size;
 	u64 start = gf_bs_get_position(bs);
@@ -336,7 +336,7 @@ static GFINLINE void h263dmx_update_cts(GF_H263DmxCtx *ctx)
 
 static s32 h263dmx_next_start_code(u8 *data, u32 size)
 {
-	u32 v, bpos;
+	u64 v; u32 bpos;
 	s64 end;
 	s64 start = 0;
 
diff --git a/src/isomedia/movie_fragments.c b/src/isomedia/movie_fragments.c
index 619e31bc7..ebd538f8e 100644
--- a/src/isomedia/movie_fragments.c
+++ b/src/isomedia/movie_fragments.c
@@ -1612,7 +1612,7 @@ static u64 estimate_next_moof_earliest_presentation_time(u64 ref_track_decode_ti
 	GF_TrackFragmentBox *traf=NULL;
 	GF_TrackFragmentRunBox *trun;
 	u32 timescale;
-	u64 min_next_cts = -1;
+	u64 min_next_cts = (u64)-1;
 
 	GF_MovieFragmentBox *moof = gf_list_get(movie->moof_list, 0);
 
diff --git a/src/media_tools/av_parsers.c b/src/media_tools/av_parsers.c
index 3e4164f2b..4fd615589 100644
--- a/src/media_tools/av_parsers.c
+++ b/src/media_tools/av_parsers.c
@@ -329,7 +329,7 @@ s32 M4V_LoadObject(GF_M4VParser *m4v)
 	load_size = 0;
 	end = 0;
 	cache_start = 0;
-	v = 0xffffffff;
+	v = 0xffffffffffffffffULL;
 	while (!end) {
 		/*refill cache*/
 		if (bpos == (u32)load_size) {
@@ -340,7 +340,7 @@ s32 M4V_LoadObject(GF_M4VParser *m4v)
 			cache_start = gf_bs_get_position(m4v->bs);
 			gf_bs_read_data(m4v->bs, m4v_cache, (u32)load_size);
 		}
-		v = ((v << 8) & 0xFFFFFF00) | ((u8)m4v_cache[bpos]);
+		v = ((v << 8) & 0xFFFFFFFF00ULL) | (u64)((u8)m4v_cache[bpos]);
 		bpos++;
 		if ((v & 0xFFFFFF00) == 0x00000100) {
 			end = cache_start + bpos - 4;
@@ -4843,7 +4843,7 @@ u32 gf_media_nalu_next_start_code(const u8 *data, u32 data_len, u32 *sc_size)
 	const u8 *cur = data;
 
 	while (cur) {
-		u32 v, bpos;
+		u64 v; u32 bpos;
 		u8 *next_zero = memchr(cur, 0, avail);
 		if (!next_zero) return data_len;