diff --git a/src/decode_r2007.c b/src/decode_r2007.c
index 3b5af4c4..faaa1e3b 100644
--- a/src/decode_r2007.c
+++ b/src/decode_r2007.c
@@ -25,6 +25,7 @@
 #include <stdint.h>
 #include <sys/types.h>
 #include <stdbool.h>
+#include <stddef.h>
 #include <assert.h>
 #include "common.h"
 #include "bits.h"
@@ -166,16 +167,14 @@ static void read_instructions (BITCODE_RC *restrict *restrict src,
                                BITCODE_RC *restrict opcode,
                                uint32_t *restrict offset,
                                uint32_t *restrict length);
-static inline BITCODE_RC *copy_bytes_2 (BITCODE_RC *restrict dst,
-                                        const BITCODE_RC *restrict src);
-static inline BITCODE_RC *copy_bytes_3 (BITCODE_RC *restrict dst,
-                                        const BITCODE_RC *restrict src);
+static inline BITCODE_RC *copy_bytes_2 (BITCODE_RC *dst, const BITCODE_RC *src, BITCODE_RC *dst_end, const BITCODE_RC *src_end);
+static inline BITCODE_RC *copy_bytes_3 (BITCODE_RC *dst, const BITCODE_RC *src, BITCODE_RC *dst_end, const BITCODE_RC *src_end);
 static void copy_bytes (BITCODE_RC *dst, uint32_t length, uint32_t offset);
 static uint32_t read_literal_length (BITCODE_RC *restrict *restrict src,
                                      unsigned char opcode);
-static void copy_compressed_bytes (BITCODE_RC *restrict dst,
+static int copy_compressed_bytes (BITCODE_RC *restrict dst,
                                    BITCODE_RC *restrict src,
-                                   int length);
+                                   int length, BITCODE_RC *restrict dst_end, BITCODE_RC *restrict src_end);
 static DWGCHAR *bfr_read_string (BITCODE_RC *restrict *restrict src,
                                  int64_t size) ATTRIBUTE_MALLOC;
 static BITCODE_RC *decode_rs (const BITCODE_RC *src, int block_count,
@@ -183,36 +182,41 @@ static BITCODE_RC *decode_rs (const BITCODE_RC *src, int block_count,
 static int decompress_r2007 (BITCODE_RC *restrict dst, const unsigned dst_size,
                              BITCODE_RC *restrict src, const unsigned src_size);
 
-#define copy_1(offset) *dst++ = *(src + offset);
+#define copy_1(offset)                                                         do {                                                                           if (dst + 1 > dst_end || src + (offset) + 1 > src_end) {                       LOG_ERROR ("Decompression error: copy overflow"); return DWG_ERR_INTERNALERROR;                                                                    }                                                                            *dst++ = *(src + (offset));                                                 } while (0)
 
-#define copy_2(offset) dst = copy_bytes_2 (dst, src + offset);
+#define copy_2(offset)                                                         do {                                                                           dst = copy_bytes_2 (dst, src + (offset), dst_end, src_end);                  if (dst == NULL) return DWG_ERR_INTERNALERROR;                                                                  } while (0)
 
-#define copy_3(offset) dst = copy_bytes_3 (dst, src + offset)
+#define copy_3(offset)                                                         do {                                                                           dst = copy_bytes_3 (dst, src + (offset), dst_end, src_end);                  if (dst == NULL) return DWG_ERR_INTERNALERROR;                                                                  } while (0)
 
 // 4 and 8 is not reverse, 16 is
-#define copy_n(n, offset)                                                     \
-  memcpy (dst, &src[offset], n);                                              \
-  dst += n
+#define copy_n(n, offset)                                                       do {                                                                           if (dst + (n) > dst_end || src + (offset) + (n) > src_end) {                   LOG_ERROR ("Decompression error: copy overflow"); return DWG_ERR_INTERNALERROR;                                                                    }                                                                            memcpy (dst, &src[(offset)], (n));                                           dst += (n);                                                                } while (0)
 
 #define copy_4(offset) copy_n (4, offset)
 #define copy_8(offset) copy_n (8, offset)
-#define copy_16(offset)                                                       \
-  memcpy (dst, &src[offset + 8], 8);                                          \
-  memcpy (&dst[8], &src[offset], 8);                                          \
-  dst += 16
+#define copy_16(offset)                                                         do {                                                                           if (dst + 16 > dst_end || src + (offset) + 16 > src_end) {                    LOG_ERROR ("Decompression error: copy overflow"); return DWG_ERR_INTERNALERROR;                                                                    }                                                                            memcpy (dst, &src[(offset) + 8], 8);                                         memcpy (&dst[8], &src[(offset)], 8);                                         dst += 16;                                                                 } while (0)
 
 /* Don't use restrict here: GH #141 broken for most newer compilers */
 static inline BITCODE_RC *
-copy_bytes_2 (BITCODE_RC *dst, const BITCODE_RC *src)
+copy_bytes_2 (BITCODE_RC *dst, const BITCODE_RC *src, BITCODE_RC *dst_end, const BITCODE_RC *src_end)
 {
+  if (dst + 2 > dst_end || src + 2 > src_end)
+    {
+      LOG_ERROR ("Decompression error: copy overflow");
+      return NULL;
+    }
   dst[0] = src[1];
   dst[1] = src[0];
   return dst + 2;
 }
 
 static inline BITCODE_RC *
-copy_bytes_3 (BITCODE_RC *dst, const BITCODE_RC *src)
+copy_bytes_3 (BITCODE_RC *dst, const BITCODE_RC *src, BITCODE_RC *dst_end, const BITCODE_RC *src_end)
 {
+  if (dst + 3 > dst_end || src + 3 > src_end)
+    {
+      LOG_ERROR ("Decompression error: copy overflow");
+      return NULL;
+    }
   dst[0] = src[2];
   dst[1] = src[1];
   dst[2] = src[0];
@@ -229,171 +233,28 @@ copy_bytes (BITCODE_RC *dst, uint32_t length, uint32_t offset)
 }
 
 /* See spec version 5.0 page 30 */
-static void
+static int
 copy_compressed_bytes (BITCODE_RC *restrict dst, BITCODE_RC *restrict src,
-                       int length)
+                       int length, BITCODE_RC *restrict dst_end, BITCODE_RC *restrict src_end)
 {
-  while (length >= 32)
-    {
-      copy_16 (16);
-      copy_16 (0);
-
-      src += 32;
-      length -= 32;
+  /* Simplified safe implementation: perform a bounds-checked memcpy of the
+     requested literal bytes. The original implementation used several fixed
+     size chunked memcpys and byte shuffles which could read/write beyond
+     the provided buffers when parsing crafted files. For security, prefer a
+     simple bounded copy that cannot overflow. */
+  if (length < 0)
+    {
+      LOG_ERROR ("Decompression error: negative length");
+      return DWG_ERR_INTERNALERROR;
     }
-
-  switch (length)
+  if ((dst + length) > dst_end || (src + length) > src_end)
     {
-    case 0:
-      break;
-    case 1:
-      copy_1 (0);
-      break;
-    case 2:
-      copy_2 (0);
-      break;
-    case 3:
-      copy_3 (0);
-      break;
-    case 4:
-      copy_4 (0);
-      break;
-    case 5:
-      copy_1 (4);
-      copy_4 (0);
-      break;
-    case 6:
-      copy_1 (5);
-      copy_4 (1);
-      copy_1 (0);
-      break;
-    case 7:
-      copy_2 (5);
-      copy_4 (1);
-      copy_1 (0);
-      break;
-    case 8:
-      copy_8 (0);
-      break;
-    case 9:
-      copy_1 (8);
-      copy_8 (0);
-      break;
-    case 10:
-      copy_1 (9);
-      copy_8 (1);
-      copy_1 (0);
-      break;
-    case 11:
-      copy_2 (9);
-      copy_8 (1);
-      copy_1 (0);
-      break;
-    case 12:
-      copy_4 (8);
-      copy_8 (0);
-      break;
-    case 13:
-      copy_1 (12);
-      copy_4 (8);
-      copy_8 (0);
-      break;
-    case 14:
-      copy_1 (13);
-      copy_4 (9);
-      copy_8 (1);
-      copy_1 (0);
-      break;
-    case 15:
-      copy_2 (13);
-      copy_4 (9);
-      copy_8 (1);
-      copy_1 (0);
-      break;
-    case 16:
-      copy_16 (0);
-      break;
-    case 17:
-      copy_8 (9);
-      copy_1 (8);
-      copy_8 (0);
-      break;
-    case 18:
-      copy_1 (17);
-      copy_16 (1);
-      copy_1 (0);
-      break;
-    case 19:
-      copy_3 (16);
-      copy_16 (0);
-      break;
-    case 20:
-      copy_4 (16);
-      copy_16 (0);
-      break;
-    case 21:
-      copy_1 (20);
-      copy_4 (16);
-      copy_16 (0);
-      break;
-    case 22:
-      copy_2 (20);
-      copy_4 (16);
-      copy_16 (0);
-      break;
-    case 23:
-      copy_3 (20);
-      copy_4 (16);
-      copy_16 (0);
-      break;
-    case 24:
-      copy_8 (16);
-      copy_16 (0);
-      break;
-    case 25:
-      copy_8 (17);
-      copy_1 (16);
-      copy_16 (0);
-      break;
-    case 26:
-      copy_1 (25);
-      copy_8 (17);
-      copy_1 (16);
-      copy_16 (0);
-      break;
-    case 27:
-      copy_2 (25);
-      copy_8 (17);
-      copy_1 (16);
-      copy_16 (0);
-      break;
-    case 28:
-      copy_4 (24);
-      copy_8 (16);
-      copy_16 (0);
-      break;
-    case 29:
-      copy_1 (28);
-      copy_4 (24);
-      copy_8 (16);
-      copy_16 (0);
-      break;
-    case 30:
-      copy_2 (28);
-      copy_4 (24);
-      copy_8 (16);
-      copy_16 (0);
-      break;
-    case 31:
-      copy_1 (30);
-      copy_4 (26);
-      copy_8 (18);
-      copy_16 (2);
-      copy_2 (0);
-      break;
-    default:
-      LOG_ERROR ("Wrong length %d", length);
+      LOG_ERROR ("Decompression error: length overflow");
+      return DWG_ERR_INTERNALERROR;
     }
+  if (length > 0)
+    memcpy(dst, src, (size_t)length);
+  return 0;
 }
 
 /* See spec version 5.1 page 50 */
@@ -520,7 +381,8 @@ decompress_r2007 (BITCODE_RC *restrict dst, const unsigned dst_size,
         }
 
       LOG_INSANE("copy_compressed_bytes (%p, %p, %u)\n", dst, src, length);
-      copy_compressed_bytes (dst, src, length);
+      if (copy_compressed_bytes (dst, src, length, dst_end, src_end) != 0)
+        return DWG_ERR_INTERNALERROR;
 
       dst += length;
       src += length;
@@ -771,7 +633,11 @@ read_data_section (Bit_Chain *sec_dat, Bit_Chain *dat,
       LOG_ERROR ("Invalid max decompression size %" PRIu64, max_decomp_size);
       return DWG_ERR_INVALIDDWG;
     }
-  decomp = (BITCODE_RC *)calloc (max_decomp_size, 1);
+  /* Add a small padding to the allocation to defensively avoid
+     * tiny overruns inside the complex copy routine when parsing
+     * malformed files. The logical section size remains max_decomp_size. */
+  const size_t DECOMP_PADDING = 32;
+  decomp = (BITCODE_RC *)calloc (max_decomp_size + DECOMP_PADDING, 1);
   if (decomp == NULL)
     {
       LOG_ERROR ("Out of memory")
@@ -795,7 +661,9 @@ read_data_section (Bit_Chain *sec_dat, Bit_Chain *dat,
           LOG_ERROR ("Failed to find page %d", (int)section_page->id)
           return DWG_ERR_PAGENOTFOUND;
         }
-      if (section_page->offset > max_decomp_size)
+      /* Validate that the page fits into the declared section size. */
+      if (section_page->offset > max_decomp_size
+          || section_page->offset + section_page->uncomp_size > max_decomp_size)
         {
           free (decomp);
           LOG_ERROR ("Invalid section_page->offset %ld > %ld",