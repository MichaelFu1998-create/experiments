diff --git a/src/scenegraph/base_scenegraph.c b/src/scenegraph/base_scenegraph.c
index 305e7edc9..78712d1c4 100644
--- a/src/scenegraph/base_scenegraph.c
+++ b/src/scenegraph/base_scenegraph.c
@@ -666,9 +666,25 @@ GF_Err gf_node_try_destroy(GF_SceneGraph *sg, GF_Node *pNode, GF_Node *parentNod
 	/*if node has been destroyed, don't even look at it*/
 	if (gf_list_find(sg->exported_nodes, pNode)>=0) return GF_OK;
 	if (!pNode || !pNode->sgprivate->num_instances) return GF_OK;
+
+	/*
+	 * Mark the node as exported/destroying before attempting to unregister it.
+	 * Many callers (commands, scene manager) may hold multiple references to the
+	 * same GF_Node and attempt to destroy it several times during command
+	 * application. By placing the node in sg->exported_nodes we ensure any
+	 * subsequent gf_node_try_destroy calls will early-return instead of
+	 * dereferencing a pointer that may have been freed by gf_node_unregister.
+	 * The exported_nodes list is used as a temporary marker and is freed with
+	 * the scenegraph, matching the existing lifetime expectations.
+	 */
+	if (sg->exported_nodes && gf_list_find(sg->exported_nodes, pNode) < 0) {
+		gf_list_add(sg->exported_nodes, pNode);
+	}
+
 	return gf_node_unregister(pNode, parentNode);
 }
 
+
 GF_EXPORT
 GF_Err gf_node_unregister(GF_Node *pNode, GF_Node *parentNode)
 {
@@ -928,52 +944,85 @@ GF_Err gf_node_replace(GF_Node *node, GF_Node *new_node, Bool updateOrderedGroup
 #endif
 	Bool replace_root;
 
+	/* save scenegraph and owning proto early to avoid dereferencing node after it may be freed */
+	GF_SceneGraph *orig_sg = node && node->sgprivate ? node->sgprivate->scenegraph : NULL;
+	GF_ProtoInstance *orig_pOwningProto = orig_sg ? orig_sg->pOwningProto : NULL;
+	/* if node was already marked exported/destroying, skip replacement to avoid UAF */
+	if (orig_sg && orig_sg->exported_nodes && gf_list_find(orig_sg->exported_nodes, node) >= 0) return GF_OK;
+
 #ifndef GPAC_DISABLE_SVG
 	type = (node->sgprivate->tag>GF_NODE_RANGE_LAST_VRML) ? 1 : 0;
-	if (type) {
-		Replace_IRI(node->sgprivate->scenegraph, node, new_node);
+	if (type && orig_sg) {
+		Replace_IRI(orig_sg, node, new_node);
 	}
 #endif
 
 	/*first check if this is the root node*/
-	replace_root = (node->sgprivate->scenegraph->RootNode == node) ? 1 : 0;
+	replace_root = (orig_sg && orig_sg->RootNode == node) ? 1 : 0;
 
 #ifndef GPAC_DISABLE_VRML
 	/*check for proto replacement*/
 	replace_proto = 0;
-	if (node->sgprivate->scenegraph->pOwningProto
-	        && (gf_list_find(node->sgprivate->scenegraph->pOwningProto->node_code, node)>=0)) {
+	if (orig_sg && orig_sg->pOwningProto && (gf_list_find(orig_sg->pOwningProto->node_code, node)>=0)) {
 		replace_proto = 1;
 	}
 #endif
 
-	while (node->sgprivate->parents) {
-		Bool do_break = node->sgprivate->parents->next ? 0 : 1;
-		GF_Node *par = node->sgprivate->parents->node;
+	/* save scenegraph and owning proto to avoid dereferencing node after it may have been freed */
+	/* Copy parent pointers to a temporary list to avoid accessing node->sgprivate after
+	   the node may have been freed by gf_node_unregister. This prevents use-after-free
+	   when unregister frees the node during replacement callbacks. */
+	{
+		GF_List *parents_copy = gf_list_new();
+		GF_ParentList *cur = node->sgprivate->parents;
+		while (cur) {
+			gf_list_add(parents_copy, cur->node);
+			cur = cur->next;
+		}
+		GF_List *to_unregister = gf_list_new();
+		u32 i, count = gf_list_count(parents_copy);
+		for (i=0; i<count; i++) {
+			GF_Node *par = (GF_Node*)gf_list_get(parents_copy, i);
 
 #ifndef GPAC_DISABLE_SVG
-		if (type)
-			ReplaceIRINode(par, node, new_node);
-		else
+			if (type)
+				ReplaceIRINode(par, node, new_node);
+			else
 #endif
-			ReplaceDEFNode(par, node, new_node, updateOrderedGroup);
+				ReplaceDEFNode(par, node, new_node, updateOrderedGroup);
+
+			if (new_node) gf_node_register(new_node, par);
+			/* notify parent changed now that replacement happened */
+			gf_node_changed(par, NULL);
+			/* postpone unregister to avoid freeing node while still used for other parents */
+			gf_list_add(to_unregister, par);
+		}
 
-		if (new_node) gf_node_register(new_node, par);
-		gf_node_unregister(node, par);
-		gf_node_changed(par, NULL);
-		if (do_break) break;
+		/* now unregister from all parents, possibly freeing node */
+		count = gf_list_count(to_unregister);
+		for (i=0; i<count; i++) {
+			GF_Node *par = (GF_Node*)gf_list_get(to_unregister, i);
+			gf_node_unregister(node, par);
+		}
+
+		gf_list_del(parents_copy);
+		gf_list_del(to_unregister);
 	}
 
 	if (replace_root) {
-		GF_SceneGraph *pSG = node->sgprivate->scenegraph;
+		/* use saved scenegraph pointer to avoid accessing node after it may have been freed */
+		GF_SceneGraph *pSG = orig_sg;
 		gf_node_unregister(node, NULL);
 		pSG->RootNode = new_node;
 	}
 #ifndef GPAC_DISABLE_VRML
 	if (replace_proto) {
-		GF_SceneGraph *pSG = node->sgprivate->scenegraph;
-		gf_list_del_item(pSG->pOwningProto->node_code, node);
-		if (pSG->pOwningProto->RenderingNode==node) pSG->pOwningProto->RenderingNode = NULL;
+		GF_SceneGraph *pSG = orig_sg;
+		GF_ProtoInstance *own = orig_pOwningProto;
+		if (own) {
+			gf_list_del_item(own->node_code, node);
+			if (own->RenderingNode==node) own->RenderingNode = NULL;
+		}
 		gf_node_unregister(node, NULL);
 	}
 #endif
diff --git a/src/scenegraph/commands.c b/src/scenegraph/commands.c
index 505719dfd..fda590b90 100644
--- a/src/scenegraph/commands.c
+++ b/src/scenegraph/commands.c
@@ -61,19 +61,26 @@ void gf_sg_command_del(GF_Command *com)
 
 			switch (inf->fieldType) {
 			case GF_SG_VRML_SFNODE:
-				if (inf->new_node) gf_node_try_destroy(com->in_scene, inf->new_node, NULL);
-				break;
+			if (inf->new_node) {
+				GF_Node *tmpn = inf->new_node;
+				gf_node_try_destroy(com->in_scene, tmpn, NULL);
+				if (com->node == tmpn) com->node = NULL;
+				inf->new_node = NULL;
+			}
+			break;
 			case GF_SG_VRML_MFNODE:
-				if (inf->field_ptr) {
-					GF_ChildNodeItem *child;
-					child = inf->node_list;
-					while (child) {
-						GF_ChildNodeItem *cur = child;
-						gf_node_try_destroy(com->in_scene, child->node, NULL);
-						child = child->next;
-						gf_free(cur);
-					}
+			if (inf->field_ptr) {
+				GF_ChildNodeItem *child;
+				child = inf->node_list;
+				while (child) {
+					GF_ChildNodeItem *cur = child;
+					GF_Node *tmpn = child->node;
+					gf_node_try_destroy(com->in_scene, tmpn, NULL);
+					if (com->node == tmpn) com->node = NULL;
+					child = child->next;
+					gf_free(cur);
 				}
+			}
 				break;
 			default:
 				if (inf->field_ptr) gf_sg_vrml_field_pointer_del(inf->field_ptr, inf->fieldType);
@@ -88,17 +95,23 @@ void gf_sg_command_del(GF_Command *com)
 			GF_CommandField *inf = (GF_CommandField *)gf_list_get(com->command_fields, 0);
 			gf_list_rem(com->command_fields, 0);
 
-			if (inf->new_node)
+			if (inf->new_node) {
 				gf_node_try_destroy(com->in_scene, inf->new_node, NULL);
+				if (com->node == inf->new_node) com->node = NULL;
+				inf->new_node = NULL;
+			}
 			else if (inf->node_list) {
 				GF_ChildNodeItem *child;
 				child = inf->node_list;
 				while (child) {
-					GF_ChildNodeItem *cur = child;
-					gf_node_try_destroy(com->in_scene, child->node, NULL);
-					child = child->next;
-					gf_free(cur);
-				}
+				GF_ChildNodeItem *cur = child;
+				GF_Node *tmpn = child->node;
+				gf_node_try_destroy(com->in_scene, tmpn, NULL);
+				if (com->node == tmpn) com->node = NULL;
+				child = child->next;
+				gf_free(cur);
+			}
+
 			} else if (inf->field_ptr) {
 				gf_svg_delete_attribute_value(inf->fieldType, inf->field_ptr, com->in_scene);
 			}