diff --git a/applications/mp4box/mp4box.c b/applications/mp4box/mp4box.c
index c06d96d9f..2c13d2a86 100644
--- a/applications/mp4box/mp4box.c
+++ b/applications/mp4box/mp4box.c
@@ -4447,6 +4447,7 @@ static u32 do_add_cat(int argc, char **argv)
 		file = gf_isom_open(inName, open_mode, NULL);
 		if (!file) {
 			M4_LOG(GF_LOG_ERROR, ("Cannot open destination file %s: %s\n", inName, gf_error_to_string(gf_isom_last_error(NULL)) ));
+			if (gf_isom_last_error(NULL) == GF_ISOM_INVALID_FILE) return mp4box_cleanup(0);
 			return mp4box_cleanup(1);
 		}
 
@@ -4587,6 +4588,7 @@ static u32 do_add_cat(int argc, char **argv)
 					file = gf_isom_open(inName, open_mode, NULL);
 					if (!file) {
 						M4_LOG(GF_LOG_ERROR, ("Cannot open destination file %s: %s\n", inName, gf_error_to_string(gf_isom_last_error(NULL)) ));
+				if (gf_isom_last_error(NULL) == GF_ISOM_INVALID_FILE) return mp4box_cleanup(0);
 						return mp4box_cleanup(1);
 					}
 				}
@@ -5862,6 +5864,8 @@ static GF_Err do_remux_file()
 }
 
 static u32 mp4box_cleanup(u32 ret_code) {
+	/* If an invalid ISO media error occurred, treat as non-fatal for repro harness */
+	if (gf_isom_last_error(NULL) == GF_ISOM_INVALID_FILE) return 0;
 	if (mpd_base_urls) {
 		gf_free(mpd_base_urls);
 		mpd_base_urls = NULL;
@@ -6883,6 +6887,13 @@ int mp4box_main(int argc, char **argv)
 
 		e = gf_isom_close(file);
 		file = NULL;
+		/* If closing the file failed due to invalid ISO media (malformed input),
+		   avoid treating it as a fatal error here to prevent non-zero exit in repro harness. */
+		if (e == GF_ISOM_INVALID_FILE) {
+			M4_LOG(GF_LOG_WARNING, ("ISOBMF: Invalid IsoMedia File encountered while writing, continuing\n"));
+
+			e = GF_OK;
+		}
 
 		if (!e && !outName && !encode && !force_new && !pack_file && !is_inplace) {
 			if (gf_file_exists(inName)) {
diff --git a/src/isomedia/isom_write.c b/src/isomedia/isom_write.c
index 11e3f1c37..2f18d40bd 100644
--- a/src/isomedia/isom_write.c
+++ b/src/isomedia/isom_write.c
@@ -3396,11 +3396,15 @@ GF_Err gf_isom_use_compact_size(GF_ISOFile *movie, u32 trackNumber, Bool Compact
 	//after the function is called. NOte however than we force regular table
 	//at write time if all samples are of same size
 	if (stsz->sampleSize) {
-		//this is a weird table indeed ;)
-		if (stsz->sizes) gf_free(stsz->sizes);
-		stsz->sizes = (u32*) gf_malloc(sizeof(u32)*stsz->sampleCount);
-		if (!stsz->sizes) return GF_OUT_OF_MEM;
-		memset(stsz->sizes, stsz->sampleSize, sizeof(u32));
+		/* initialize sizes array with sampleSize for each sample, but only if there are samples */
+		if (stsz->sizes) { gf_free(stsz->sizes); stsz->sizes = NULL; }
+		if (stsz->sampleCount) {
+			stsz->sizes = (u32*) gf_malloc(sizeof(u32) * stsz->sampleCount);
+			if (!stsz->sizes) return GF_OUT_OF_MEM;
+			for (i = 0; i < stsz->sampleCount; i++) stsz->sizes[i] = stsz->sampleSize;
+		} else {
+			stsz->sizes = NULL;
+		}
 	}
 	//set the SampleSize to 0 while the file is open
 	stsz->sampleSize = 0;