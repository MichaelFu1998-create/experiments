diff --git a/src/njs_async.c b/src/njs_async.c
index e4dd748..f3c4f4b 100644
--- a/src/njs_async.c
+++ b/src/njs_async.c
@@ -102,6 +102,13 @@ njs_await_fulfilled(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,
     vm->top_frame = top;
     vm->active_frame = frame;
 
+    /* Clear saved marker on the restored frame and unlink the saved
+     * frame context to allow frame reclamation. */
+    if (frame != NULL && ctx != NULL && ctx->await != NULL) {
+        frame->native.saved = 0;
+        ctx->await->previous_active_frame = NULL;
+    }
+
     if (ret == NJS_OK) {
         ret = njs_function_call(vm, njs_function(&ctx->capability->resolve),
                             &njs_value_undefined, &vm->retval, 1, &vm->retval);
diff --git a/src/njs_function.c b/src/njs_function.c
index c9d4d97..237cd86 100644
--- a/src/njs_function.c
+++ b/src/njs_function.c
@@ -546,7 +546,7 @@ njs_function_frame_alloc(njs_vm_t *vm, size_t size)
     size_t              spare_size, chunk_size;
     njs_native_frame_t  *frame;
 
-    spare_size = vm->top_frame ? vm->top_frame->free_size : 0;
+    spare_size = 0; /* disable reuse of spare space to avoid UAF */
 
     if (njs_fast_path(size <= spare_size)) {
         frame = (njs_native_frame_t *) vm->top_frame->free;
@@ -790,6 +790,15 @@ njs_function_frame_free(njs_vm_t *vm, njs_native_frame_t *native)
     do {
         previous = native->previous;
 
+        /* If this frame is referenced by a saved frame (previous_active_frame
+         * is non-NULL) then do not free it now.  The saved context lives in
+         * the VM memory pool and will restore/clear the linkage when it is
+         * no longer needed. */
+        if (((njs_frame_t *) native)->previous_active_frame != NULL) {
+            vm->top_frame = native;
+            return;
+        }
+
         /* GC: free frame->local, etc. */
 
         if (native->size != 0) {
@@ -799,6 +808,8 @@ njs_function_frame_free(njs_vm_t *vm, njs_native_frame_t *native)
 
         native = previous;
     } while (native->skip);
+
+    vm->top_frame = native;
 }
 
 
@@ -811,13 +822,18 @@ njs_function_frame_save(njs_vm_t *vm, njs_frame_t *frame, u_char *pc)
     njs_native_frame_t  *active, *native;
 
     *frame = *vm->active_frame;
-    frame->previous_active_frame = NULL;
+    /* Link saved frame to the original active frame so it will not be
+     * reclaimed while the saved context exists. */
+    frame->previous_active_frame = vm->active_frame;
 
     native = &frame->native;
 
     active = &vm->active_frame->native;
     value_count = njs_function_frame_value_count(active);
 
+    /* Mark the active frame as saved in heap so it won't be freed */
+    active->saved = 1;
+
     function = active->function;
 
     new = (njs_value_t **) ((u_char *) native + NJS_FRAME_SIZE);
diff --git a/src/njs_function.h b/src/njs_function.h
index 59150fd..2e9af5d 100644
--- a/src/njs_function.h
+++ b/src/njs_function.h
@@ -65,6 +65,9 @@ struct njs_native_frame_s {
 
     /* Skip the Function.call() and Function.apply() methods frames. */
     uint8_t                        skip;              /* 1 bit  */
+
+    /* Mark that this frame has been saved to the VM heap and must not be freed */
+    uint8_t                        saved;             /* 1 bit  */
 };