diff --git a/src/filter_core/filter.c b/src/filter_core/filter.c
index c052ca760..16805b95a 100644
--- a/src/filter_core/filter.c
+++ b/src/filter_core/filter.c
@@ -35,8 +35,15 @@ void gf_void_del(void *p)
 void gf_filterpacket_del(void *p)
 {
 	GF_FilterPacket *pck=(GF_FilterPacket *)p;
-	if (pck->data) gf_free(pck->data);
-	gf_free(p);
+	if (!pck) return;
+	/*
+	 * Do not free pck->data here: packet internal memory is managed by
+	 * the packet lifecycle functions in filter_pck.c. Freeing it here
+	 * caused double-free when other subsystems (eg. realloc in
+	 * Media_GetSample/gf_filter_pck_expand) already released or moved
+	 * the underlying buffer. Only free the packet wrapper.
+	 */
+	gf_free(pck);
 }
 
 static void gf_filter_parse_args(GF_Filter *filter, const char *args, GF_FilterArgType arg_type, Bool for_script);
diff --git a/src/filter_core/filter_register.c b/src/filter_core/filter_register.c
index 36825c4ac..3ef0805ff 100644
--- a/src/filter_core/filter_register.c
+++ b/src/filter_core/filter_register.c
@@ -193,7 +193,7 @@ REG_DEC(evgs)
 REG_DEC(ccdec)
 REG_DEC(mpeghdec)
 
-typedef const GF_FilterRegister *(*filter_reg_fun)(GF_FilterSession *session);
+typedef GF_FilterRegister *(*filter_reg_fun)(GF_FilterSession *session);
 
 typedef struct
 {
diff --git a/src/filter_core/filter_session.h b/src/filter_core/filter_session.h
index 93c57dc96..f8fdef4ff 100644
--- a/src/filter_core/filter_session.h
+++ b/src/filter_core/filter_session.h
@@ -60,7 +60,7 @@ struct __gf_prop_entry
 //we use the same value internally but with reverse meaning
 #define GF_FS_FLAG_IMPLICIT_MODE	GF_FS_FLAG_NO_IMPLICIT
 
-#define GF_FS_FLAG_FORCE_DEBUG	(1<<30)
+#define GF_FS_FLAG_FORCE_DEBUG	(1u<<30)
 
 #ifndef GF_PROPS_HASHTABLE_SIZE
 #define GF_PROPS_HASHTABLE_SIZE 0
@@ -172,48 +172,48 @@ typedef struct
 //packet flags
 enum
 {
-	GF_PCKF_BLOCK_START = 0x80000000, //1<<31
-	GF_PCKF_BLOCK_END = 1<<30,
-	GF_PCKF_PROPS_CHANGED = 1<<29,
-	GF_PCKF_INFO_CHANGED = 1<<28,
-	GF_PCKF_CORRUPTED = 1<<27,
-	GF_PCKF_SEEK = 1<<26,
-	GF_PCKF_DUR_SET = 1<<25,
-	GF_PCKF_PROPS_REFERENCE = 1<<24,
+	GF_PCKF_BLOCK_START = 0x80000000u, //1u<<31
+	GF_PCKF_BLOCK_END = 1u<<30,
+	GF_PCKF_PROPS_CHANGED = 1u<<29,
+	GF_PCKF_INFO_CHANGED = 1u<<28,
+	GF_PCKF_CORRUPTED = 1u<<27,
+	GF_PCKF_SEEK = 1u<<26,
+	GF_PCKF_DUR_SET = 1u<<25,
+	GF_PCKF_PROPS_REFERENCE = 1u<<24,
 	//3 bits for SAP
 	GF_PCK_SAP_POS = 21,
-	GF_PCK_SAP_MASK = 0x7 << GF_PCK_SAP_POS,
+	GF_PCK_SAP_MASK = 0x7u << GF_PCK_SAP_POS,
 	//2 bits for interlaced
 	GF_PCK_ILACE_POS = 19,
-	GF_PCK_ILACE_MASK = 0x3 << GF_PCK_ILACE_POS,
+	GF_PCK_ILACE_MASK = 0x3u << GF_PCK_ILACE_POS,
 	//2 bits for clock type
 	GF_PCK_CKTYPE_POS = 17,
-	GF_PCK_CKTYPE_MASK = 0x3 << GF_PCK_CKTYPE_POS,
+	GF_PCK_CKTYPE_MASK = 0x3u << GF_PCK_CKTYPE_POS,
 	//2 bits for crypt type
 	GF_PCK_CRYPT_POS = 15,
-	GF_PCK_CRYPT_MASK = 0x3 << GF_PCK_CRYPT_POS,
+	GF_PCK_CRYPT_MASK = 0x3u << GF_PCK_CRYPT_POS,
 	//2 bits for crypt type
 	GF_PCK_CMD_POS = 13,
-	GF_PCK_CMD_MASK = 0x3 << GF_PCK_CMD_POS,
-	GF_PCKF_FORCE_MAIN = 1<<12,
+	GF_PCK_CMD_MASK = 0x3u << GF_PCK_CMD_POS,
+	GF_PCKF_FORCE_MAIN = 1u<<12,
 	//RESERVED bits [8,11]
 
 	//2 bits for is_leading
 	GF_PCK_ISLEADING_POS = 6,
-	GF_PCK_ISLEADING_MASK = 0x3 << GF_PCK_ISLEADING_POS,
+	GF_PCK_ISLEADING_MASK = 0x3u << GF_PCK_ISLEADING_POS,
 	//2 bits for depends_on
 	GF_PCK_DEPENDS_ON_POS = 4,
-	GF_PCK_DEPENDS_ON_MASK = 0x3 << GF_PCK_DEPENDS_ON_POS,
+	GF_PCK_DEPENDS_ON_MASK = 0x3u << GF_PCK_DEPENDS_ON_POS,
 	//2 bits for depended_on
 	GF_PCK_DEPENDED_ON_POS = 2,
-	GF_PCK_DEPENDED_ON_MASK = 0x3 << GF_PCK_DEPENDED_ON_POS,
+	GF_PCK_DEPENDED_ON_MASK = 0x3u << GF_PCK_DEPENDED_ON_POS,
 	//2 bits for redundant
-	GF_PCK_REDUNDANT_MASK = 0x3,
+	GF_PCK_REDUNDANT_MASK = 0x3u,
 
 	//quick defs
-	GF_PCK_CMD_NONE = 0<<GF_PCK_CMD_POS,
-	GF_PCK_CMD_PID_EOS = 1<<GF_PCK_CMD_POS,
-	GF_PCK_CMD_PID_REM = 2<<GF_PCK_CMD_POS,
+	GF_PCK_CMD_NONE = 0u<<GF_PCK_CMD_POS,
+	GF_PCK_CMD_PID_EOS = 1u<<GF_PCK_CMD_POS,
+	GF_PCK_CMD_PID_REM = 2u<<GF_PCK_CMD_POS,
 };
 
 typedef struct __gf_filter_pck_info
@@ -1121,7 +1121,7 @@ typedef struct
 } GF_CapsBundleStore;
 
 #define CAP_MATCH_LOADED_INPUT_ONLY		1
-#define CAP_MATCH_LOADED_OUTPUT_ONLY	1<<1
+#define CAP_MATCH_LOADED_OUTPUT_ONLY	1u<<1
 
 u32 gf_filter_caps_to_caps_match(const GF_FilterRegister *src, u32 src_bundle_idx, const GF_FilterRegister *dst, u32 nb_in_bundles, GF_Filter *dst_filter, u32 *dst_bundle_idx, u32 for_dst_bundle, u32 *loaded_filter_flags, GF_CapsBundleStore *capstore);
 Bool gf_filter_has_out_caps(const GF_FilterCapability *caps, u32 nb_caps);
@@ -1176,7 +1176,7 @@ enum
 };
 
 #define EDGE_LOADED_SOURCE_ONLY (1)
-#define EDGE_LOADED_DEST_ONLY (1<<1)
+#define EDGE_LOADED_DEST_ONLY (1u<<1)
 
 typedef struct
 {
diff --git a/src/filters/dasher.c b/src/filters/dasher.c
index 15ee85050..cadf1a14f 100644
--- a/src/filters/dasher.c
+++ b/src/filters/dasher.c
@@ -10190,7 +10190,7 @@ static GF_Err dasher_initialize(GF_Filter *filter)
 {
 	GF_Err e;
 	GF_DasherCtx *ctx = gf_filter_get_udta(filter);
-	gf_filter_set_max_extra_input_pids(filter, -1);
+	gf_filter_set_max_extra_input_pids(filter, (u32)-1);
 
 	if (ctx->mname && !strcmp(ctx->mname, "m3u8")) {
 		gf_free(ctx->mname);
diff --git a/src/filters/ff_avf.c b/src/filters/ff_avf.c
index 29c8c50b7..0f26c5862 100644
--- a/src/filters/ff_avf.c
+++ b/src/filters/ff_avf.c
@@ -358,7 +358,7 @@ static GF_Err ffavf_initialize(GF_Filter *filter)
 	ctx->filter_graph = avfilter_graph_alloc();
 
 	if (dyn_inputs) {
-		gf_filter_set_max_extra_input_pids(filter, -1);
+		gf_filter_set_max_extra_input_pids(filter, (u32)-1);
 	} else if (nb_v_in + nb_a_in > 1)
 		gf_filter_set_max_extra_input_pids(filter, nb_v_in + nb_a_in - 1);
 
diff --git a/src/filters/ff_enc.c b/src/filters/ff_enc.c
index d9a0e2203..79e28189b 100644
--- a/src/filters/ff_enc.c
+++ b/src/filters/ff_enc.c
@@ -407,7 +407,7 @@ static void ffenc_log_video(GF_Filter *filter, struct _gf_ffenc_ctx *ctx, AVPack
 	if (do_reporting) {
 		char szStatus[1024];
 		sprintf(szStatus, "[FFEnc] FPS %.02f F %d DTS "LLD" CTS "LLD" Q %02.02f PT %s (F_in %d)", fps, ctx->nb_frames_out, pkt->dts+ctx->ts_shift, pkt->pts+ctx->ts_shift, ((Double)q) /  FF_QP2LAMBDA, ptype, ctx->nb_frames_in);
-		gf_filter_update_status(filter, -1, szStatus);
+		gf_filter_update_status(filter, (u32)-1, szStatus);
 	}
 }
 
diff --git a/src/filters/mux_isom.c b/src/filters/mux_isom.c
index 57e9e7834..ec536bdd6 100644
--- a/src/filters/mux_isom.c
+++ b/src/filters/mux_isom.c
@@ -7594,7 +7594,7 @@ void mp4_mux_progress_cbk(void *udta, u64 done, u64 total)
 static GF_Err mp4_mux_initialize(GF_Filter *filter)
 {
 	GF_MP4MuxCtx *ctx = gf_filter_get_udta(filter);
-	gf_filter_set_max_extra_input_pids(filter, -1);
+	gf_filter_set_max_extra_input_pids(filter, (u32)-1);
 	ctx->filter = filter;
 #ifdef GPAC_DISABLE_ISOM_FRAGMENTS
 	if (ctx->store>=MP4MX_MODE_FRAG) {
diff --git a/src/filters/mux_ts.c b/src/filters/mux_ts.c
index 0665d69b4..27ec1e57d 100644
--- a/src/filters/mux_ts.c
+++ b/src/filters/mux_ts.c
@@ -1850,7 +1850,7 @@ static GF_Err tsmux_process(GF_Filter *filter)
 		} else {
 
 			sprintf(szStatus, "sysclock % 6d ms TS clock % 6d ms bitrate % 8d kbps", gf_m2ts_get_sys_clock(ctx->mux), gf_m2ts_get_ts_clock(ctx->mux), ctx->mux->bit_rate/1000);
-			gf_filter_update_status(filter, -1, szStatus);
+			gf_filter_update_status(filter, (u32)-1, szStatus);
 		}
 	}
 
@@ -1913,7 +1913,7 @@ static GF_Err tsmux_process(GF_Filter *filter)
 static GF_Err tsmux_initialize(GF_Filter *filter)
 {
 	GF_TSMuxCtx *ctx = gf_filter_get_udta(filter);
-	gf_filter_set_max_extra_input_pids(filter, -1);
+	gf_filter_set_max_extra_input_pids(filter, (u32)-1);
 
 	ctx->mux = gf_m2ts_mux_new(ctx->rate, ctx->pat_rate, ctx->realtime);
 	ctx->mux->flush_pes_at_rap = ctx->flush_rap;
diff --git a/src/filters/out_file.c b/src/filters/out_file.c
index 641fa1cf3..ddb1c726d 100644
--- a/src/filters/out_file.c
+++ b/src/filters/out_file.c
@@ -889,7 +889,7 @@ check_gfio:
 	if (gf_filter_reporting_enabled(filter)) {
 		char szStatus[1024];
 		snprintf(szStatus, 1024, "%s: wrote % 16"LLD_SUF" bytes", gf_file_basename(ctx->szFileName), (s64) ctx->nb_write);
-		gf_filter_update_status(filter, -1, szStatus);
+		gf_filter_update_status(filter, (u32)-1, szStatus);
 	}
 	return e;
 }
diff --git a/src/filters/out_video.c b/src/filters/out_video.c
index 3e72d2d1c..8ec690632 100644
--- a/src/filters/out_video.c
+++ b/src/filters/out_video.c
@@ -1862,7 +1862,7 @@ static GF_Err vout_process(GF_Filter *filter)
 					if (gf_filter_reporting_enabled(filter)) {
 						char szStatus[1024];
 						sprintf(szStatus, "buffering %d / %d ms", (u32) (dur/1000), ctx->buffer);
-						gf_filter_update_status(filter, -1, szStatus);
+						gf_filter_update_status(filter, (u32)-1, szStatus);
 					}
 					//we don't lock here since we don't access the pointer
 					if (ctx->oldata.ptr && ctx->update_oldata)
@@ -2133,7 +2133,7 @@ draw_frame:
 		}
 		sprintf(szStatus, "%dx%d->%dx%d %s frame TS "LLU"/%d buffer %d / %d ms %02.02f FPS", ctx->width, ctx->height, ctx->display_width, ctx->display_height,
 		 	gf_pixel_fmt_name(ctx->pfmt), gf_filter_pck_get_cts(ctx->last_pck), ctx->timescale, (u32) (dur/1000), ctx->buffer, fps);
-		gf_filter_update_status(filter, -1, szStatus);
+		gf_filter_update_status(filter, (u32)-1, szStatus);
 	}
 
 	if (ctx->step) {
diff --git a/src/filters/reframe_h263.c b/src/filters/reframe_h263.c
index 4b9da7ed2..57493fd1d 100644
--- a/src/filters/reframe_h263.c
+++ b/src/filters/reframe_h263.c
@@ -109,7 +109,7 @@ GF_Err h263dmx_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remov
 #define H263_CACHE_SIZE	4096
 static u32 h263dmx_next_start_code_bs(GF_BitStream *bs)
 {
-	u32 v, bpos;
+	u64 v, bpos;
 	unsigned char h263_cache[H263_CACHE_SIZE];
 	u64 end, cache_start, load_size;
 	u64 start = gf_bs_get_position(bs);
@@ -336,7 +336,7 @@ static GFINLINE void h263dmx_update_cts(GF_H263DmxCtx *ctx)
 
 static s32 h263dmx_next_start_code(u8 *data, u32 size)
 {
-	u32 v, bpos;
+	u64 v, bpos;
 	s64 end;
 	s64 start = 0;
 
diff --git a/src/filters/reframe_nalu.c b/src/filters/reframe_nalu.c
index 87835b0e7..36cdc03d1 100644
--- a/src/filters/reframe_nalu.c
+++ b/src/filters/reframe_nalu.c
@@ -3892,7 +3892,7 @@ naldmx_flush:
 		char szStatus[1024];
 
 		sprintf(szStatus, "%s %dx%d % 10d NALU % 8d I % 8d P % 8d B % 8d SEI", ctx->log_name, ctx->width, ctx->height, ctx->nb_nalus, ctx->nb_i, ctx->nb_p, ctx->nb_b, ctx->nb_sei);
-		gf_filter_update_status(filter, -1, szStatus);
+		gf_filter_update_status(filter, (u32)-1, szStatus);
 	}
 	if (ctx->full_au_source && ctx->poc_probe_done) {
 		if (ctx->first_pck_in_au)
diff --git a/src/filters/rewrite_nalu.c b/src/filters/rewrite_nalu.c
index 581d0cd7a..25566635d 100644
--- a/src/filters/rewrite_nalu.c
+++ b/src/filters/rewrite_nalu.c
@@ -641,7 +641,7 @@ GF_Err nalumx_process(GF_Filter *filter)
 		char szStatus[1024];
 
 		sprintf(szStatus, "%s Annex-B %dx%d % 10d NALU", (ctx->vtype==UFNAL_HEVC) ? "HEVC" : ((ctx->vtype==UFNAL_VVC) ? "VVC" : "AVC|H264"), ctx->width, ctx->height, ctx->nb_nalu);
-		gf_filter_update_status(filter, -1, szStatus);
+		gf_filter_update_status(filter, (u32)-1, szStatus);
 
 	}
 	return GF_OK;