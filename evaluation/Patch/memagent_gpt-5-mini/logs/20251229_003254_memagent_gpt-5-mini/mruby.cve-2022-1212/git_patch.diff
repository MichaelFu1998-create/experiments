diff --git a/src/string.c b/src/string.c
index 0273f74e3..7e5bfc692 100644
--- a/src/string.c
+++ b/src/string.c
@@ -1212,13 +1212,19 @@ str_escape(mrb_state *mrb, mrb_value str, mrb_bool inspect)
 {
   const char *p, *pend;
   char buf[4];  /* `\x??` or UTF-8 character */
-  mrb_value result = mrb_str_new_lit(mrb, "\"");
+  mrb_value result;
 #ifdef MRB_UTF8_STRING
   uint32_t ascii_flag = MRB_STR_ASCII;
 #endif
 
+  result = mrb_str_new_lit(mrb, """);
+  /* register both source and result to GC roots so they won't be freed
+     while we hold raw pointers into the source during escaping. */
+  mrb_gc_register(mrb, str);
+  mrb_gc_register(mrb, result);
+
   p = RSTRING_PTR(str); pend = RSTRING_END(str);
-  for (;p < pend; p++) {
+  for (; p < pend; p++) {
     unsigned char c, cc;
 #ifdef MRB_UTF8_STRING
     if (inspect) {
@@ -1237,8 +1243,8 @@ str_escape(mrb_state *mrb, mrb_value str, mrb_bool inspect)
     }
 #endif
     c = *p;
-    if (c == '"'|| c == '\\' || (c == '#' && IS_EVSTR(p+1, pend))) {
-      buf[0] = '\\'; buf[1] = c;
+    if (c == '"' || c == '\' || (c == '#' && IS_EVSTR(p+1, pend))) {
+      buf[0] = '\'; buf[1] = c;
       mrb_str_cat(mrb, result, buf, 2);
       continue;
     }
@@ -1248,24 +1254,25 @@ str_escape(mrb_state *mrb, mrb_value str, mrb_bool inspect)
       continue;
     }
     switch (c) {
-      case '\n': cc = 'n'; break;
-      case '\r': cc = 'r'; break;
-      case '\t': cc = 't'; break;
-      case '\f': cc = 'f'; break;
-      case '\013': cc = 'v'; break;
-      case '\010': cc = 'b'; break;
-      case '\007': cc = 'a'; break;
+      case '
+': cc = 'n'; break;
+      case '': cc = 'r'; break;
+      case '	': cc = 't'; break;
+      case '': cc = 'f'; break;
+      case '': cc = 'v'; break;
+      case '': cc = 'b'; break;
+      case '': cc = 'a'; break;
       case 033: cc = 'e'; break;
       default: cc = 0; break;
     }
     if (cc) {
-      buf[0] = '\\';
+      buf[0] = '\';
       buf[1] = (char)cc;
       mrb_str_cat(mrb, result, buf, 2);
       continue;
     }
     else {
-      buf[0] = '\\';
+      buf[0] = '\';
       buf[1] = 'x';
       buf[3] = mrb_digitmap[c % 16]; c /= 16;
       buf[2] = mrb_digitmap[c % 16];
@@ -1273,7 +1280,7 @@ str_escape(mrb_state *mrb, mrb_value str, mrb_bool inspect)
       continue;
     }
   }
-  mrb_str_cat_lit(mrb, result, "\"");
+  mrb_str_cat_lit(mrb, result, """);
 #ifdef MRB_UTF8_STRING
   if (inspect) {
     mrb_str_ptr(str)->flags |= ascii_flag;
@@ -1284,9 +1291,14 @@ str_escape(mrb_state *mrb, mrb_value str, mrb_bool inspect)
   }
 #endif
 
+  /* Unregister the objects we registered earlier. */
+  mrb_gc_unregister(mrb, result);
+  mrb_gc_unregister(mrb, str);
+
   return result;
 }
 
+
 static void
 mrb_str_aset(mrb_state *mrb, mrb_value str, mrb_value indx, mrb_value alen, mrb_value replace)
 {