diff --git a/programs/escape.c b/programs/escape.c
index 1daff81d..17627638 100644
--- a/programs/escape.c
+++ b/programs/escape.c
@@ -27,37 +27,83 @@ char * ATTRIBUTE_MALLOC
 htmlescape (const char *restrict src, const int cp)
 {
   int len = strlen (src) + 10;
-  char *dest, *d = malloc (len);
-  unsigned char *s = (unsigned char *)src;
-  dest = d;
-  while (*s++)
+  char *dest = malloc (len);
+  char *d;
+  const unsigned char *s = (const unsigned char *)src;
+  if (!dest)
+    return NULL;
+  d = dest;
+  /* initialize as empty string so strcat/other string ops don't read uninit memory */
+  *d = '\0';
+
+  while (*s)
     {
-      const int off = d - dest;
+      const int off = (int)(d - dest);
       if (off >= len - 8)
         {
           len += 10;
-          dest = realloc (dest, len);
+          char *newdest = realloc (dest, len);
+          if (!newdest)
+            {
+              free(dest);
+              return NULL;
+            }
+          dest = newdest;
           d = dest + off;
         }
-      switch (*s)
+      unsigned char ch = *s;
+      switch (ch)
         {
-        case '"': strcat (d, "&quot;"); d += 6; break;
-        case '\'': strcat (d, "&#39;"); d += 5; break;
-        case '`': strcat (d, "&#96;"); d += 5; break;
-        case '&': strcat (d, "&amp;"); d += 5; break;
-        case '<': strcat (d, "&lt;"); d += 4; break;
-        case '>': strcat (d, "&gt;"); d += 4; break;
-        case '{': strcat (d, "&#123;"); d += 6; break;
-        case '}': strcat (d, "&#125;"); d += 6; break;
+        case '"': memcpy (d, "&quot;", 6); d += 6; *d = '\0'; break;
+        case '\'': memcpy (d, "&#39;", 5); d += 5; *d = '\0'; break;
+        case '`': memcpy (d, "&#96;", 5); d += 5; *d = '\0'; break;
+        case '&': memcpy (d, "&amp;", 5); d += 5; *d = '\0'; break;
+        case '<': memcpy (d, "&lt;", 4); d += 4; *d = '\0'; break;
+        case '>': memcpy (d, "&gt;", 4); d += 4; *d = '\0'; break;
+        case '{': memcpy (d, "&#123;", 6); d += 6; *d = '\0'; break;
+        case '}': memcpy (d, "&#125;", 6); d += 6; *d = '\0'; break;
         default:
-          if (*s >= 127) // maybe encodings, no utf8 (see htmlwescape)
+          if (ch >= 127) // maybe encodings, no utf8 (see htmlwescape)
+            {
+              /* ensure we don't overflow: snprintf writes up to remaining space */
+              int remaining = len - (d - dest);
+              if (remaining > 0)
+                {
+                  int wrote = snprintf (d, remaining, "&#x%X;", ch);
+                  if (wrote < 0 || wrote >= remaining)
+                    {
+                      /* need more space, expand and retry once */
+                      int off2 = (int)(d - dest);
+                      len += 16;
+                      char *newdest2 = realloc (dest, len);
+                      if (!newdest2)
+                        {
+                          free(dest);
+                          return NULL;
+                        }
+                      dest = newdest2;
+                      d = dest + off2;
+                      remaining = len - (d - dest);
+                      wrote = snprintf (d, remaining, "&#x%X;", ch);
+                      if (wrote < 0 || wrote >= remaining)
+                        {
+                          /* give up, ensure valid string */
+                          *d = '\0';
+                        }
+                      else
+                        d += wrote;
+                    }
+                  else
+                    d += wrote;
+                }
+            }
+          else if (ch >= 20)
             {
-              sprintf (d, "&#x%X;", *s); // 4 + 4
-              d += strlen (d);
+              *d++ = ch;
+              *d = '\0';
             }
-          else if (*s >= 20)
-            *d++ = *s;
         }
+      s++;
     }
   *d = 0;
   return dest;
@@ -76,36 +122,75 @@ htmlwescape (BITCODE_TU wstr)
   while ((c = *tmp++))
     len++;
   len += 16;
-  d = dest = malloc (len);
+  dest = malloc (len);
+  if (!dest)
+    return NULL;
+  d = dest;
+  *d = '\0';
 
-  while (*wstr++)
+  while (*wstr)
     {
-      const int off = d - dest;
+      const int off = (int)(d - dest);
       if (off >= len - 8)
         {
           len += 16;
-          dest = realloc (dest, len);
+          char *newdest = realloc (dest, len);
+          if (!newdest)
+            {
+              free(dest);
+              return NULL;
+            }
+          dest = newdest;
           d = dest + off;
         }
-      switch (*wstr)
+      unsigned int ch = (unsigned int)(*wstr);
+      switch (ch)
         {
-        case 34: strcat (d, "&quot;"); d += 6; break;
-        case 39: strcat (d, "&#39;"); d += 5; break;
-        case 38: strcat (d, "&amp;"); d += 5; break;
-        case 60: strcat (d, "&lt;"); d += 4; break;
-        case 62: strcat (d, "&gt;"); d += 4; break;
-        case 96: strcat (d, "&#96;"); d += 5; break;
-        case 123: strcat (d, "&#123;"); d += 6; break;
-        case 125: strcat (d, "&#125;"); d += 6; break;
+        case 34: memcpy (d, "&quot;", 6); d += 6; *d = '\0'; break;
+        case 39: memcpy (d, "&#39;", 5); d += 5; *d = '\0'; break;
+        case 38: memcpy (d, "&amp;", 5); d += 5; *d = '\0'; break;
+        case 60: memcpy (d, "&lt;", 4); d += 4; *d = '\0'; break;
+        case 62: memcpy (d, "&gt;", 4); d += 4; *d = '\0'; break;
+        case 96: memcpy (d, "&#96;", 5); d += 5; *d = '\0'; break;
+        case 123: memcpy (d, "&#123;", 6); d += 6; *d = '\0'; break;
+        case 125: memcpy (d, "&#125;", 6); d += 6; *d = '\0'; break;
         default:
-          if (*wstr >= 127) // utf8 encodings
+          if (ch >= 127) // utf8 encodings
+            {
+              int remaining = len - (d - dest);
+              if (remaining > 0)
+                {
+                  int wrote = snprintf (d, remaining, "&#x%X;", ch);
+                  if (wrote < 0 || wrote >= remaining)
+                    {
+                      int off2 = (int)(d - dest);
+                      len += 16;
+                      char *newdest2 = realloc (dest, len);
+                      if (!newdest2)
+                        {
+                          free(dest);
+                          return NULL;
+                        }
+                      dest = newdest2;
+                      d = dest + off2;
+                      remaining = len - (d - dest);
+                      wrote = snprintf (d, remaining, "&#x%X;", ch);
+                      if (wrote < 0 || wrote >= remaining)
+                        *d = '\0';
+                      else
+                        d += wrote;
+                    }
+                  else
+                    d += wrote;
+                }
+            }
+          else if (ch >= 20)
             {
-              sprintf (d, "&#x%X;", *wstr);
-              d += strlen (d);
+              *d++ = (char)ch;
+              *d = '\0';
             }
-          else if (*wstr >= 20)
-            *d++ = *wstr;
         }
+      wstr++;
     }
   *d = 0;
   return dest;