diff --git a/src/hash.c b/src/hash.c
index fc6b6fa6b..09580b825 100644
--- a/src/hash.c
+++ b/src/hash.c
@@ -132,16 +132,7 @@ typedef struct index_buckets_iter {
   MRB_INLINE void c_##_dec_##n_(struct RHash *h) {                            \
     c_##_set_##n_(h, c_##_##n_(h) - 1);                                       \
   }
-#define DEFINE_SWITCHER(n_, k_)                                               \
-  MRB_INLINE void h_##n_##_on(struct RHash *h) {                              \
-    h->flags |= MRB_HASH_##k_;                                                \
-  }                                                                           \
-  MRB_INLINE void h_##n_##_off(struct RHash *h) {                             \
-    h->flags &= ~MRB_HASH_##k_;                                               \
-  }                                                                           \
-  MRB_INLINE mrb_bool h_##n_##_p(const struct RHash *h) {                     \
-    return (h->flags & MRB_HASH_##k_) == MRB_HASH_##k_;                       \
-  }
+#define DEFINE_SWITCHER(n_, k_)                                                 MRB_INLINE void h_##n_##_on(struct RHash *h) {                                  if (h) h->flags |= MRB_HASH_##k_;                                            }                                                                             MRB_INLINE void h_##n_##_off(struct RHash *h) {                                 if (h) h->flags &= ~MRB_HASH_##k_;                                           }                                                                             MRB_INLINE mrb_bool h_##n_##_p(const struct RHash *h) {                         return h != NULL && ((h->flags & MRB_HASH_##k_) == MRB_HASH_##k_);           }
 
 #ifdef MRB_64BIT
 DEFINE_ACCESSOR(ar, ea_capa, uint32_t, ea_capa)
@@ -1151,7 +1142,14 @@ static mrb_value mrb_hash_default(mrb_state *mrb, mrb_value hash);
 static void
 hash_modify(mrb_state *mrb, mrb_value hash)
 {
-  mrb_check_frozen(mrb, mrb_hash_ptr(hash));
+  /* Defensive check: ensure `hash` is not an immediate value and has
+     a valid pointer before checking frozen state. This prevents NULL or
+     small-pointer dereferences in mrb_check_frozen when callers pass
+     invalid values. */
+  if (mrb_immediate_p(hash)) return;
+  struct RHash *h = mrb_hash_ptr(hash);
+  if (h == NULL) return;
+  mrb_check_frozen(mrb, h);
 }
 
 static mrb_value
@@ -1239,9 +1237,16 @@ mrb_hash_fetch(mrb_state *mrb, mrb_value hash, mrb_value key, mrb_value def)
 MRB_API void
 mrb_hash_set(mrb_state *mrb, mrb_value hash, mrb_value key, mrb_value val)
 {
+  /* Defensive checks: ensure `hash` is not an immediate value and its
+     pointer is valid before performing modifications. This prevents
+     dereferences of NULL or invalid pointers inside h_* helpers. */
+  if (mrb_immediate_p(hash)) return;
+  struct RHash *h = mrb_hash_ptr(hash);
+  if (h == NULL) return;
+
   hash_modify(mrb, hash);
   key = h_key_for(mrb, key);
-  h_set(mrb, mrb_hash_ptr(hash), key, val);
+  h_set(mrb, h, key, val);
   mrb_field_write_barrier_value(mrb, mrb_basic_ptr(hash), key);
   mrb_field_write_barrier_value(mrb, mrb_basic_ptr(hash), val);
 }