diff --git a/src/vm.c b/src/vm.c
index 09f524a9d..a52370fe6 100644
--- a/src/vm.c
+++ b/src/vm.c
@@ -1201,7 +1201,17 @@ MRB_API mrb_value
 mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)
 {
   /* mrb_assert(MRB_PROC_CFUNC_P(proc)) */
+  /* Defensive checks: ensure proc and its irep are valid before
+     dereferencing. In some error/malformed-input cases proc or
+     proc->body.irep can be NULL which leads to a NULL pointer
+     dereference observed by ASan. Return nil to avoid crashing the VM. */
+  if (proc == NULL) {
+    return mrb_nil_value();
+  }
   const mrb_irep *irep = proc->body.irep;
+  if (irep == NULL) {
+    return mrb_nil_value();
+  }
   const mrb_pool_value *pool = irep->pool;
   const mrb_sym *syms = irep->syms;
   mrb_code insn;
@@ -1234,9 +1244,25 @@ RETRY_TRY_BLOCK:
       goto L_BREAK;
     goto L_RAISE;
   }
+  /* Defensive check: ensure callinfo and stack are present before
+     attempting to use them. This must be done before calling
+     mrb_vm_ci_proc_set which dereferences ci. If these are missing
+     due to failed initialization or corrupted state, return nil to
+     avoid crashing the VM. */
+  if (!mrb->c || !mrb->c->ci) {
+    mrb->jmp = prev_jmp;
+    return mrb_nil_value();
+  }
+
   mrb->jmp = &c_jmp;
   mrb_vm_ci_proc_set(mrb->c->ci, proc);
 
+  /* Defensive check: ensure stack is present before defining regs macro */
+  if (!mrb->c->ci->stack) {
+    mrb->jmp = prev_jmp;
+    return mrb_nil_value();
+  }
+
 #define regs (mrb->c->ci->stack)
   INIT_DISPATCH {
     CASE(OP_NOP, Z) {
@@ -1875,6 +1901,11 @@ RETRY_TRY_BLOCK:
     }
 
     CASE(OP_ENTER, W) {
+      if (!mrb->c || !mrb->c->ci || !mrb->c->ci->stack) {
+        mrb_value exc = mrb_exc_new_lit(mrb, E_RUNTIME_ERROR, "internal VM error: missing stack");
+        mrb_exc_set(mrb, exc);
+        goto L_RAISE;
+      }
       mrb_int m1 = MRB_ASPEC_REQ(a);
       mrb_int o  = MRB_ASPEC_OPT(a);
       mrb_int r  = MRB_ASPEC_REST(a);
@@ -1925,6 +1956,14 @@ RETRY_TRY_BLOCK:
 
       /* arguments is passed with Array */
       if (argc == 15) {
+        /* Defensive: ensure regs[1] is actually an Array before
+           dereferencing it. Some malformed inputs may leave a
+           non-array value here which would make mrb_ary_ptr return
+           NULL and trigger a crash. Convert non-array to an empty
+           array to continue safely. */
+        if (!mrb_array_p(regs[1])) {
+          regs[1] = mrb_ary_new_capa(mrb, 0);
+        }
         struct RArray *ary = mrb_ary_ptr(regs[1]);
         argv = ARY_PTR(ary);
         argc = (int)ARY_LEN(ary);