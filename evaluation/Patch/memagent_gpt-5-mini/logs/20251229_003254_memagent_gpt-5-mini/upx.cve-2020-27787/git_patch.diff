diff --git a/src/p_lx_elf.cpp b/src/p_lx_elf.cpp
index 96f5838d..9cc7c27a 100644
--- a/src/p_lx_elf.cpp
+++ b/src/p_lx_elf.cpp
@@ -777,13 +777,19 @@ PackLinuxElf64::PackLinuxElf64help1(InputFile *f)
         }
 
         Elf64_Phdr const *phdr= phdri;
-        for (int j = e_phnum; --j>=0; ++phdr)
-        if (Elf64_Phdr::PT_DYNAMIC==get_te64(&phdr->p_type)) {
-            dynseg= (Elf64_Dyn const *)(check_pt_dynamic(phdr) + file_image);
-            invert_pt_dynamic(dynseg);
-        }
-        else if (PT_LOAD64==get_te32(&phdr->p_type)) {
-            check_pt_load(phdr);
+        for (int j = e_phnum; --j>=0; ++phdr) {
+            if (Elf64_Phdr::PT_DYNAMIC==get_te64(&phdr->p_type)) {
+                try {
+                    upx_uint64_t off = check_pt_dynamic(phdr);
+                    dynseg= (Elf64_Dyn const *)(off + file_image);
+                    invert_pt_dynamic(dynseg);
+                } catch (const Exception &) {
+                    /* skip malformed PT_DYNAMIC and continue parsing */
+                    continue;
+                }
+            } else if (PT_LOAD64==get_te32(&phdr->p_type)) {
+                check_pt_load(phdr);
+            }
         }
         // elf_find_dynamic() returns 0 if 0==dynseg.
         dynstr =      (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB);
@@ -1575,6 +1581,12 @@ PackLinuxElf32::invert_pt_dynamic(Elf32_Dyn const *dynp)
     unsigned ndx = 1+ 0;
     if (dynp)
     for (; ; ++ndx, ++dynp) {
+        const char *file_base = (const char *)file_image.getVoidPtr();
+        if (!file_base) break;
+        upx_uint64_t rel = (char const *)dynp - file_base;
+        if (rel + sizeof(Elf64_Dyn) > (upx_uint64_t)file_size) break;
+        upx_uint64_t offset = (char const *)dynp - (char const *)dynp0;
+        if (offset + sizeof(Elf64_Dyn) > sz_dynseg) break;
         unsigned const d_tag = get_te32(&dynp->d_tag);
         if (d_tag < DT_NUM) {
             if (Elf32_Dyn::DT_NEEDED != d_tag
@@ -5067,7 +5079,27 @@ PackLinuxElf64::invert_pt_dynamic(Elf64_Dyn const *dynp)
     Elf64_Dyn const *const dynp0 = dynp;
     unsigned ndx = 1+ 0;
     if (dynp)
+    {
+        /* ensure dynp0 lies within the mapped file image */
+        const char *file_base = (const char *)file_image.getVoidPtr();
+        if (!file_base) {
+            return; /* cannot validate without file image */
+        }
+        upx_uint64_t rel0 = (const char *)dynp0 - file_base;
+        if (rel0 + sizeof(Elf64_Dyn) > (upx_uint64_t)file_size
+            || rel0 + sizeof(Elf64_Dyn) > sz_dynseg) {
+            return; /* malformed PT_DYNAMIC pointer; treat as absent */
+        }
+    }
+
     for (; ; ++ndx, ++dynp) {
+        /* ensure this dyn entry lies within declared PT_DYNAMIC range */
+        upx_uint64_t offset = (char const *)dynp - (char const *)dynp0;
+        if (offset + sizeof(Elf64_Dyn) > sz_dynseg) {
+            char msg[50]; snprintf(msg, sizeof(msg),
+                "bad PT_DYNAMIC dyn entry %u", -1+ ndx);
+            throwCantPack(msg);
+        }
         upx_uint64_t const d_tag = get_te64(&dynp->d_tag);
         if (d_tag>>32) { // outrageous
             char msg[50]; snprintf(msg, sizeof(msg),
@@ -5076,13 +5108,18 @@ PackLinuxElf64::invert_pt_dynamic(Elf64_Dyn const *dynp)
         }
         if (d_tag < DT_NUM) {
             if (Elf64_Dyn::DT_NEEDED != d_tag
-            &&  dt_table[d_tag]
-            &&    get_te64(&dynp->d_val)
-               != get_te64(&dynp0[-1+ dt_table[d_tag]].d_val)) {
-                char msg[50]; snprintf(msg, sizeof(msg),
-                    "duplicate DT_%#x: [%#x] [%#x]",
-                    (unsigned)d_tag, -1+ dt_table[d_tag], -1+ ndx);
-                throwCantPack(msg);
+            &&  dt_table[d_tag]) {
+                unsigned prev = dt_table[d_tag];
+                /* validate previous dt_table index is inside dynseg */
+                if ((upx_uint64_t)(prev - 1) * sizeof(Elf64_Dyn) + sizeof(Elf64_Dyn) > sz_dynseg) {
+                    throwCantPack("bad DT_* index");
+                }
+                if (get_te64(&dynp->d_val) != get_te64(&dynp0[-1+ dt_table[d_tag]].d_val)) {
+                    char msg[50]; snprintf(msg, sizeof(msg),
+                        "duplicate DT_%#x: [%#x] [%#x]",
+                        (unsigned)d_tag, -1+ dt_table[d_tag], -1+ ndx);
+                    throwCantPack(msg);
+                }
             }
             dt_table[d_tag] = ndx;
         }