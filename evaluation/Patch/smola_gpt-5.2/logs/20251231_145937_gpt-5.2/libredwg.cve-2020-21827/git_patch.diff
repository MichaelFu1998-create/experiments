diff --git a/src/decode.c b/src/decode.c
index 96b48ef..8079d05 100644
--- a/src/decode.c
+++ b/src/decode.c
@@ -2256,7 +2256,8 @@ read_2004_compressed_section (Bit_Chain *dat, Dwg_Data *restrict dwg,
                               Bit_Chain *sec_dat, Dwg_Section_Type type)
 {
   uint32_t address, sec_mask, initial_address;
-  uint32_t max_decomp_size;
+  uint64_t max_decomp_size;
+  uint64_t stride;
   long bytes_left;
   Dwg_Section_Info *info = NULL;
   encrypted_section_header es;
@@ -2295,23 +2296,48 @@ read_2004_compressed_section (Bit_Chain *dat, Dwg_Data *restrict dwg,
                  info->compressed == 2 ? "" : "un");
     }
 
-  max_decomp_size = info->num_sections * info->max_decomp_size;
+  /*
+   * For compressed sections the decompressed output is laid out in
+   * fixed-size chunks of info->max_decomp_size.
+   *
+   * For uncompressed sections, the code below copies raw bytes into the
+   * output buffer with a stride of info->size per section.
+   *
+   * The allocation must match the per-section stride, otherwise
+   * i * info->size can exceed an allocation based on max_decomp_size and
+   * cause a heap buffer overflow.
+   */
+  if (info->compressed == 2)
+    stride = (uint64_t)info->max_decomp_size;
+  else
+    {
+      if (info->size <= 0)
+        {
+          LOG_ERROR ("Invalid section %s size %lld", info->name,
+                     (long long)info->size);
+          return DWG_ERR_INVALIDDWG;
+        }
+      stride = (uint64_t)info->size;
+    }
+
+  max_decomp_size = (uint64_t)info->num_sections * stride;
   if (info->num_sections == 0)
     return 0;
   if (max_decomp_size == 0 || max_decomp_size > 0x2f000000) // 790Mb
     {
       LOG_ERROR ("Invalid section %s count or max decompression size. "
-                 "Sections: %u, Max size: %u",
-                 info->name, info->num_sections, info->max_decomp_size);
+                 "Sections: %u, Stride: %llu",
+                 info->name, info->num_sections,
+                 (unsigned long long)stride);
       return DWG_ERR_INVALIDDWG;
     }
-  decomp = (BITCODE_RC *)calloc (max_decomp_size, sizeof (BITCODE_RC));
+  decomp = (BITCODE_RC *)calloc ((size_t)max_decomp_size, sizeof (BITCODE_RC));
   if (!decomp)
     {
       LOG_ERROR ("Out of memory with %u sections", info->num_sections);
       return DWG_ERR_OUTOFMEM;
     }
-  bytes_left = max_decomp_size;
+  bytes_left = (long)max_decomp_size;
   initial_address = info->sections[0] ? info->sections[0]->address : 0;
   sec_dat->bit = 0;
   sec_dat->byte = 0;
@@ -2369,8 +2395,18 @@ read_2004_compressed_section (Bit_Chain *dat, Dwg_Data *restrict dwg,
       // check if compressed at all
       if (info->compressed == 2
           && bytes_left > 0
-          && (i * info->max_decomp_size) <= max_decomp_size)
+          && ((uint64_t)i * (uint64_t)info->max_decomp_size) < max_decomp_size)
         {
+          /* Ensure the per-section output slice is inside the allocation. */
+          if (((uint64_t)i * (uint64_t)info->max_decomp_size)
+              + (uint64_t)info->max_decomp_size > max_decomp_size)
+            {
+              LOG_ERROR ("Some section output size out of bounds")
+              sec_dat->chain = NULL;
+              free (decomp);
+              return type < SECTION_REVHISTORY ? DWG_ERR_INVALIDDWG
+                                               : DWG_ERR_VALUEOUTOFBOUNDS;
+            }
           error = decompress_R2004_section (
               dat, &decomp[i * info->max_decomp_size], // offset
               info->max_decomp_size, es.fields.data_size);
@@ -2386,7 +2422,7 @@ read_2004_compressed_section (Bit_Chain *dat, Dwg_Data *restrict dwg,
       else
         {
           if (info->compressed == 2
-              || info->size > max_decomp_size
+              || (uint64_t)stride > max_decomp_size
               || bytes_left < 0
             /*|| ((unsigned long)(address + es.fields.address + 32
                                    + info->size)
@@ -2399,10 +2435,41 @@ read_2004_compressed_section (Bit_Chain *dat, Dwg_Data *restrict dwg,
               return type < SECTION_REVHISTORY ? DWG_ERR_INVALIDDWG
                                                : DWG_ERR_VALUEOUTOFBOUNDS;
             }
-          memcpy (&decomp[i * info->size],
-                  &dat->chain[address + es.fields.address + 32],
-                  MIN (bytes_left, info->size));
-          bytes_left -= info->size;
+          uint64_t dst_off = (uint64_t)i * stride;
+          size_t copy_len;
+          uint64_t src_off;
+
+          if (dst_off >= max_decomp_size)
+            {
+              LOG_ERROR ("Some section output offset out of bounds")
+              sec_dat->chain = NULL;
+              free (decomp);
+              return type < SECTION_REVHISTORY ? DWG_ERR_INVALIDDWG
+                                               : DWG_ERR_VALUEOUTOFBOUNDS;
+            }
+
+          copy_len = (size_t)MIN ((uint64_t)bytes_left, stride);
+          if (dst_off + copy_len > max_decomp_size)
+            {
+              LOG_ERROR ("Some section output size out of bounds")
+              sec_dat->chain = NULL;
+              free (decomp);
+              return type < SECTION_REVHISTORY ? DWG_ERR_INVALIDDWG
+                                               : DWG_ERR_VALUEOUTOFBOUNDS;
+            }
+
+          src_off = (uint64_t)address + (uint64_t)es.fields.address + 32;
+          if (src_off > dat->size || src_off + copy_len > dat->size)
+            {
+              LOG_ERROR ("Some section input size out of bounds")
+              sec_dat->chain = NULL;
+              free (decomp);
+              return type < SECTION_REVHISTORY ? DWG_ERR_INVALIDDWG
+                                               : DWG_ERR_VALUEOUTOFBOUNDS;
+            }
+
+          memcpy (&decomp[dst_off], &dat->chain[src_off], copy_len);
+          bytes_left -= (long)stride;
           sec_dat->size = max_decomp_size;
         }
     }