diff --git a/src/njs_vmcode.c b/src/njs_vmcode.c
index ec47865..e5d2c46 100644
--- a/src/njs_vmcode.c
+++ b/src/njs_vmcode.c
@@ -797,6 +797,21 @@ next:
                 pnext = (njs_vmcode_prop_next_t *) pc;
                 retval = njs_scope_value(vm, pnext->retval);
 
+                /*
+                 * The PROPERTY_NEXT opcode expects that value2 holds an
+                 * internal iterator state created by PROPERTY_FOREACH.
+                 *
+                 * PROPERTY_FOREACH stores this state as NJS_DATA.  Without
+                 * validation here, crafted bytecode/state may cause an invalid
+                 * pointer dereference.
+                 */
+                if (njs_slow_path(!njs_is_data(value2, NJS_DATA_TAG_ANY)
+                                  || value2->data.u.next == NULL))
+                {
+                    njs_internal_error(vm, "invalid property iterator");
+                    goto error;
+                }
+
                 next = value2->data.u.next;
 
                 if (next->index < next->array->length) {
@@ -808,6 +823,9 @@ next:
 
                 njs_mp_free(vm->mem_pool, next);
 
+                /* Prevent accidental reuse/double free. */
+                njs_set_undefined(value2);
+
                 ret = sizeof(njs_vmcode_prop_next_t);
                 break;
 
@@ -1426,11 +1444,16 @@ njs_vmcode_property_foreach(njs_vm_t *vm, njs_value_t *object,
     next->array = njs_value_enumerate(vm, object, NJS_ENUM_KEYS,
                                       NJS_ENUM_STRING, 0);
     if (njs_slow_path(next->array == NULL)) {
+        njs_mp_free(vm->mem_pool, next);
         njs_memory_error(vm);
         return NJS_ERROR;
     }
 
-    vm->retval.data.u.next = next;
+    /*
+     * Store the iterator state as a proper NJS_DATA value.
+     * Tag 0 (NJS_DATA_TAG_ANY) is used for internal anonymous data.
+     */
+    njs_set_data(&vm->retval, next, NJS_DATA_TAG_ANY);
 
     code = (njs_vmcode_prop_foreach_t *) pc;