diff --git a/src/bifs/field_decode.c b/src/bifs/field_decode.c
index 5537da7..533991f 100644
--- a/src/bifs/field_decode.c
+++ b/src/bifs/field_decode.c
@@ -727,6 +727,8 @@ GF_Node *gf_bifs_dec_node(GF_BifsDecoder * codec, GF_BitStream *bs, u32 NDT_Tag)
 	GF_Node *new_node;
 	GF_Err e;
 	GF_Proto *proto;
+	M_QuantizationParameter *saved_qp;
+	u32 saved_qp_stack_count;
 	void SetupConditional(GF_BifsDecoder *codec, GF_Node *node);
 
 	//to store the UseName
@@ -855,6 +857,16 @@ GF_Node *gf_bifs_dec_node(GF_BifsDecoder * codec, GF_BitStream *bs, u32 NDT_Tag)
 
 	new_node = NULL;
 	skip_init = GF_FALSE;
+	/*
+	 * On parse error we may delete the node (and therefore its children) while leaving
+	 * codec->ActiveQP pointing to a QuantizationParameter node that has just been freed.
+	 * This can later lead to use-after-free in unquantization.
+	 *
+	 * Save and restore the QP context on errors and discard any QPs that were pushed on
+	 * the stack while decoding this node.
+	 */
+	saved_qp = codec->ActiveQP;
+	saved_qp_stack_count = gf_list_count(codec->QPs);
 
 	/*don't check node IDs duplicate since VRML may use them...*/
 #if 0
@@ -925,6 +937,11 @@ GF_Node *gf_bifs_dec_node(GF_BifsDecoder * codec, GF_BitStream *bs, u32 NDT_Tag)
 
 	if (e) {
 		codec->LastError = e;
+		/* restore QP context to avoid leaving dangling pointers */
+		codec->ActiveQP = saved_qp;
+		while (gf_list_count(codec->QPs) > saved_qp_stack_count) {
+			gf_list_rem(codec->QPs, 0);
+		}
 		/*register*/
 		gf_node_register(new_node, NULL);
 		/*unregister (deletes)*/