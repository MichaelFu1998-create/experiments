diff --git a/src/gc.c b/src/gc.c
index a6ff0c5..189465e 100644
--- a/src/gc.c
+++ b/src/gc.c
@@ -533,7 +533,15 @@ MRB_API struct RBasic*
 mrb_obj_alloc(mrb_state *mrb, enum mrb_vtype ttype, struct RClass *cls)
 {
   struct RBasic *p;
-  static const RVALUE RVALUE_zero = { { { NULL, NULL, MRB_TT_FALSE } } };
+  /*
+   * Important: fully zero-initialize the whole RVALUE.
+   *
+   * Initializing only the first union member leaves the rest of the union
+   * storage unspecified. When copied into freshly allocated objects, fields
+   * such as  pointers may contain garbage non-NULL values, leading to
+   * invalid frees/dereferences during GC finalization (e.g. iv_free()).
+   */
+  static const RVALUE RVALUE_zero = { 0 };
   mrb_gc *gc = &mrb->gc;
 
   if (cls) {
diff --git a/src/variable.c b/src/variable.c
index 53b760d..1b31064 100644
--- a/src/variable.c
+++ b/src/variable.c
@@ -229,6 +229,14 @@ iv_copy(mrb_state *mrb, iv_tbl *t)
 static void
 iv_free(mrb_state *mrb, iv_tbl *t)
 {
+  if (t == NULL) return;
+  /*
+   * Hardening:  pointers should always be real heap pointers.
+   * If memory corruption (or a partially initialized object) leaves a small
+   * or misaligned value here, avoid dereferencing it during GC finalization.
+   */
+  if ((uintptr_t)t < 4096 || ((uintptr_t)t & (sizeof(void*)-1)) != 0) return;
+
   mrb_free(mrb, t->ptr);
   mrb_free(mrb, t);
 }