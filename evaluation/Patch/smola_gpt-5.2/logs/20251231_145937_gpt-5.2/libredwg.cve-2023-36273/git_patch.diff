diff --git a/src/decode.c b/src/decode.c
index d68d0fc..10b6925 100644
--- a/src/decode.c
+++ b/src/decode.c
@@ -6329,11 +6329,41 @@ decode_preR13_auxheader (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)
     }
   else
     {
-      crcc = bit_calc_CRC (0xC0C1,
-                           // after sentinel (16 bytes)
-                           &dat->chain[_obj->auxheader_address + 16],
-                           // minus crc length (2 bytes)
-                           _obj->auxheader_size - 2); 
+      /* The auxheader CRC starts after the 16-byte begin sentinel, and the
+         stored CRC itself is the last 2 bytes of the auxheader.
+
+         Previous bounds checks validated only auxheader_address + auxheader_size
+         against dat->size, but the CRC calculation additionally adds the
+         sentinel offset (+16) while subtracting only the CRC length (-2).
+         This could make bit_calc_CRC read past the end of dat->chain for
+         malformed inputs (ASan crash in bit_calc_CRC).
+       */
+      if (_obj->auxheader_size < 2)
+        {
+          LOG_ERROR ("Invalid auxheader_size %u", (unsigned)_obj->auxheader_size);
+          error |= DWG_ERR_WRONGCRC;
+          return error;
+        }
+
+      {
+        const unsigned long crc_start
+            = (unsigned long)_obj->auxheader_address + 16UL;
+        const unsigned long crc_len
+            = (unsigned long)_obj->auxheader_size - 2UL;
+        if (crc_start > dat->size || crc_len > dat->size
+            || crc_start + crc_len > dat->size)
+          {
+            LOG_ERROR ("Invalid auxheader CRC range start=0x%lx len=%lu (size=0x%lx)",
+                       crc_start, crc_len, (unsigned long)dat->size);
+            error |= DWG_ERR_WRONGCRC;
+            return error;
+          }
+
+        crcc = bit_calc_CRC (0xC0C1,
+                             // after sentinel (16 bytes)
+                             &dat->chain[crc_start],
+                             (long)crc_len);
+      }
       crc = bit_read_RS (dat);
       LOG_TRACE ("crc: %04X [RSx] from 0x%x-0x%lx\n", crc,
                  _obj->auxheader_address + 16, dat->byte - 2);