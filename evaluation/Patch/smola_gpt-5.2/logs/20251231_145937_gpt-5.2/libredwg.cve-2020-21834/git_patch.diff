diff --git a/src/dwg.c b/src/dwg.c
index 72c3870..b2b0b0f 100644
--- a/src/dwg.c
+++ b/src/dwg.c
@@ -426,11 +426,16 @@ dwg_bmp (const Dwg_Data *restrict dwg, BITCODE_RL *restrict size)
   *size = 0;
   assert (dwg);
   dat = (Bit_Chain *)&dwg->thumbnail;
-  if (!dat || !dat->size)
+  if (!dat || !dat->size || !dat->chain)
     {
       LOG_INFO ("no THUMBNAIL Image Data\n")
       return NULL;
     }
+
+  /* Start parsing from the beginning of the thumbnail buffer.
+     The Bit_Chain may have been used previously and its cursor fields are not
+     guaranteed to be reset for this helper. */
+  dat->byte = 0;
   dat->bit = 0;
   dat->version = dwg->header.version;
   dat->from_version = dwg->header.from_version;
@@ -471,7 +476,13 @@ dwg_bmp (const Dwg_Data *restrict dwg, BITCODE_RL *restrict size)
       LOG_TRACE ("\t\tHeader data start: 0x%x [RL]\n", address)
       if (code == 1)
         {
-          header_size += bit_read_RL (dat);
+          BITCODE_RL add = bit_read_RL (dat);
+          if (add > dat->size || header_size > dat->size - add)
+            {
+              LOG_ERROR ("Preview header overflow");
+              return NULL;
+            }
+          header_size += add;
           LOG_TRACE ("\t\tHeader data size: %i [RL]\n", header_size)
         }
       else if (code == 2 && found == 0)
@@ -495,10 +506,28 @@ dwg_bmp (const Dwg_Data *restrict dwg, BITCODE_RL *restrict size)
   if (*size)
     LOG_TRACE ("BMP offset: %lu\n", dat->byte)
 
-  if (*size > 0)
-    return (dat->chain + dat->byte);
-  else
+  if (*size == 0)
     return NULL;
+
+  /* Validate that the returned pointer is within the thumbnail buffer.
+     Without these checks a crafted DWG could make us return an out-of-bounds
+     pointer which later gets passed to fwrite() (e.g. by dwgbmp), causing a
+     crash/ASan report. */
+  if (dat->byte > dat->size)
+    {
+      LOG_ERROR ("Preview overflow");
+      return NULL;
+    }
+  if (*size > dat->size - dat->byte)
+    {
+      LOG_ERROR ("Preview overflow (bmp size %lu at offset %lu > %lu)",
+                 (unsigned long)*size, (unsigned long)dat->byte,
+                 (unsigned long)dat->size);
+      *size = 0;
+      return NULL;
+    }
+
+  return (dat->chain + dat->byte);
 }
 
 EXPORT double