diff --git a/src/mat5.c b/src/mat5.c
index abdb351..80f111d 100644
--- a/src/mat5.c
+++ b/src/mat5.c
@@ -35,6 +35,7 @@
 #include <stdio.h>
 #include <math.h>
 #include <time.h>
+#include "safe-math.h"
 #if defined(_MSC_VER) || defined(__MINGW32__)
 #   define SIZE_T_FMTSTR "Iu"
 #   define strdup _strdup
@@ -4773,6 +4774,12 @@ Mat_VarReadNextInfo5( mat_t *mat )
         (void)Mat_int32Swap(&data_type);
         (void)Mat_int32Swap(&nBytes);
     }
+    /* A negative size indicates a malformed file. */
+    if ( nBytes < 0 ) {
+        Mat_Critical("Invalid element size");
+        (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);
+        return NULL;
+    }
     switch ( data_type ) {
         case MAT_T_COMPRESSED:
         {
@@ -4864,21 +4871,51 @@ Mat_VarReadNextInfo5( mat_t *mat )
                     (void)Mat_uint32Swap(uncomp_buf);
                 /* Name of variable */
                 if ( uncomp_buf[0] == MAT_T_INT8 ) {    /* Name not in tag */
-                    mat_uint32_t len, len_pad;
+                    mat_uint32_t len;
+                    size_t len_pad;
                     if ( mat->byteswap )
                         len = Mat_uint32Swap(uncomp_buf+1);
                     else
                         len = uncomp_buf[1];
 
-                    if ( len % 8 == 0 )
-                        len_pad = len;
-                    else
-                        len_pad = len + 8 - (len % 8);
-                    matvar->name = (char*)malloc(len_pad + 1);
+                    /* Overflow-safe padded length (MAT v5 pads to 8-byte boundary). */
+                    len_pad = (size_t)len;
+                    if ( len_pad % 8 != 0 ) {
+                        size_t add = 8 - (len_pad % 8);
+                        if ( !psnip_safe_size_add(&len_pad, len_pad, add) ) {
+                            Mat_VarFree(matvar);
+                            matvar = NULL;
+                            (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);
+                            break;
+                        }
+                    }
+                    /* Sanity check: name must fit within the uncompressed matrix element. */
+                    if ( len_pad > (size_t)nbytes ) {
+                        Mat_VarFree(matvar);
+                        matvar = NULL;
+                        (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);
+                        break;
+                    }
+                    {
+                        size_t alloc_sz;
+                        if ( !psnip_safe_size_add(&alloc_sz, len_pad, 1u) ) {
+                            Mat_VarFree(matvar);
+                            matvar = NULL;
+                            (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);
+                            break;
+                        }
+                        matvar->name = (char*)malloc(alloc_sz);
+                    }
                     if ( NULL != matvar->name ) {
                         /* Variable name */
-                        bytesread += InflateVarName(mat,matvar,matvar->name,len_pad);
+                        bytesread += InflateVarName(mat,matvar,matvar->name,(int)len_pad);
+                        /* len <= len_pad, ensured above */
                         matvar->name[len] = '\0';
+                    } else {
+                        Mat_VarFree(matvar);
+                        matvar = NULL;
+                        (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);
+                        break;
                     }
                 } else {
                     mat_uint32_t len = (uncomp_buf[0] & 0xffff0000) >> 16;
@@ -4967,16 +5004,41 @@ Mat_VarReadNextInfo5( mat_t *mat )
                 (void)Mat_uint32Swap(buf);
             /* Name of variable */
             if ( buf[0] == MAT_T_INT8 ) {    /* Name not in tag */
-                mat_uint32_t len, len_pad;
+                mat_uint32_t len;
+                size_t len_pad;
                 if ( mat->byteswap )
                     len = Mat_uint32Swap(buf+1);
                 else
                     len = buf[1];
-                if ( len % 8 == 0 )
-                    len_pad = len;
-                else
-                    len_pad = len + 8 - (len % 8);
-                matvar->name = (char*)malloc(len_pad + 1);
+
+                /* Overflow-safe padded length (MAT v5 pads to 8-byte boundary). */
+                len_pad = (size_t)len;
+                if ( len_pad % 8 != 0 ) {
+                    size_t add = 8 - (len_pad % 8);
+                    if ( !psnip_safe_size_add(&len_pad, len_pad, add) ) {
+                        Mat_VarFree(matvar);
+                        matvar = NULL;
+                        (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);
+                        break;
+                    }
+                }
+                /* Sanity check: name must fit within the matrix element. */
+                if ( len_pad > (size_t)nBytes ) {
+                    Mat_VarFree(matvar);
+                    matvar = NULL;
+                    (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);
+                    break;
+                }
+                {
+                    size_t alloc_sz;
+                    if ( !psnip_safe_size_add(&alloc_sz, len_pad, 1u) ) {
+                        Mat_VarFree(matvar);
+                        matvar = NULL;
+                        (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);
+                        break;
+                    }
+                    matvar->name = (char*)malloc(alloc_sz);
+                }
                 if ( NULL != matvar->name ) {
                     readresult = fread(matvar->name, 1, len_pad, (FILE*)mat->fp);
                     if ( readresult == len_pad ) {
@@ -4987,6 +5049,11 @@ Mat_VarReadNextInfo5( mat_t *mat )
                         (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);
                         break;
                     }
+                } else {
+                    Mat_VarFree(matvar);
+                    matvar = NULL;
+                    (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);
+                    break;
                 }
             } else {
                 mat_uint32_t len = (buf[0] & 0xffff0000) >> 16;