diff --git a/MagickCore/threshold.c b/MagickCore/threshold.c
index a3bb96a..29e2f70 100644
--- a/MagickCore/threshold.c
+++ b/MagickCore/threshold.c
@@ -209,6 +209,15 @@ MagickExport Image *AdaptiveThresholdImage(const Image *image,
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",image->filename);
   assert(exception != (ExceptionInfo *) NULL);
   assert(exception->signature == MagickCoreSignature);
+
+  /*
+    A width/height of zero is not meaningful for an adaptive neighborhood.
+    Historically this could underflow (width-1) and also yield division by
+    zero (number_pixels).  Clamp to a minimum of 1 to keep behavior safe.
+  */
+  size_t
+    neighborhood_width = width == 0 ? 1UL : width,
+    neighborhood_height = height == 0 ? 1UL : height;
   threshold_image=CloneImage(image,0,0,MagickTrue,exception);
   if (threshold_image == (Image *) NULL)
     return((Image *) NULL);
@@ -223,7 +232,7 @@ MagickExport Image *AdaptiveThresholdImage(const Image *image,
   */
   status=MagickTrue;
   progress=0;
-  number_pixels=(MagickSizeType) width*height;
+  number_pixels=(MagickSizeType) neighborhood_width*neighborhood_height;
   image_view=AcquireVirtualCacheView(image,exception);
   threshold_view=AcquireAuthenticCacheView(threshold_image,exception);
 #if defined(MAGICKCORE_OPENMP_SUPPORT)
@@ -254,8 +263,8 @@ MagickExport Image *AdaptiveThresholdImage(const Image *image,
 
     if (status == MagickFalse)
       continue;
-    p=GetCacheViewVirtualPixels(image_view,-((ssize_t) width/2L),y-(ssize_t)
-      (height/2L),image->columns+width,height,exception);
+    p=GetCacheViewVirtualPixels(image_view,-((ssize_t) neighborhood_width/2L),y-(ssize_t)
+      (neighborhood_height/2L),image->columns+neighborhood_width,neighborhood_height,exception);
     q=QueueCacheViewAuthenticPixels(threshold_view,0,y,threshold_image->columns,
       1,exception);
     if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))
@@ -263,8 +272,8 @@ MagickExport Image *AdaptiveThresholdImage(const Image *image,
         status=MagickFalse;
         continue;
       }
-    center=(ssize_t) GetPixelChannels(image)*(image->columns+width)*(height/2L)+
-      GetPixelChannels(image)*(width/2);
+    center=(ssize_t) GetPixelChannels(image)*(image->columns+neighborhood_width)*(neighborhood_height/2L)+
+      GetPixelChannels(image)*(neighborhood_width/2);
     for (i=0; i < (ssize_t) GetPixelChannels(image); i++)
     {
       PixelChannel channel = GetPixelChannelChannel(image,i);
@@ -282,11 +291,11 @@ MagickExport Image *AdaptiveThresholdImage(const Image *image,
       pixels=p;
       channel_bias[channel]=0.0;
       channel_sum[channel]=0.0;
-      for (v=0; v < (ssize_t) height; v++)
+      for (v=0; v < (ssize_t) neighborhood_height; v++)
       {
-        for (u=0; u < (ssize_t) width; u++)
+        for (u=0; u < (ssize_t) neighborhood_width; u++)
         {
-          if (u == (ssize_t) (width-1))
+          if (u == (ssize_t) (neighborhood_width-1))
             channel_bias[channel]+=pixels[i];
           channel_sum[channel]+=pixels[i];
           pixels+=GetPixelChannels(image);
@@ -316,10 +325,10 @@ MagickExport Image *AdaptiveThresholdImage(const Image *image,
         channel_sum[channel]-=channel_bias[channel];
         channel_bias[channel]=0.0;
         pixels=p;
-        for (v=0; v < (ssize_t) height; v++)
+        for (v=0; v < (ssize_t) neighborhood_height; v++)
         {
           channel_bias[channel]+=pixels[i];
-          pixels+=(width-1)*GetPixelChannels(image);
+          pixels+=(neighborhood_width-1)*GetPixelChannels(image);
           channel_sum[channel]+=pixels[i];
           pixels+=GetPixelChannels(image)*(image->columns+1);
         }