diff --git a/src/vm.c b/src/vm.c
index 1c59d4406..5de76ec32 100644
--- a/src/vm.c
+++ b/src/vm.c
@@ -478,7 +478,18 @@ mrb_funcall_with_block(mrb_state *mrb, mrb_value self, mrb_sym mid, mrb_int argc
     }
     c = mrb_class(mrb, self);
     m = mrb_method_search_vm(mrb, &c, mid);
-    mrb_stack_extend(mrb, argc + 3);
+    /*
+     * We are going to build a new call frame right after the current frame.
+     * The new frame starts at (current ci->stack + nregs).
+     *
+     * mrb_stack_extend() takes `room` relative to the *current* frame base
+     * (mrb->c->ci->stack). Therefore we must include the current frame size
+     * (`n`) when reserving space for the upcoming call frame.
+     *
+     * When the method is undefined (or argc>=15), we will pass arguments as an
+     * array (argc forced to 15) and store the block at stack[2].
+     */
+    mrb_stack_extend(mrb, n + ((MRB_METHOD_UNDEF_P(m) || argc >= 15) ? 3 : (argc + 2)));
     if (MRB_METHOD_UNDEF_P(m) || argc >= 15) {
       mrb_value args = mrb_ary_new_from_values(mrb, argc, argv);
 
@@ -494,7 +505,8 @@ mrb_funcall_with_block(mrb_state *mrb, mrb_value self, mrb_sym mid, mrb_int argc
         mrb_method_missing(mrb, mid, self, args);
       }
       mrb_ary_unshift(mrb, args, mrb_symbol_value(mid));
-      mrb_stack_extend(mrb, n+2);
+      /* reserve at least [self, args, blk] for the upcoming vararg call */
+      mrb_stack_extend(mrb, n+3);
       ci->stack[n+1] = args;
       argc = 15;
     }