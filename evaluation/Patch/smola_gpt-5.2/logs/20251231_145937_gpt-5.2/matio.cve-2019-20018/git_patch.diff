diff --git a/src/inflate.c b/src/inflate.c
index 5fd205a..59882c2 100644
--- a/src/inflate.c
+++ b/src/inflate.c
@@ -348,9 +348,11 @@ size_t
 InflateRankDims(mat_t *mat, matvar_t *matvar, void *buf, size_t nbytes, mat_uint32_t** dims)
 {
     mat_uint8_t comp_buf[32];
-    mat_int32_t tag[2];
-    int    err, rank, i;
+    mat_uint32_t tag[2];
+    mat_uint32_t len;
+    size_t padded_len;
     size_t bytesread = 0, readresult = 1;
+    int    err;
 
     if ( buf == NULL )
         return 0;
@@ -365,6 +367,12 @@ InflateRankDims(mat_t *mat, matvar_t *matvar, void *buf, size_t nbytes, mat_uint
     err = inflate(matvar->internal->z,Z_NO_FLUSH);
     if ( err != Z_OK ) {
         Mat_Critical("InflateRankDims: inflate returned %s",zError(err == Z_NEED_DICT ? Z_DATA_ERROR : err));
+        if ( dims )
+            *dims = NULL;
+        if ( buf ) {
+            ((mat_uint32_t *)buf)[0] = 0;
+            ((mat_uint32_t *)buf)[1] = 0;
+        }
         return bytesread;
     }
     while ( matvar->internal->z->avail_out && !matvar->internal->z->avail_in && 1 == readresult ) {
@@ -375,25 +383,99 @@ InflateRankDims(mat_t *mat, matvar_t *matvar, void *buf, size_t nbytes, mat_uint
         err = inflate(matvar->internal->z,Z_NO_FLUSH);
         if ( err != Z_OK ) {
             Mat_Critical("InflateRankDims: inflate returned %s",zError(err == Z_NEED_DICT ? Z_DATA_ERROR : err));
-            return bytesread;
+        if ( dims )
+            *dims = NULL;
+        if ( buf ) {
+            ((mat_uint32_t *)buf)[0] = 0;
+            ((mat_uint32_t *)buf)[1] = 0;
+        }
+        return bytesread;
         }
     }
-    tag[0] = *(int *)buf;
-    tag[1] = *((int *)buf+1);
+
+    tag[0] = *(mat_uint32_t *)buf;
+    tag[1] = *((mat_uint32_t *)buf+1);
     if ( mat->byteswap ) {
-        Mat_int32Swap(tag);
-        Mat_int32Swap(tag+1);
+        (void)Mat_uint32Swap(tag);
+        (void)Mat_uint32Swap(tag+1);
     }
+
     if ( (tag[0] & 0x0000ffff) != MAT_T_INT32 ) {
         Mat_Critical("InflateRankDims: Reading dimensions expected type MAT_T_INT32");
+        if ( dims )
+            *dims = NULL;
+        if ( buf ) {
+            ((mat_uint32_t *)buf)[0] = 0;
+            ((mat_uint32_t *)buf)[1] = 0;
+        }
+        return bytesread;
+    }
+
+    /* Handle small data element format: length in upper 16 bits, data packed in
+     * tag[1]. This is used for small dimension arrays.
+     */
+    if ( tag[0] & 0xffff0000 ) {
+        len = (tag[0] & 0xffff0000) >> 16;
+        if ( len > 4 ) {
+            Mat_Critical("InflateRankDims: Invalid packed dimensions length %u", len);
+        if ( dims )
+            *dims = NULL;
+        if ( buf ) {
+            ((mat_uint32_t *)buf)[0] = 0;
+            ((mat_uint32_t *)buf)[1] = 0;
+        }
+        return bytesread;
+        }
+
+        /* Normalize output so callers can interpret buf as a normal tag */
+        ((mat_uint32_t *)buf)[0] = MAT_T_INT32;
+        ((mat_uint32_t *)buf)[1] = len;
+
+        if ( dims )
+            *dims = NULL;
+
+        /* Store packed data right after the tag so callers can use buf+2 */
+        if ( nbytes >= 12 ) {
+            ((mat_uint32_t *)buf)[2] = tag[1];
+        } else if ( dims ) {
+            *dims = (mat_uint32_t*)calloc(1, sizeof(mat_uint32_t));
+            if ( NULL != *dims ) {
+                **dims = tag[1];
+            } else {
+                ((mat_uint32_t *)buf)[1] = 0;
+                Mat_Critical("Error allocating memory for dims");
+            }
+        }
+        return bytesread;
+    }
+
+    len = tag[1];
+    if ( len % 4 != 0 ) {
+        Mat_Critical("InflateRankDims: Invalid dimensions length %u", len);
+        if ( dims )
+            *dims = NULL;
+        if ( buf ) {
+            ((mat_uint32_t *)buf)[0] = 0;
+            ((mat_uint32_t *)buf)[1] = 0;
+        }
+        return bytesread;
+    }
+
+    padded_len = len;
+    if ( padded_len % 8 != 0 )
+        padded_len += 8 - (padded_len % 8);
+
+    /* zlib uses uInt for avail_out */
+    if ( padded_len > 0xffffffffu ) {
+        Mat_Critical("InflateRankDims: Dimensions data too large");
+        if ( dims )
+            *dims = NULL;
+        if ( buf ) {
+            ((mat_uint32_t *)buf)[0] = 0;
+            ((mat_uint32_t *)buf)[1] = 0;
+        }
         return bytesread;
     }
-    rank = tag[1];
-    if ( rank % 8 != 0 )
-        i = 8-(rank %8);
-    else
-        i = 0;
-    rank+=i;
 
     if ( !matvar->internal->z->avail_in ) {
         matvar->internal->z->avail_in = 1;
@@ -401,23 +483,38 @@ InflateRankDims(mat_t *mat, matvar_t *matvar, void *buf, size_t nbytes, mat_uint
         bytesread += fread(comp_buf,1,1,(FILE*)mat->fp);
     }
 
-    matvar->internal->z->avail_out = rank;
-    if ( sizeof(mat_uint32_t)*(rank + 2) <= nbytes ) {
-        matvar->internal->z->next_out = (Bytef*)((mat_int32_t *)buf+2);
+    matvar->internal->z->avail_out = (uInt)padded_len;
+    if ( 8 + padded_len <= nbytes ) {
+        matvar->internal->z->next_out = (Bytef*)((mat_uint32_t *)buf+2);
     } else {
         /* Cannot use too small buf, but can allocate output buffer dims */
-        *dims = (mat_uint32_t*)calloc(rank, sizeof(mat_uint32_t));
+        if ( dims == NULL )
+            return bytesread;
+        *dims = (mat_uint32_t*)calloc(padded_len/4, sizeof(mat_uint32_t));
         if ( NULL != *dims ) {
             matvar->internal->z->next_out = (Bytef*)*dims;
         } else {
-            *((mat_int32_t *)buf+1) = 0;
+            ((mat_uint32_t *)buf)[1] = 0;
             Mat_Critical("Error allocating memory for dims");
-            return bytesread;
+        if ( dims )
+            *dims = NULL;
+        if ( buf ) {
+            ((mat_uint32_t *)buf)[0] = 0;
+            ((mat_uint32_t *)buf)[1] = 0;
+        }
+        return bytesread;
         }
     }
+
     err = inflate(matvar->internal->z,Z_NO_FLUSH);
     if ( err != Z_OK ) {
         Mat_Critical("InflateRankDims: inflate returned %s",zError(err == Z_NEED_DICT ? Z_DATA_ERROR : err));
+        if ( dims )
+            *dims = NULL;
+        if ( buf ) {
+            ((mat_uint32_t *)buf)[0] = 0;
+            ((mat_uint32_t *)buf)[1] = 0;
+        }
         return bytesread;
     }
     readresult = 1;
@@ -429,7 +526,13 @@ InflateRankDims(mat_t *mat, matvar_t *matvar, void *buf, size_t nbytes, mat_uint
         err = inflate(matvar->internal->z,Z_NO_FLUSH);
         if ( err != Z_OK ) {
             Mat_Critical("InflateRankDims: inflate returned %s",zError(err == Z_NEED_DICT ? Z_DATA_ERROR : err));
-            return bytesread;
+        if ( dims )
+            *dims = NULL;
+        if ( buf ) {
+            ((mat_uint32_t *)buf)[0] = 0;
+            ((mat_uint32_t *)buf)[1] = 0;
+        }
+        return bytesread;
         }
     }
 
diff --git a/src/mat.c b/src/mat.c
index 253ec25..e2970fd 100644
--- a/src/mat.c
+++ b/src/mat.c
@@ -1464,6 +1464,21 @@ Mat_VarFree(matvar_t *matvar)
         nelems = 1;
         SafeMulDims(matvar, &nelems);
         free(matvar->dims);
+    } else if ( NULL != matvar->data && matvar->data_size > 0 && matvar->nbytes > 0 ) {
+        /* If dims were not read/allocated (e.g. malformed file), fall back to
+         * deriving the number of elements from nbytes. This allows proper
+         * recursive freeing of partially-parsed cell/struct arrays.
+         */
+        if ( matvar->class_type == MAT_C_CELL &&
+             matvar->data_size == (int)sizeof(matvar_t *) &&
+             (matvar->nbytes % (size_t)matvar->data_size) == 0 ) {
+            nelems = matvar->nbytes / (size_t)matvar->data_size;
+        } else if ( matvar->class_type == MAT_C_STRUCT &&
+                    matvar->data_size == (int)sizeof(matvar_t *) &&
+                    matvar->internal != NULL && matvar->internal->num_fields > 0 &&
+                    (matvar->nbytes % ((size_t)matvar->data_size * matvar->internal->num_fields)) == 0 ) {
+            nelems = matvar->nbytes / ((size_t)matvar->data_size * matvar->internal->num_fields);
+        }
     }
     if ( NULL != matvar->data ) {
         switch (matvar->class_type ) {