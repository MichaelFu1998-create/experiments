diff --git a/src/jp2image.cpp b/src/jp2image.cpp
index 07afef0..162c73b 100644
--- a/src/jp2image.cpp
+++ b/src/jp2image.cpp
@@ -503,12 +503,27 @@ namespace Exiv2
                             subBox.length = getLong((byte*)&subBox.length, bigEndian);
                             subBox.type   = getLong((byte*)&subBox.type, bigEndian);
 
-                            // subBox.length makes no sense if it is larger than the rest of the file
-                            if (subBox.length > io_->size() - io_->tell()) {
+                            // Validate sub-box length to prevent negative sizes (underflow) and OOM
+                            if (subBox.length < (uint32_t)sizeof(subBox)) {
                                 throw Error(kerCorruptedMetadata);
                             }
-                            DataBuf data(subBox.length-sizeof(box));
-                            io_->read(data.pData_,data.size_);
+                            const long boxEnd = static_cast<long>(position - sizeof(box) + box.length);
+                            const long subBoxStart = io_->tell() - static_cast<long>(sizeof(subBox));
+                            if (subBoxStart < 0 || boxEnd < subBoxStart) {
+                                throw Error(kerCorruptedMetadata);
+                            }
+                            if (subBoxStart + static_cast<long>(subBox.length) > boxEnd) {
+                                throw Error(kerCorruptedMetadata);
+                            }
+                            const uint32_t dataSize = subBox.length - (uint32_t)sizeof(subBox);
+                            if (static_cast<size_t>(dataSize) > (io_->size() - io_->tell())) {
+                                throw Error(kerCorruptedMetadata);
+                            }
+
+                            DataBuf data(static_cast<long>(dataSize));
+                            const long dataRead = io_->read(data.pData_, data.size_);
+                            if (io_->error()) throw Error(kerFailedToReadImageData);
+                            if (dataRead != data.size_) throw Error(kerInputDataReadFailed);
                             if ( bPrint ) {
                                 out << Internal::stringFormat("%8ld | %8ld |  sub:",(size_t)address,(size_t)subBox.length)
                                     << toAscii(subBox.type)
@@ -554,7 +569,11 @@ namespace Exiv2
                             }
 
                             DataBuf rawData;
-                            rawData.alloc(box.length-sizeof(uuid)-sizeof(box));
+                            
+                            if (box.length < (uint32_t)(sizeof(box) + sizeof(uuid))) {
+                                throw Error(kerCorruptedMetadata);
+                            }
+                            rawData.alloc(static_cast<long>(box.length - (uint32_t)sizeof(uuid) - (uint32_t)sizeof(box)));
                             long    bufRead = io_->read(rawData.pData_, rawData.size_);
                             if (io_->error()) throw Error(kerFailedToReadImageData);
                             if (bufRead != rawData.size_) throw Error(kerInputDataReadFailed);
diff --git a/src/types.cpp b/src/types.cpp
index 17ab051..c636295 100644
--- a/src/types.cpp
+++ b/src/types.cpp
@@ -138,14 +138,20 @@ namespace Exiv2 {
     DataBuf::DataBuf() : pData_(0), size_(0)
     {}
 
-    DataBuf::DataBuf(long size) : pData_(new byte[size]()), size_(size)
-    {}
+    DataBuf::DataBuf(long size) : pData_(0), size_(0)
+    {
+        // Defensive: callers can compute buffer sizes from untrusted input.
+        // Avoid converting negative sizes to huge size_t values.
+        if (size <= 0) return;
+        pData_ = new byte[static_cast<size_t>(size)]();
+        size_ = size;
+    }
 
-    DataBuf::DataBuf(const byte* pData, long size)
+DataBuf::DataBuf(const byte* pData, long size)
         : pData_(0), size_(0)
     {
         if (size > 0) {
-            pData_ = new byte[size];
+            pData_ = new byte[static_cast<size_t>(size)];
             std::memcpy(pData_, pData, size);
             size_ = size;
         }
@@ -160,11 +166,17 @@ namespace Exiv2 {
 
     void DataBuf::alloc(long size)
     {
+        // Defensive: avoid negative sizes being converted to a huge allocation.
+        if (size <= 0) {
+            free();
+            return;
+        }
         if (size > size_) {
+
             delete[] pData_;
             pData_ = 0;
             size_ = 0;
-            pData_ = new byte[size];
+            pData_ = new byte[static_cast<size_t>(size)];
             size_ = size;
         }
     }