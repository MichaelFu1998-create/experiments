diff --git a/MagickCore/fourier.c b/MagickCore/fourier.c
index 24b3824..84495b7 100644
--- a/MagickCore/fourier.c
+++ b/MagickCore/fourier.c
@@ -243,6 +243,14 @@ MagickExport Image *ComplexImages(const Image *images,const ComplexOperator op,
     register ssize_t
       x;
 
+    /*
+      The input images in a complex sequence may not have the same channel
+      count (e.g. grayscale vs. RGBA).  Ensure we never read or write past the
+      end of any pixel row buffer.
+    */
+    size_t
+      channels;
+
     if (status == MagickFalse)
       continue;
     Ar=GetCacheViewVirtualPixels(Ar_view,0,y,Cr_image->columns,1,exception);
@@ -258,12 +266,23 @@ MagickExport Image *ComplexImages(const Image *images,const ComplexOperator op,
         status=MagickFalse;
         continue;
       }
+    channels=GetPixelChannels(Cr_image);
+    if (channels > GetPixelChannels(Ci_image))
+      channels=GetPixelChannels(Ci_image);
+    if (channels > GetPixelChannels(Ar_image))
+      channels=GetPixelChannels(Ar_image);
+    if (channels > GetPixelChannels(Ai_image))
+      channels=GetPixelChannels(Ai_image);
+    if (channels > GetPixelChannels(Br_image))
+      channels=GetPixelChannels(Br_image);
+    if (channels > GetPixelChannels(Bi_image))
+      channels=GetPixelChannels(Bi_image);
     for (x=0; x < (ssize_t) Cr_image->columns; x++)
     {
       register ssize_t
         i;
 
-      for (i=0; i < (ssize_t) GetPixelChannels(Cr_image); i++)
+      for (i=0; i < (ssize_t) channels; i++)
       {
         switch (op)
         {