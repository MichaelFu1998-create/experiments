diff --git a/coders/tiff.c b/coders/tiff.c
index 31839f6..74a0ddf 100644
--- a/coders/tiff.c
+++ b/coders/tiff.c
@@ -490,6 +490,75 @@ static inline unsigned char ClampYCC(double value)
   return((unsigned char)(value));
 }
 
+static inline size_t GetTIFFQuantumRowExtent(const QuantumInfo *quantum_info,
+  const QuantumType quantum_type,const size_t columns)
+{
+  size_t
+    packet_size,
+    pad;
+
+  packet_size=1;
+  switch (quantum_type)
+  {
+    case GrayAlphaQuantum: packet_size=2; break;
+    case IndexAlphaQuantum: packet_size=2; break;
+    case RGBQuantum: packet_size=3; break;
+    case BGRQuantum: packet_size=3; break;
+    case RGBAQuantum: packet_size=4; break;
+    case RGBOQuantum: packet_size=4; break;
+    case BGRAQuantum: packet_size=4; break;
+    case CMYKQuantum: packet_size=4; break;
+    case CMYKAQuantum: packet_size=5; break;
+    case CbYCrAQuantum: packet_size=4; break;
+    case CbYCrQuantum: packet_size=3; break;
+    case CbYCrYQuantum: packet_size=4; break;
+    default: break;
+  }
+
+  pad=quantum_info->pad;
+  if (quantum_info->pack == MagickFalse)
+    {
+      size_t
+        bytes_per_sample,
+        bytes_per_pixel;
+
+      bytes_per_sample=(quantum_info->depth+7U)/8U;
+      if (HeapOverflowSanityCheck(packet_size,bytes_per_sample) != MagickFalse)
+        return(0);
+      bytes_per_pixel=packet_size*bytes_per_sample;
+      if (bytes_per_pixel > (size_t) (~0U)-pad)
+        return(0);
+      bytes_per_pixel+=pad;
+      if (HeapOverflowSanityCheck(columns,bytes_per_pixel) != MagickFalse)
+        return(0);
+      return(columns*bytes_per_pixel);
+    }
+
+  /* Packed (bit-level) quantum. */
+  {
+    size_t
+      sample_count,
+      bits,
+      packed_bytes,
+      pad_bytes;
+
+    if (HeapOverflowSanityCheck(columns,packet_size) != MagickFalse)
+      return(0);
+    sample_count=columns*packet_size;
+    if (HeapOverflowSanityCheck(sample_count,quantum_info->depth) != MagickFalse)
+      return(0);
+    bits=sample_count*quantum_info->depth;
+    packed_bytes=(bits+7U)/8U;
+    if (HeapOverflowSanityCheck(columns,pad) != MagickFalse)
+      return(0);
+    pad_bytes=columns*pad;
+    if (packed_bytes > (size_t) (~0U)-pad_bytes)
+      return(0);
+    return(packed_bytes+pad_bytes);
+  }
+}
+
+
 static MagickBooleanType DecodeLabImage(Image *image,ExceptionInfo *exception)
 {
   CacheView
@@ -1943,6 +2012,16 @@ static Image *ReadTIFFImage(const ImageInfo *image_info,
                 p=strip_pixels;
                 strip_id++;
               }
+            {
+              const size_t
+                row_extent=GetTIFFQuantumRowExtent(quantum_info,quantum_type,
+                  image->columns);
+
+              if ((row_extent == 0) || (row_extent > (size_t) stride) ||
+                  ((size_t) (p-strip_pixels) > (size_t) strip_size) ||
+                  (row_extent > ((size_t) strip_size-(size_t) (p-strip_pixels))))
+                break;
+            }
             (void) ImportQuantumPixels(image,(CacheView *) NULL,
               quantum_info,quantum_type,p,exception);
             p+=stride;
@@ -2049,6 +2128,18 @@ static Image *ReadTIFFImage(const ImageInfo *image_info,
                   exception);
                 if (q == (Quantum *) NULL)
                   break;
+                {
+                  const size_t
+                    row_extent=GetTIFFQuantumRowExtent(quantum_info,quantum_type,
+                      columns_remaining),
+                    tile_row_size=(size_t) TIFFTileRowSize(tiff);
+
+                  if ((row_extent == 0) || (row_extent > tile_row_size) ||
+                      ((size_t) (p-tile_pixels) > (size_t) tiff_status) ||
+                      (row_extent > ((size_t) tiff_status-
+                        (size_t) (p-tile_pixels))))
+                    break;
+                }
                 (void) ImportQuantumPixels(image,(CacheView *) NULL,
                   quantum_info,quantum_type,p,exception);
                 p+=TIFFTileRowSize(tiff);