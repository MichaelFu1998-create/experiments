diff --git a/libarchive/archive_read_support_format_lha.c b/libarchive/archive_read_support_format_lha.c
index b8ef4ae..c9d75cb 100644
--- a/libarchive/archive_read_support_format_lha.c
+++ b/libarchive/archive_read_support_format_lha.c
@@ -1246,9 +1246,16 @@ lha_read_file_extended_header(struct archive_read *a, struct lha *lha,
 			break;
 		case EXT_FILESIZE:
 			if (datasize == sizeof(uint64_t) * 2) {
-				lha->compsize = archive_le64dec(extdheader);
-				extdheader += sizeof(uint64_t);
-				lha->origsize = archive_le64dec(extdheader);
+				uint64_t csize, osize;
+
+				csize = archive_le64dec(extdheader);
+				osize = archive_le64dec(extdheader + sizeof(uint64_t));
+				/* Ignore values that cannot be represented in int64_t. */
+				if (csize <= (uint64_t)INT64_MAX &&
+				    osize <= (uint64_t)INT64_MAX) {
+					lha->compsize = (int64_t)csize;
+					lha->origsize = (int64_t)osize;
+				}
 			}
 			break;
 		case EXT_CODEPAGE:
@@ -1404,6 +1411,12 @@ lha_read_data_none(struct archive_read *a, const void **buff,
 	struct lha *lha = (struct lha *)(a->format->data);
 	ssize_t bytes_avail;
 
+	if (lha->entry_bytes_remaining < 0) {
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+		    "Invalid LHa file size");
+		return (ARCHIVE_FATAL);
+	}
+
 	if (lha->entry_bytes_remaining == 0) {
 		*buff = NULL;
 		*size = 0;
@@ -1419,12 +1432,22 @@ lha_read_data_none(struct archive_read *a, const void **buff,
 	 */
 	*buff = __archive_read_ahead(a, 1, &bytes_avail);
 	if (bytes_avail <= 0) {
-		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
-		    "Truncated LHa file data");
-		return (ARCHIVE_FATAL);
+		/* Premature EOF: stop this entry without further processing. */
+		lha->setflag &= ~CRC_IS_SET;
+		lha->entry_bytes_remaining = 0;
+		lha->end_of_entry = 1;
+		*buff = NULL;
+		*size = 0;
+		*offset = lha->entry_offset;
+		return (lha_end_of_entry(a));
 	}
 	if (bytes_avail > lha->entry_bytes_remaining)
 		bytes_avail = (ssize_t)lha->entry_bytes_remaining;
+	if (bytes_avail < 0) {
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+		    "Invalid LHa file size");
+		return (ARCHIVE_FATAL);
+	}
 	lha->entry_crc_calculated =
 	    lha_crc16(lha->entry_crc_calculated, *buff, bytes_avail);
 	*size = bytes_avail;
@@ -1452,6 +1475,12 @@ lha_read_data_lzh(struct archive_read *a, const void **buff,
 	ssize_t bytes_avail;
 	int r;
 
+	if (lha->entry_bytes_remaining < 0) {
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+		    "Invalid LHa file size");
+		return (ARCHIVE_FATAL);
+	}
+
 	/* If we haven't yet read any data, initialize the decompressor. */
 	if (!lha->decompress_init) {
 		r = lzh_decode_init(&(lha->strm), lha->method);
@@ -1490,9 +1519,14 @@ lha_read_data_lzh(struct archive_read *a, const void **buff,
 	 */
 	lha->strm.next_in = __archive_read_ahead(a, 1, &bytes_avail);
 	if (bytes_avail <= 0) {
-		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
-		    "Truncated LHa file body");
-		return (ARCHIVE_FATAL);
+		/* Premature EOF: stop this entry without further processing. */
+		lha->setflag &= ~CRC_IS_SET;
+		lha->entry_bytes_remaining = 0;
+		lha->end_of_entry = 1;
+		*buff = NULL;
+		*size = 0;
+		*offset = lha->entry_offset;
+		return (lha_end_of_entry(a));
 	}
 	if (bytes_avail > lha->entry_bytes_remaining)
 		bytes_avail = (ssize_t)lha->entry_bytes_remaining;