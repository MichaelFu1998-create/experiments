diff --git a/src/mat5.c b/src/mat5.c
index 2841b58..8a0a2e4 100644
--- a/src/mat5.c
+++ b/src/mat5.c
@@ -35,6 +35,7 @@
 #include <stdio.h>
 #include <math.h>
 #include <time.h>
+#include <limits.h>
 #if defined(_MSC_VER) || defined(__MINGW32__)
 #   define SIZE_T_FMTSTR "Iu"
 #   define strdup _strdup
@@ -53,6 +54,33 @@
 
 static mat_complex_split_t null_complex_data = {NULL,NULL};
 
+/*
+ * Helper for checked size_t multiplication to avoid integer overflow when
+ * computing allocation sizes from MAT file dimensions.
+ * Returns non-zero on overflow, 0 otherwise.
+ */
+static int
+matio_size_mul_overflow(size_t a, size_t b, size_t *result)
+{
+#if defined(__has_builtin)
+#  if __has_builtin(__builtin_mul_overflow)
+    return __builtin_mul_overflow(a, b, result);
+#  endif
+#endif
+#if defined(__GNUC__) && (__GNUC__ >= 5)
+    return __builtin_mul_overflow(a, b, result);
+#else
+    if (a == 0 || b == 0) {
+        *result = 0;
+        return 0;
+    }
+    if (a > (SIZE_MAX / b))
+        return 1;
+    *result = a * b;
+    return 0;
+#endif
+}
+
 /*===========================================================================
  *  Private functions
  *===========================================================================
@@ -1824,21 +1852,47 @@ ReadNextFunctionHandle(mat_t *mat, matvar_t *matvar)
     int j;
     size_t bytesread = 0, nfunctions = 1;
 
-    for ( j = 0; j < matvar->rank; j++ )
-        nfunctions *= matvar->dims[j];
+    /*
+     * The number of function handles is derived from dimensions stored in the
+     * file. Malformed files can set huge values causing integer overflow in
+     * nfunctions and/or allocation size calculations.
+     */
+    for ( j = 0; j < matvar->rank; j++ ) {
+        size_t tmp;
+        if (matio_size_mul_overflow(nfunctions, matvar->dims[j], &tmp)) {
+            Mat_Critical("Integer overflow calculating function handle count");
+            matvar->data = NULL;
+            matvar->data_size = 0;
+            matvar->nbytes = 0;
+            return 0;
+        }
+        nfunctions = tmp;
+    }
 
-    matvar->data = malloc(nfunctions*sizeof(matvar_t *));
-    if ( matvar->data != NULL ) {
-        size_t i;
-        matvar_t **functions = (matvar_t**)matvar->data;;
-        matvar->data_size = sizeof(matvar_t *);
-        matvar->nbytes    = nfunctions*matvar->data_size;
-        for ( i = 0; i < nfunctions; i++ )
-            functions[i] = Mat_VarReadNextInfo(mat);
-    } else {
-        bytesread = 0;
-        matvar->data_size = 0;
-        matvar->nbytes    = 0;
+    /* Prevent overflow in allocation size */
+    {
+        size_t alloc_size;
+        if (matio_size_mul_overflow(nfunctions, sizeof(matvar_t *), &alloc_size)) {
+            Mat_Critical("Integer overflow calculating function handle allocation size");
+            matvar->data = NULL;
+            matvar->data_size = 0;
+            matvar->nbytes = 0;
+            return 0;
+        }
+
+        matvar->data = malloc(alloc_size);
+        if ( matvar->data != NULL ) {
+            size_t i;
+            matvar_t **functions = (matvar_t**)matvar->data;
+            matvar->data_size = sizeof(matvar_t *);
+            matvar->nbytes    = alloc_size;
+            for ( i = 0; i < nfunctions; i++ )
+                functions[i] = Mat_VarReadNextInfo(mat);
+        } else {
+            bytesread = 0;
+            matvar->data_size = 0;
+            matvar->nbytes    = 0;
+        }
     }
 
     return bytesread;