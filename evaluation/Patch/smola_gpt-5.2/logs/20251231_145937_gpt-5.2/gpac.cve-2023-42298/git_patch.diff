diff --git a/src/bifs/unquantize.c b/src/bifs/unquantize.c
index 008a830..292dd4a 100644
--- a/src/bifs/unquantize.c
+++ b/src/bifs/unquantize.c
@@ -225,9 +225,14 @@ Bool Q_IsTypeOn(M_QuantizationParameter *qp, u32 q_type, u32 *NbBits, SFVec3f *b
 //Linear inverse Quantization for floats
 Fixed Q_InverseQuantize(Fixed Min, Fixed Max, u32 NbBits, u32 value)
 {
+	u64 max_val;
+	if (!NbBits) return Min;
+	/* avoid undefined behavior for shifts >= 32 */
+	max_val = (NbBits >= 32) ? 0xFFFFFFFFULL : ((1ULL << NbBits) - 1);
 	if (!value) return Min;
-	if (value == (u32) ((1 << NbBits) - 1) ) return Max;
-	return Min + gf_muldiv(Max - Min, INT2FIX(value), INT2FIX( (1 << NbBits) - 1) );
+	if (value == (u32) max_val) return Max;
+	/* max_val cannot be 0 here since NbBits!=0 */
+	return Min + gf_muldiv(Max - Min, INT2FIX(value), INT2FIX((u32) max_val));
 }
 
 
@@ -280,11 +285,12 @@ GF_Err Q_DecInt(GF_BifsDecoder *codec, GF_BitStream *bs, u32 QType, SFInt32 b_mi
 //in the UnitSphere (R=1.0)
 GF_Err Q_DecCoordOnUnitSphere(GF_BifsDecoder *codec, GF_BitStream *bs, u32 NbBits, u32 NbComp, Fixed *m_ft)
 {
-	u32 i, orient, sign;
-	s32 value;
+	u32 i, orient;
+	s32 value, sign;
 	Fixed tang[4], delta;
 	s32 dir;
-	if (NbBits>32) return GF_NON_COMPLIANT_BITSTREAM;
+	/* NbBits is used as NbBits-1 and as a shift exponent: enforce valid range */
+	if ((NbBits < 2) || (NbBits > 32)) return GF_NON_COMPLIANT_BITSTREAM;
 	if (NbComp != 2 && NbComp != 3) return GF_BAD_PARAM;
 
 	//only 2 or 3 comp in the quantized version
@@ -295,9 +301,15 @@ GF_Err Q_DecCoordOnUnitSphere(GF_BifsDecoder *codec, GF_BitStream *bs, u32 NbBit
 	if ((orient==3) && (NbComp==2)) return GF_NON_COMPLIANT_BITSTREAM;
 
 	for(i=0; i<NbComp; i++) {
-		value = gf_bs_read_int(bs, NbBits) - (1 << (NbBits-1) );
+		u32 abs_val;
+		u32 max_abs = 1U << (NbBits-1);
+		/* centered signed value in range [-2^(NbBits-1), 2^(NbBits-1)-1] */
+		value = (s32) ((s64) gf_bs_read_int(bs, NbBits) - (1LL << (NbBits-1)));
 		sign = (value >= 0) ? 1 : -1;
-		m_ft[i] = sign * Q_InverseQuantize(0, 1, NbBits-1, sign*value);
+		/* magnitude is encoded on NbBits-1 bits, clamp the edge case -2^(NbBits-1) */
+		abs_val = (u32) ((value < 0) ? -(s64)value : (s64)value);
+		if (abs_val >= max_abs) abs_val = max_abs - 1;
+		m_ft[i] = sign * Q_InverseQuantize(0, 1, NbBits-1, abs_val);
 	}
 	delta = 1;
 	for (i=0; i<NbComp; i++) {