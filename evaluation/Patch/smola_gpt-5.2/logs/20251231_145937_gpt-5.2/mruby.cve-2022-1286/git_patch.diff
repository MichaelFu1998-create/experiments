diff --git a/src/proc.c b/src/proc.c
index 100e041..160ea64 100644
--- a/src/proc.c
+++ b/src/proc.c
@@ -84,11 +84,21 @@ mrb_env_new(mrb_state *mrb, struct mrb_context *c, mrb_callinfo *ci, int nstacks
   int n = ci->n;
   int nk = ci->nk;
 
+  /*
+   * REnv stores length and block-index in 8-bit fields (see MRB_ENV_SET_LEN/BIDX).
+   * Reject values that do not fit to avoid truncation and later OOB accesses.
+   */
+  if (nstacks < 0 || nstacks > 0xff) {
+    mrb_raise(mrb, E_RUNTIME_ERROR, "environment too large");
+  }
   e = MRB_OBJ_ALLOC(mrb, MRB_TT_ENV, NULL);
   e->c = tc;
   MRB_ENV_SET_LEN(e, nstacks);
   bidx += (n == 15) ? 1 : n;
   bidx += (nk == 15) ? 1 : (2*nk);
+  if (bidx < 0 || bidx > 0xff) {
+    mrb_raise(mrb, E_RUNTIME_ERROR, "call frame too large");
+  }
   MRB_ENV_SET_BIDX(e, bidx);
   e->mid = ci->mid;
   e->stack = stack;
@@ -153,6 +163,10 @@ mrb_proc_new_cfunc_with_env(mrb_state *mrb, mrb_func_t func, mrb_int argc, const
   struct REnv *e;
   int i;
 
+  if (argc < 0 || argc > 0xff) {
+    mrb_raisef(mrb, E_ARGUMENT_ERROR, "cfunc env too large (%i)", argc);
+  }
+
   p->e.env = e = mrb_env_new(mrb, mrb->c, mrb->c->ci, 0, NULL, NULL);
   p->flags |= MRB_PROC_ENVSET;
   mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)e);
@@ -439,6 +453,9 @@ mrb_proc_merge_lvar(mrb_state *mrb, mrb_irep *irep, struct REnv *env, int num, c
   }
   irep->nlocals += num;
   irep->nregs = irep->nlocals;
+  if (irep->nlocals > 0xff) {
+    mrb_raise(mrb, E_RUNTIME_ERROR, "too many local variables");
+  }
   MRB_ENV_SET_LEN(env, irep->nlocals);
 }
 
diff --git a/src/vm.c b/src/vm.c
index 5f2ef77..3e72a39 100644
--- a/src/vm.c
+++ b/src/vm.c
@@ -1167,32 +1167,55 @@ hash_new_from_values(mrb_state *mrb, mrb_int argc, mrb_value *regs)
 #define ARGUMENT_NORMALIZE(arg_base, arg_info, insn) do { \
   int n = *(arg_info)&0xf; \
   int nk = (*(arg_info)>>4)&0xf; \
+  /* indices are relative to current stack frame (regs[0..irep->nregs-1]) */ \
+  mrb_int frame_max = (mrb_int)irep->nregs; \
   mrb_int bidx = (arg_base) + mrb_bidx(*(arg_info)); \
   if (nk == CALL_MAXARGS) { \
-    mrb_ensure_hash_type(mrb, regs[(arg_base)+(n==CALL_MAXARGS?1:n)+1]); \
+    mrb_int kidx = (arg_base)+(n==CALL_MAXARGS?1:n)+1; \
+    if (0 <= kidx && kidx < frame_max) { \
+      mrb_ensure_hash_type(mrb, regs[kidx]); \
+    } \
+    else { \
+      /* invalid index: ignore keyword arguments */ \
+      *(arg_info) = (uint16_t)n; \
+    } \
   } \
   else if (nk > 0) {  /* pack keyword arguments */ \
     mrb_int kidx = (arg_base)+(n==CALL_MAXARGS?1:n)+1; \
-    mrb_value kdict = hash_new_from_values(mrb, nk, regs+kidx); \
-    regs[kidx] = kdict; \
-    nk = CALL_MAXARGS; \
-    *(arg_info) = n | (nk<<4); \
+    if (0 <= kidx && kidx + (mrb_int)nk*2 <= frame_max) { \
+      mrb_value kdict = hash_new_from_values(mrb, nk, regs+kidx); \
+      regs[kidx] = kdict; \
+      nk = CALL_MAXARGS; \
+      *(arg_info) = (uint16_t)(n | (nk<<4)); \
+    } \
+    else { \
+      /* invalid range: ignore keyword arguments */ \
+      *(arg_info) = (uint16_t)n; \
+    } \
   } \
   \
-  mrb_assert(bidx < irep->nregs+(arg_base)); \
-  mrb_int new_bidx = (arg_base)+mrb_bidx(*(arg_info)); \
+  mrb_int new_bidx = (arg_base) + mrb_bidx(*(arg_info)); \
   if ((insn) == OP_SEND) { \
     /* clear block argument */ \
-    SET_NIL_VALUE(regs[new_bidx]); \
+    if (0 <= new_bidx && new_bidx < frame_max) { \
+      SET_NIL_VALUE(regs[new_bidx]); \
+    } \
     SET_NIL_VALUE(blk); \
   } \
   else { \
-    blk = regs[bidx]; \
+    if (0 <= bidx && bidx < frame_max) { \
+      blk = regs[bidx]; \
+    } \
+    else { \
+      blk = mrb_nil_value(); \
+    } \
     if (!mrb_nil_p(blk) && !mrb_proc_p(blk)) { \
       blk = mrb_type_convert(mrb, blk, MRB_TT_PROC, MRB_SYM(to_proc)); \
       /* The stack might have been reallocated during mrb_type_convert(), see #3622 */ \
     } \
-    regs[new_bidx] = blk; \
+    if (0 <= new_bidx && new_bidx < frame_max) { \
+      regs[new_bidx] = blk; \
+    } \
   } \
 } while (0)
 
@@ -1426,6 +1449,7 @@ RETRY_TRY_BLOCK:
     CASE(OP_SETIDX, B) {
       c = 2;
       mid = MRB_OPSYM(aset);
+      mrb_stack_extend(mrb, (mrb_int)a + 4);
       SET_NIL_VALUE(regs[a+3]);
       goto L_SENDB_SYM;
     }
@@ -1606,6 +1630,7 @@ RETRY_TRY_BLOCK:
     L_SEND_SYM:
     c = 1;
     /* push nil after arguments */
+    mrb_stack_extend(mrb, (mrb_int)a + 3);
     SET_NIL_VALUE(regs[a+2]);
     goto L_SENDB_SYM;
 
@@ -1843,7 +1868,7 @@ RETRY_TRY_BLOCK:
       else {
         struct REnv *e = uvenv(mrb, lv-1);
         if (!e) goto L_NOSUPER;
-        if (MRB_ENV_LEN(e) <= m1+r+m2+1)
+        if (MRB_ENV_LEN(e) <= m1+r+m2+kd+1)
           goto L_NOSUPER;
         stack = e->stack + 1;
       }
@@ -2370,7 +2395,7 @@ RETRY_TRY_BLOCK:
       else {
         struct REnv *e = uvenv(mrb, lv-1);
         if (!e || (!MRB_ENV_ONSTACK_P(e) && e->mid == 0) ||
-            MRB_ENV_LEN(e) <= m1+r+m2+1) {
+            MRB_ENV_LEN(e) <= m1+r+m2+kd+1) {
           localjump_error(mrb, LOCALJUMP_ERROR_YIELD);
           goto L_RAISE;
         }