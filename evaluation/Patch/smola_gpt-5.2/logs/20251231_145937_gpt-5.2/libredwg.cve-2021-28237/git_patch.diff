diff --git a/src/decode.c b/src/decode.c
index 281df66..4ae625e 100644
--- a/src/decode.c
+++ b/src/decode.c
@@ -31,6 +31,7 @@
 #include <string.h>
 #include <stdbool.h>
 #include <assert.h>
+#include <stdint.h>
 
 #define IS_DECODER
 #include "common.h"
@@ -304,7 +305,6 @@ decode_preR13_section (Dwg_Section_Type_r11 id, Bit_Chain *restrict dat,
   BITCODE_BL vcount;
   int error = 0;
   long unsigned int num = dwg->num_objects;
-  long unsigned int old_size = num * sizeof (Dwg_Object);
   long unsigned int size = tbl->number * sizeof (Dwg_Object);
   long unsigned int pos;
 
@@ -325,11 +325,50 @@ decode_preR13_section (Dwg_Section_Type_r11 id, Bit_Chain *restrict dat,
       return DWG_ERR_INVALIDDWG;
     }
   if (dwg->num_objects % REFS_PER_REALLOC == 0)
-    dwg->object = (Dwg_Object*)realloc (dwg->object, old_size + size + REFS_PER_REALLOC);
+    {
+      /* Ensure the object array is large enough for all table entries.
+         The previous logic used a byte-based increment (REFS_PER_REALLOC)
+         which could under-allocate and lead to out-of-bounds writes when
+         accessing dwg->object[num + i]. */
+      size_t need = (size_t)num + (size_t)tbl->number;
+      size_t rounded;
+      size_t bytes;
+      Dwg_Object *newobj;
+
+      if (need < (size_t)num) /* overflow */
+        {
+          LOG_ERROR ("Invalid table number %ld for %-8s [%2d]", (long)tbl->number,
+                     tbl->name, id);
+          return DWG_ERR_INVALIDDWG;
+        }
+      rounded = need;
+      if (rounded % REFS_PER_REALLOC)
+        rounded += (REFS_PER_REALLOC - (rounded % REFS_PER_REALLOC));
+      if (rounded == 0)
+        rounded = REFS_PER_REALLOC;
+      if (rounded > (SIZE_MAX / sizeof (Dwg_Object)))
+        {
+          LOG_ERROR ("Table allocation overflow for %-8s [%2d]", tbl->name, id);
+          return DWG_ERR_INVALIDDWG;
+        }
+      bytes = rounded * sizeof (Dwg_Object);
+
+      if (!dwg->object)
+        newobj = (Dwg_Object *)calloc (rounded, sizeof (Dwg_Object));
+      else
+        newobj = (Dwg_Object *)realloc (dwg->object, bytes);
+      if (!newobj)
+        {
+          LOG_ERROR ("Out of memory");
+          return DWG_ERR_OUTOFMEM;
+        }
+      dwg->object = newobj;
+    }
 
     // TODO: move to a spec dwg_r11.spec, and dwg_decode_r11_NAME
 #define PREP_TABLE(token)                                                     \
   Dwg_Object *obj = &dwg->object[num + i];                                    \
+  memset (obj, 0, sizeof (Dwg_Object));                                       \
   Dwg_Object_##token *_obj = (Dwg_Object_##token*)calloc (1, sizeof (Dwg_Object_##token)); \
   if (dat->byte > dat->size)                                                  \
     {                                                                         \
@@ -346,9 +385,9 @@ decode_preR13_section (Dwg_Section_Type_r11 id, Bit_Chain *restrict dat,
   dwg->num_objects++;                                                         \
   obj->tio.object->tio.token = _obj;                                          \
   obj->tio.object->objid = obj->index;                                        \
-  obj->tio.object->dwg = obj->parent;                                         \
-  obj->supertype = DWG_SUPERTYPE_OBJECT;                                      \
   obj->parent = dwg;                                                          \
+  obj->tio.object->dwg = dwg;                                                 \
+  obj->supertype = DWG_SUPERTYPE_OBJECT;                                      \
   obj->name = obj->dxfname = (char *)#token;                                  \
   obj->type = obj->fixedtype = DWG_TYPE_##token;                              \
   _obj->parent = obj->tio.object;                                             \