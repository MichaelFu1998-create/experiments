diff --git a/mrbgems/mruby-io/src/io.c b/mrbgems/mruby-io/src/io.c
index 58bcdd1..0b538fe 100644
--- a/mrbgems/mruby-io/src/io.c
+++ b/mrbgems/mruby-io/src/io.c
@@ -561,14 +561,38 @@ mrb_io_initialize_copy(mrb_state *mrb, mrb_value copy)
   mrb_bool failed = TRUE;
 
   mrb_get_args(mrb, "o", &orig);
+
+  /*
+   * Guard: File#initialize_copy should only copy from another IO/File object.
+   * This method can be called directly from Ruby with arbitrary objects;
+   * treat non-IO sources as a no-op to avoid type errors and, more importantly,
+   * to prevent lifetime issues with the internal fptr.
+   */
+  if (mrb_type(orig) != MRB_TT_DATA || DATA_TYPE(orig) != &mrb_io_type) {
+    return copy;
+  }
+
+  /*
+   * initialize_copy is intended to copy from a different object, but Ruby code
+   * can call it with the same receiver (or with another object sharing the
+   * same data pointer). Guard against freeing the active fptr.
+   */
+  if (mrb_obj_ptr(copy) == mrb_obj_ptr(orig)) {
+    return copy;
+  }
+
+  /* Validate/obtain the source fptr first. This may raise an exception. */
+  fptr_orig = io_get_open_fptr(mrb, orig);
+
   fptr_copy = (struct mrb_io *)DATA_PTR(copy);
-  if (fptr_copy != NULL) {
+  if (fptr_copy != NULL && fptr_copy != fptr_orig) {
+    /* Detach first so that GC finalizers cannot see a freed pointer. */
+    DATA_PTR(copy) = NULL;
     fptr_finalize(mrb, fptr_copy, FALSE);
     mrb_free(mrb, fptr_copy);
   }
-  fptr_copy = (struct mrb_io *)mrb_io_alloc(mrb);
-  fptr_orig = io_get_open_fptr(mrb, orig);
 
+  fptr_copy = (struct mrb_io *)mrb_io_alloc(mrb);
   DATA_TYPE(copy) = &mrb_io_type;
   DATA_PTR(copy) = fptr_copy;