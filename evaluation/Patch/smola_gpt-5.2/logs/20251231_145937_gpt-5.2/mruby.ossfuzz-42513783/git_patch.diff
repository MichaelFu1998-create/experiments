diff --git a/mrbgems/mruby-bigint/core/bigint.c b/mrbgems/mruby-bigint/core/bigint.c
index dd6674e1f..c1d512f7e 100644
--- a/mrbgems/mruby-bigint/core/bigint.c
+++ b/mrbgems/mruby-bigint/core/bigint.c
@@ -361,6 +361,14 @@ urshift(mrb_state *mrb, mpz_t *c1, mpz_t *a, size_t n)
 {
   mrb_assert(n < DIG_SIZE);
 
+  /* a may be 0 with sz==0 and p==NULL (see mpz_init/zero).
+     In that case the loop below would underflow (a->sz-1) and
+     access invalid memory. */
+  if (a->sz == 0 || uzero(a)) {
+    mpz_set_int(mrb, c1, 0);
+    return;
+  }
+
   if (n == 0)
     mpz_set(mrb, c1, a);
   else {
@@ -750,6 +758,10 @@ mpz_get_int(mpz_t *y, mrb_int *v)
 static void
 mpz_mul_2exp(mrb_state *mrb, mpz_t *z, mpz_t *x, mrb_int e)
 {
+  if (x->sn == 0 || uzero(x)) {
+    mpz_set_int(mrb, z, 0);
+    return;
+  }
   if (e==0)
     mpz_set(mrb, z, x);
   else {
@@ -758,6 +770,7 @@ mpz_mul_2exp(mrb_state *mrb, mpz_t *z, mpz_t *x, mrb_int e)
     size_t bs = (e % (DIG_SIZE));
     mpz_t y;
 
+
     mpz_init(mrb, &y);
     mpz_realloc(mrb, &y, x->sz+digs);
     for (size_t i=0;i<x->sz;i++)
@@ -777,6 +790,10 @@ static void
 mpz_div_2exp(mrb_state *mrb, mpz_t *z, mpz_t *x, mrb_int e)
 {
   short sn = x->sn;
+  if (sn == 0 || uzero(x)) {
+    mpz_set_int(mrb, z, 0);
+    return;
+  }
   if (e==0)
     mpz_set(mrb, z, x);
   else {
@@ -784,6 +801,14 @@ mpz_div_2exp(mrb_state *mrb, mpz_t *z, mpz_t *x, mrb_int e)
     size_t bs = (e % (DIG_SIZE));
     mpz_t y;
 
+
+    /* Shifting by more digits than present yields 0.
+       Avoid size_t underflow in x->sz-digs and later reads. */
+    if (digs >= x->sz) {
+      mpz_set_int(mrb, z, 0);
+      return;
+    }
+
     mpz_init(mrb, &y);
     mpz_realloc(mrb, &y, x->sz-digs);
     for (size_t i=0; i < x->sz-digs; i++)