diff --git a/mrbgems/mruby-fiber/src/fiber.c b/mrbgems/mruby-fiber/src/fiber.c
index 83153a9..9310475 100644
--- a/mrbgems/mruby-fiber/src/fiber.c
+++ b/mrbgems/mruby-fiber/src/fiber.c
@@ -179,6 +179,23 @@ fiber_switch_context(mrb_state *mrb, struct mrb_context *c)
   mrb->c = c;
 }
 
+/*
+ * Ensure the target fiber context has enough stack space.
+ *
+ * mrb_stack_extend() operates on mrb->c, so temporarily switch mrb->c
+ * to the target context.
+ */
+static void
+fiber_stack_extend(mrb_state *mrb, struct mrb_context *c, int room)
+{
+  struct mrb_context *old_c = mrb->c;
+
+  if (c->stack + room < c->stend) return;
+  mrb->c = c;
+  mrb_stack_extend(mrb, room);
+  mrb->c = old_c;
+}
+
 static mrb_value
 fiber_switch(mrb_state *mrb, mrb_value self, mrb_int len, const mrb_value *a, mrb_bool resume, mrb_bool vmexec)
 {
@@ -201,9 +218,12 @@ fiber_switch(mrb_state *mrb, mrb_value self, mrb_int len, const mrb_value *a, mr
   if (c->status == MRB_FIBER_CREATED) {
     mrb_value *b, *e;
 
-    if (len >= c->stend - c->stack) {
-      mrb_raise(mrb, E_FIBER_ERROR, "too many arguments to fiber");
-    }
+    /*
+     * The first resume passes arguments as registers (regs+1..).
+     * OP_ENTER expects them to be present on the stack, so make sure
+     * the fiber stack can accommodate all arguments (+ self).
+     */
+    fiber_stack_extend(mrb, c, (int)len + 2);
     b = c->stack+1;
     e = b + len;
     while (b<e) {