diff --git a/src/media_tools/mpeg2_ps.c b/src/media_tools/mpeg2_ps.c
index 0af7a31..c95bd0e 100644
--- a/src/media_tools/mpeg2_ps.c
+++ b/src/media_tools/mpeg2_ps.c
@@ -266,6 +266,13 @@ int MPEG12_ParseSeqHdr(unsigned char *pbuffer, u32 buflen, s32 *have_mpeg2, u32
 	u32 scode, ix;
 	s32 found = -1;
 	*have_mpeg2 = 0;
+	u32 orig_buflen = buflen;
+	if (buflen < 6) return -1;
+	/*
+	 * Keep the historical parsing logic below (which uses a reduced buflen to avoid
+	 * scanning too close to the end of the buffer), but ensure no underflow and
+	 * validate the required number of bytes before dereferencing.
+	 */
 	buflen -= 6;
 	bitrate_int = 0;
 	for (ix = 0; ix < buflen; ix++, pbuffer++) {
@@ -273,6 +280,8 @@ int MPEG12_ParseSeqHdr(unsigned char *pbuffer, u32 buflen, s32 *have_mpeg2, u32
 		        pbuffer[3];
 
 		if (scode == MPEG12_SEQUENCE_START_CODE) {
+			/* Need 4 bytes for start code + 7 bytes of sequence header payload */
+			if (orig_buflen < ix + sizeof(u32) + 7) return found;
 			pbuffer += sizeof(u32);
 			*width = (pbuffer[0]);
 			*width <<= 4;
@@ -320,6 +329,8 @@ int MPEG12_ParseSeqHdr(unsigned char *pbuffer, u32 buflen, s32 *have_mpeg2, u32
 			found = 0;
 		} else if (found == 0) {
 			if (scode == MPEG12_EXT_START_CODE) {
+				/* Need 4 bytes for start code + at least 4 bytes of extension payload */
+				if (orig_buflen < ix + sizeof(u32) + 4) return found;
 				pbuffer += sizeof(u32);
 				ix += sizeof(u32);
 				switch ((pbuffer[0] >> 4) & 0xf) {