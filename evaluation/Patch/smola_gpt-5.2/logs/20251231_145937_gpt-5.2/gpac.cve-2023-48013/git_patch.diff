diff --git a/src/isomedia/media.c b/src/isomedia/media.c
index 2a2d614..68a7ef9 100644
--- a/src/isomedia/media.c
+++ b/src/isomedia/media.c
@@ -615,11 +615,25 @@ GF_Err Media_GetSample(GF_MediaBox *mdia, u32 sampleNumber, GF_ISOSample **samp,
 
 		/*and finally get the data, include padding if needed*/
 		if ((*samp)->alloc_size) {
+			/*
+			 * If the caller provided an external allocator (sample_alloc_cbk), we must
+			 * NEVER gf_realloc() the buffer here.
+			 *
+			 * In such cases, the buffer may be owned by another subsystem (e.g. filter
+			 * packets) and reallocating it here would invalidate the original pointer
+			 * held by that owner, leading to double-free/use-after-free during cleanup.
+			 */
 			if ((*samp)->alloc_size < data_size + mdia->mediaTrack->padding_bytes) {
-				(*samp)->data = (char *) gf_realloc((*samp)->data, sizeof(char) * ( data_size + mdia->mediaTrack->padding_bytes) );
-				if (! (*samp)->data) return GF_OUT_OF_MEM;
+				if (ext_realloc) {
+					(*samp)->data = mdia->mediaTrack->sample_alloc_cbk(data_size + mdia->mediaTrack->padding_bytes, mdia->mediaTrack->sample_alloc_udta);
+					if (! (*samp)->data) return GF_OUT_OF_MEM;
+					(*samp)->alloc_size = data_size + mdia->mediaTrack->padding_bytes;
+				} else {
+					(*samp)->data = (char *) gf_realloc((*samp)->data, sizeof(char) * ( data_size + mdia->mediaTrack->padding_bytes) );
+					if (! (*samp)->data) return GF_OUT_OF_MEM;
 
-				(*samp)->alloc_size = data_size + mdia->mediaTrack->padding_bytes;
+					(*samp)->alloc_size = data_size + mdia->mediaTrack->padding_bytes;
+				}
 			}
 		} else {
 			if (ext_realloc) {
@@ -628,6 +642,7 @@ GF_Err Media_GetSample(GF_MediaBox *mdia, u32 sampleNumber, GF_ISOSample **samp,
 				(*samp)->data = (u8 *) gf_malloc(data_size + mdia->mediaTrack->padding_bytes);
 			}
 			if (! (*samp)->data) return GF_OUT_OF_MEM;
+			(*samp)->alloc_size = data_size + mdia->mediaTrack->padding_bytes;
 		}
 		(*samp)->dataLength = data_size;
 		if (mdia->mediaTrack->padding_bytes)