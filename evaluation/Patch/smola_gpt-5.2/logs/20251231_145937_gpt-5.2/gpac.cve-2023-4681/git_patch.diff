diff --git a/src/media_tools/avilib.c b/src/media_tools/avilib.c
index 27cd811..116f190 100644
--- a/src/media_tools/avilib.c
+++ b/src/media_tools/avilib.c
@@ -541,14 +541,41 @@ static int avi_add_odml_index_entry(avi_t *AVI, unsigned char *tag, int flags, u
 
 static int avi_add_index_entry(avi_t *AVI, unsigned char *tag, int flags, u64 pos, u64 len)
 {
-	if(AVI->n_idx>=AVI->max_idx) {
-		void *ptr = gf_realloc((void *)AVI->idx,(AVI->max_idx+4096)*16);
-
-		if(ptr == 0) {
+	/*
+	 * Safety: AVI->idx may be NULL even if max_idx is non-zero (e.g. partially
+	 * initialised structures or error paths). Ensure the index buffer exists
+	 * before writing into it.
+	 */
+	if (!AVI || !tag) return -1;
+	if (!AVI->idx || (AVI->n_idx>=AVI->max_idx)) {
+		/*
+		 * Harden against corrupted values in AVI->max_idx (can be negative or
+		 * extremely large when parsing broken files), which could otherwise
+		 * lead to integer overflows and huge allocations.
+		 */
+		if (AVI->max_idx < 0) {
+			AVI_errno = AVI_ERR_READ;
+			return -1;
+		}
+		/* cap index to a reasonable amount of memory (4 million entries -> 64MB) */
+		const u32 AVI_MAX_IDX_ENTRIES = 4u * 1024u * 1024u;
+		u32 cur_max = (u32) AVI->max_idx;
+		u32 new_max = cur_max + 4096;
+		if (new_max < cur_max || new_max > AVI_MAX_IDX_ENTRIES) {
+			AVI_errno = AVI_ERR_NO_MEM;
+			return -1;
+		}
+		size_t new_size = (size_t) new_max * 16u;
+		if (new_size / 16u != (size_t) new_max) {
+			AVI_errno = AVI_ERR_NO_MEM;
+			return -1;
+		}
+		void *ptr = gf_realloc((void *) AVI->idx, new_size);
+		if (ptr == 0) {
 			AVI_errno = AVI_ERR_NO_MEM;
 			return -1;
 		}
-		AVI->max_idx += 4096;
+		AVI->max_idx = (int) new_max;
 		AVI->idx = (unsigned char((*)[16]) ) ptr;
 	}
 
diff --git a/src/media_tools/mpeg2_ps.c b/src/media_tools/mpeg2_ps.c
index 8e33e48..4c4dfc0 100644
--- a/src/media_tools/mpeg2_ps.c
+++ b/src/media_tools/mpeg2_ps.c
@@ -160,16 +160,21 @@ static Bool file_read_bytes(FILE *fd,
                             u8 *buffer,
                             u32 len)
 {
+	/*
+	 * Safety: several call sites assume file operations always succeed.
+	 * When the per-stream FILE cannot be opened, fd may be NULL and
+	 * gf_fread would crash.
+	 */
+	if (!fd || (!buffer && len)) return 0;
 	u32 readval = (u32) gf_fread(buffer, len, fd);
 	return readval == len;
 }
-
 // note: len could be negative.
 static void file_skip_bytes (FILE *fd, s32 len)
 {
+	if (!fd) return;
 	gf_fseek(fd, len, SEEK_CUR);
 }
-
 #define file_location(__f) gf_ftell(__f)
 #define file_seek_to(__f, __off) gf_fseek(__f, __off, SEEK_SET)
 
@@ -1143,8 +1148,12 @@ static void check_fd_for_stream (mpeg2ps_t *ps,
 	if (sptr->m_fd != FDNULL) return;
 
 	sptr->m_fd = file_open(ps->filename);
+	/* Fallback to main program stream FD if we cannot open a dedicated one.
+	 * This avoids NULL dereferences in subsequent fread/ftell/fseek calls.
+	 */
+	if (!file_okay(sptr->m_fd))
+		sptr->m_fd = ps->fd;
 }
-
 /*
  * advance_frame - when we're reading frames, this indicates that we're
  * done.  We will call this when we read a frame, but not when we