diff --git a/src/odf/descriptors.c b/src/odf/descriptors.c
index 0d42ff2..e7adcd5 100644
--- a/src/odf/descriptors.c
+++ b/src/odf/descriptors.c
@@ -1371,6 +1371,7 @@ GF_VVCConfig *gf_odf_vvc_cfg_read_bs(GF_BitStream *bs)
 	for (i=0; i<count; i++) {
 		u32 nalucount, j;
 		Bool valid = GF_FALSE;
+		u32 nalu_type;
 		GF_NALUFFParamArray *ar;
 		GF_SAFEALLOC(ar, GF_NALUFFParamArray);
 		if (!ar) {
@@ -1380,9 +1381,10 @@ GF_VVCConfig *gf_odf_vvc_cfg_read_bs(GF_BitStream *bs)
 		}
 		ar->array_completeness = gf_bs_read_int(bs, 1);
 		gf_bs_read_int(bs, 2);
-		ar->type = gf_bs_read_int(bs, 5);
+		nalu_type = gf_bs_read_int(bs, 5);
+		ar->type = nalu_type;
 
-		switch (ar->type) {
+		switch (nalu_type) {
 		case GF_VVC_NALU_DEC_PARAM:
 		case GF_VVC_NALU_OPI:
 		case GF_VVC_NALU_VID_PARAM:
@@ -1395,12 +1397,15 @@ GF_VVCConfig *gf_odf_vvc_cfg_read_bs(GF_BitStream *bs)
 			gf_list_add(cfg->param_array, ar);
 			break;
 		default:
-			GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, ("[VVC] Invalid NALU type in vvcC - ignoring\n", ar->nalus));
+			GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, ("[VVC] Invalid NALU type in vvcC - ignoring\n"));
 			gf_free(ar);
+			ar = NULL;
 			break;
 		}
 
-		if ((ar->type != GF_VVC_NALU_DEC_PARAM) && (ar->type != GF_VVC_NALU_OPI))
+		/* for invalid types, we still have to parse and skip NAL unit payloads,
+		   but we must not touch the freed array structure */
+		if ((nalu_type != GF_VVC_NALU_DEC_PARAM) && (nalu_type != GF_VVC_NALU_OPI))
 			nalucount = gf_bs_read_int(bs, 16);
 		else
 			nalucount = 1;