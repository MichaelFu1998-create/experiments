diff --git a/src/mat5.c b/src/mat5.c
index abdb351..d742646 100644
--- a/src/mat5.c
+++ b/src/mat5.c
@@ -1353,6 +1353,25 @@ ReadNextStructField( mat_t *mat, matvar_t *matvar )
                     (void)Mat_uint32Swap(uncomp_buf);
                     (void)Mat_uint32Swap(uncomp_buf+1);
                 }
+                /*
+                 * Defensive validation: if InflateRankDims stored the
+                 * dimensions in uncomp_buf (dims == uncomp_buf+2), ensure
+                 * the byte count fits in the remaining buffer.
+                 *
+                 * A malformed file can advertise a dimensions byte-count
+                 * larger than what fits in uncomp_buf, which would make the
+                 * loop below read past the end of the stack buffer.
+                 */
+                if ( dims == uncomp_buf + 2 ) {
+                    const mat_uint32_t max_dim_bytes = (mat_uint32_t)(sizeof(uncomp_buf) - 2U*sizeof(uncomp_buf[0]));
+                    if ( uncomp_buf[1] > max_dim_bytes || (uncomp_buf[1] % 4U) != 0 ) {
+                        Mat_Critical("Invalid dimensions tag");
+                        Mat_VarFree(matvar);
+                        matvar = NULL;
+                        (void)fseek((FILE*)mat->fp,nbytes-bytesread,SEEK_CUR);
+                        break;
+                    }
+                }
                 /* Rank and dimension */
                 if ( uncomp_buf[0] == MAT_T_INT32 ) {
                     int j;
@@ -4805,7 +4824,7 @@ Mat_VarReadNextInfo5( mat_t *mat )
             }
             nbytes = uncomp_buf[1];
             if ( uncomp_buf[0] != MAT_T_MATRIX ) {
-                (void)fseek((FILE*)mat->fp,nBytes-bytesread,SEEK_CUR);
+                (void)fseek((FILE*)mat->fp,nbytes-bytesread,SEEK_CUR);
                 Mat_VarFree(matvar);
                 matvar = NULL;
                 Mat_Critical("Uncompressed type not MAT_T_MATRIX");
@@ -4842,12 +4861,40 @@ Mat_VarReadNextInfo5( mat_t *mat )
                     (void)Mat_uint32Swap(uncomp_buf);
                     (void)Mat_uint32Swap(uncomp_buf+1);
                 }
+                /*
+                 * Defensive validation: if InflateRankDims stored the
+                 * dimensions in uncomp_buf (dims == uncomp_buf+2), ensure
+                 * the byte count fits in the remaining buffer.
+                 *
+                 * A malformed file can advertise a dimensions byte-count
+                 * larger than what fits in uncomp_buf, which would make the
+                 * loop below read past the end of the stack buffer.
+                 */
+                if ( dims == uncomp_buf + 2 ) {
+                    const mat_uint32_t max_dim_bytes = (mat_uint32_t)(sizeof(uncomp_buf) - 2U*sizeof(uncomp_buf[0]));
+                    if ( uncomp_buf[1] > max_dim_bytes || (uncomp_buf[1] % 4U) != 0 ) {
+                        Mat_Critical("Invalid dimensions tag");
+                        Mat_VarFree(matvar);
+                        matvar = NULL;
+                        (void)fseek((FILE*)mat->fp,nbytes-bytesread,SEEK_CUR);
+                        break;
+                    }
+                }
                 /* Rank and dimension */
                 if ( uncomp_buf[0] == MAT_T_INT32 ) {
                     int j;
                     nbytes = uncomp_buf[1];
                     matvar->rank = nbytes / 4;
                     matvar->dims = (size_t*)malloc(matvar->rank*sizeof(*matvar->dims));
+                    if ( NULL == matvar->dims ) {
+                        Mat_Critical("Couldn\'t allocate memory");
+                        if ( do_clean )
+                            free(dims);
+                        Mat_VarFree(matvar);
+                        matvar = NULL;
+                        (void)fseek((FILE*)mat->fp,nbytes-bytesread,SEEK_CUR);
+                        break;
+                    }
                     if ( mat->byteswap ) {
                         for ( j = 0; j < matvar->rank; j++ )
                             matvar->dims[j] = Mat_uint32Swap(dims + j);