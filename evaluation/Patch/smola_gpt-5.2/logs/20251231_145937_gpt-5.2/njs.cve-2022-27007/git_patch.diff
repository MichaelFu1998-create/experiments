diff --git a/src/njs_async.c b/src/njs_async.c
index e4dd748..33f1261 100644
--- a/src/njs_async.c
+++ b/src/njs_async.c
@@ -163,6 +163,11 @@ njs_await_rejected(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,
 static void
 njs_async_context_free(njs_vm_t *vm, njs_async_ctx_t *ctx)
 {
+    if (ctx->await != NULL) {
+        njs_mp_free(vm->mem_pool, ctx->await);
+        ctx->await = NULL;
+    }
+
     njs_mp_free(vm->mem_pool, ctx->capability);
     njs_mp_free(vm->mem_pool, ctx);
 }
diff --git a/src/njs_function.c b/src/njs_function.c
index c9d4d97..c792c46 100644
--- a/src/njs_function.c
+++ b/src/njs_function.c
@@ -811,10 +811,26 @@ njs_function_frame_save(njs_vm_t *vm, njs_frame_t *frame, u_char *pc)
     njs_native_frame_t  *active, *native;
 
     *frame = *vm->active_frame;
+
+    /*
+     * The frame can be restored later (e.g. async/await) and inserted back
+     * into the VM call stack.  The original active frame is stack-allocated
+     * and can be freed before restoration.
+     *
+     * Do not preserve allocator bookkeeping fields (free/free_size/size)
+     * pointing to the original stack chunk, otherwise subsequent
+     * njs_function_frame_alloc() may try to allocate from a freed memory
+     * region resulting in use-after-free.
+     */
     frame->previous_active_frame = NULL;
 
     native = &frame->native;
 
+    native->free = NULL;
+    native->free_size = 0;
+    native->size = 0;
+    native->previous = NULL;
+
     active = &vm->active_frame->native;
     value_count = njs_function_frame_value_count(active);
 
diff --git a/src/njs_vm.c b/src/njs_vm.c
index dadec63..7b0996b 100644
--- a/src/njs_vm.c
+++ b/src/njs_vm.c
@@ -8,6 +8,9 @@
 #include <njs_main.h>
 
 
+#define NJS_MAX_EVENT_TASKS  100000
+
+
 static njs_int_t njs_vm_init(njs_vm_t *vm);
 static njs_int_t njs_vm_handle_events(njs_vm_t *vm);
 
@@ -563,12 +566,15 @@ njs_vm_handle_events(njs_vm_t *vm)
     njs_str_t         str;
     njs_value_t       string;
     njs_event_t       *ev;
+    njs_uint_t        tasks;
     njs_queue_t       *promise_events, *posted_events;
     njs_queue_link_t  *link;
 
     promise_events = &vm->promise_events;
     posted_events = &vm->posted_events;
 
+    tasks = 0;
+
     do {
         for ( ;; ) {
             link = njs_queue_first(promise_events);
@@ -581,6 +587,11 @@ njs_vm_handle_events(njs_vm_t *vm)
 
             njs_queue_remove(&ev->link);
 
+
+            if (++tasks > NJS_MAX_EVENT_TASKS) {
+                njs_range_error(vm, "Maximum event loop tasks exceeded");
+                return NJS_ERROR;
+            }
             ret = njs_vm_call(vm, ev->function, ev->args, ev->nargs);
             if (njs_slow_path(ret == NJS_ERROR)) {
                 return ret;
@@ -620,6 +631,11 @@ njs_vm_handle_events(njs_vm_t *vm)
                 njs_queue_remove(&ev->link);
             }
 
+
+            if (++tasks > NJS_MAX_EVENT_TASKS) {
+                njs_range_error(vm, "Maximum event loop tasks exceeded");
+                return NJS_ERROR;
+            }
             ret = njs_vm_call(vm, ev->function, ev->args, ev->nargs);
 
             if (ret == NJS_ERROR) {