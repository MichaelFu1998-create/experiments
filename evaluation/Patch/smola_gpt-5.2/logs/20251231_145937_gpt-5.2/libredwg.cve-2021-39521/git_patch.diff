diff --git a/src/bits.c b/src/bits.c
index e187757..4f495cf 100644
--- a/src/bits.c
+++ b/src/bits.c
@@ -102,12 +102,36 @@ bit_set_position (Bit_Chain *dat, unsigned long bitpos)
 void
 bit_reset_chain (Bit_Chain *dat)
 {
+  if (!dat || !dat->chain)
+    {
+      /* Avoid pointer arithmetic on a NULL/invalid chain. This can happen
+         on malformed input where the Bit_Chain was not properly initialized. */
+      if (dat)
+        {
+          dat->byte = 0;
+          dat->bit = 0;
+          dat->size = 0;
+          dat->chain = NULL;
+        }
+      return;
+    }
+
   unsigned long pos = dat->byte;
   dat->byte = 0;
-  if (pos < dat->size) // not already overflowed
-    dat->chain += pos;
-  if (dat->size > 0)
-    dat->size -= pos;
+  if (pos >= dat->size)
+    {
+      /* Do not underflow dat->size. A corrupted byte offset can otherwise
+         turn size into a huge value and later reads will bypass overflow
+         checks, leading to out-of-bounds access / crash. */
+      loglevel = dat->opts & DWG_OPTS_LOGLEVEL;
+      LOG_ERROR ("%s invalid reset at %lu >= %lu", __FUNCTION__, pos, dat->size)
+      dat->bit = 0;
+      dat->size = 0;
+      return;
+    }
+  // not already overflowed
+  dat->chain += pos;
+  dat->size -= pos;
 }
 
 #ifdef DWG_ABORT
@@ -181,6 +205,15 @@ bit_read_BB (Bit_Chain *dat)
   unsigned char result;
   unsigned char byte;
 
+
+  /* Defensive: avoid NULL dereference when called with an uninitialized
+     or cleared Bit_Chain. */
+  if (!dat || !dat->chain)
+    {
+      loglevel = dat ? (dat->opts & DWG_OPTS_LOGLEVEL) : 0;
+      LOG_ERROR ("%s NULL bit chain", __FUNCTION__)
+      return 0;
+    }
   CHK_OVERFLOW(__FUNCTION__,0)
   byte = dat->chain[dat->byte];
   if (dat->bit < 7)
diff --git a/src/decode_r2007.c b/src/decode_r2007.c
index bafcdab..0e2f9a7 100644
--- a/src/decode_r2007.c
+++ b/src/decode_r2007.c
@@ -1287,6 +1287,24 @@ obj_string_stream (Bit_Chain *restrict dat, Dwg_Object *restrict obj,
   assert (dat != str);
   old_size = str->size;
   old_byte = str->byte;
+  BITCODE_RC *old_chain;
+  unsigned char old_bit;
+
+  /* Defensive: obj_string_stream may be called on malformed input with
+     an invalid string stream state. Avoid pointer arithmetic on a bad
+     chain and restore the previous state on error. */
+  if (!str || !str->chain)
+    {
+      LOG_WARN ("obj_string_stream invalid stream");
+      return DWG_ERR_VALUEOUTOFBOUNDS;
+    }
+  old_chain = str->chain;
+  old_bit = str->bit;
+  if (old_byte > old_size)
+    {
+      LOG_WARN ("obj_string_stream invalid position");
+      return DWG_ERR_VALUEOUTOFBOUNDS;
+    }
 
   str->chain += str->byte;
   // obj->strpos = str->byte * 8 + str->bit;
@@ -1299,6 +1317,10 @@ obj_string_stream (Bit_Chain *restrict dat, Dwg_Object *restrict obj,
   if (str->byte >= old_size - old_byte)
     {
       LOG_WARN ("obj_string_stream overflow");
+      str->chain = old_chain;
+      str->size = old_size;
+      str->byte = old_byte;
+      str->bit = old_bit;
       return DWG_ERR_VALUEOUTOFBOUNDS;
     }
   LOG_HANDLE (" obj string stream +%u: @%lu.%u (%lu)", start, str->byte,