diff --git a/src/isomedia/box_funcs.c b/src/isomedia/box_funcs.c
index 98ff6bb..1944d62 100644
--- a/src/isomedia/box_funcs.c
+++ b/src/isomedia/box_funcs.c
@@ -1994,6 +1994,13 @@ GF_Err gf_isom_box_size(GF_Box *a)
 {
 	GF_Err e;
 	if (!a) return GF_BAD_PARAM;
+	/* Some corrupted files may lead to partially initialized boxes.
+	 * We must not dereference the registry pointer before checking it.
+	 */
+	if (!a->registry) {
+		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[iso file] Size invalid box type %s without registry\n", gf_4cc_to_str(a->type) ));
+		return GF_ISOM_INVALID_FILE;
+	}
 	if (a->registry->disabled) {
 		a->size = 0;
 		return GF_OK;
diff --git a/src/isomedia/isom_read.c b/src/isomedia/isom_read.c
index ba474c3..0951b92 100644
--- a/src/isomedia/isom_read.c
+++ b/src/isomedia/isom_read.c
@@ -5857,13 +5857,32 @@ Bool gf_isom_is_identical_sgpd(void *ptr1, void *ptr2, u32 grouping_type)
 
 	if (!ptr1 || !ptr2)
 		return GF_FALSE;
+	// grouping_type==0 can happen with corrupted files (invalid grouping_type in sgpd).
+	// In that case ptr1/ptr2 are sgpd entries, not boxes. Avoid treating them as boxes.
+	if (!grouping_type)
+		return GF_FALSE;
 
 	bs1 = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
 	if (grouping_type) {
 		sgpd_write_entry(grouping_type, ptr1, bs1);
 	} else {
-		gf_isom_box_size((GF_Box *)ptr1);
-		gf_isom_box_write((GF_Box *)ptr1, bs1);
+		GF_Box *b1 = (GF_Box *) ptr1;
+		GF_Box *b2 = (GF_Box *) ptr2;
+		GF_Err e1, e2;
+		// grouping_type==0 is invalid for sample group descriptions; corrupted files may hit this path
+		// with ptr1/ptr2 not being real boxes (eg SGPD entry payloads).
+		if (!b1 || !b2 || !b1->registry || !b2->registry) {
+			gf_bs_del(bs1);
+			return GF_FALSE;
+		}
+		e1 = gf_isom_box_size(b1);
+		e2 = gf_isom_box_size(b2);
+		if (e1 || e2) {
+			gf_bs_del(bs1);
+			return GF_FALSE;
+		}
+		gf_isom_box_write(b1, bs1);
+		/* bs2 will be created after extracting bs1 content */
 	}
 	gf_bs_get_content(bs1, &buf1, &len1);
 	gf_bs_del(bs1);