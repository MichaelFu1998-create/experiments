diff --git a/src/string.c b/src/string.c
index 0273f74..0795efa 100644
--- a/src/string.c
+++ b/src/string.c
@@ -17,6 +17,7 @@
 #include <mruby/internal.h>
 #include <mruby/presym.h>
 #include <string.h>
+#include <stdlib.h>
 
 typedef struct mrb_shared_string {
   int refcnt;
@@ -1210,15 +1211,28 @@ str_replace_partial(mrb_state *mrb, mrb_value src, mrb_int pos, mrb_int end, mrb
 static mrb_value
 str_escape(mrb_state *mrb, mrb_value str, mrb_bool inspect)
 {
-  const char *p, *pend;
+  /*
+   * SECURITY:
+   * Do not keep raw pointers into +str+ across allocations.
+   * Allocations while building the escaped string can trigger incremental GC
+   * which may sweep +str+ and free its buffer, causing a use-after-free.
+   *
+   * Take a snapshot as a new mruby String and iterate over that snapshot.
+   */
+  int ai = mrb_gc_arena_save(mrb);
+  mrb_value snap = mrb_str_new(mrb, RSTRING_PTR(str), RSTRING_LEN(str));
+  mrb_gc_protect(mrb, snap);
+
+  const char *p = RSTRING_PTR(snap);
+  const char *pend = RSTRING_END(snap);
+
   char buf[4];  /* `\x??` or UTF-8 character */
   mrb_value result = mrb_str_new_lit(mrb, "\"");
 #ifdef MRB_UTF8_STRING
   uint32_t ascii_flag = MRB_STR_ASCII;
 #endif
 
-  p = RSTRING_PTR(str); pend = RSTRING_END(str);
-  for (;p < pend; p++) {
+  for (; p < pend; p++) {
     unsigned char c, cc;
 #ifdef MRB_UTF8_STRING
     if (inspect) {
@@ -1226,24 +1240,24 @@ str_escape(mrb_state *mrb, mrb_value str, mrb_bool inspect)
       if (clen > 1) {
         mrb_int i;
 
-        for (i=0; i<clen; i++) {
+        for (i = 0; i < clen; i++) {
           buf[i] = p[i];
         }
         mrb_str_cat(mrb, result, buf, clen);
-        p += clen-1;
+        p += clen - 1;
         ascii_flag = 0;
         continue;
       }
     }
 #endif
-    c = *p;
-    if (c == '"'|| c == '\\' || (c == '#' && IS_EVSTR(p+1, pend))) {
-      buf[0] = '\\'; buf[1] = c;
+    c = (unsigned char)*p;
+    if (c == '"' || c == '\' || (c == '#' && IS_EVSTR(p+1, pend))) {
+      buf[0] = '\'; buf[1] = (char)c;
       mrb_str_cat(mrb, result, buf, 2);
       continue;
     }
     if (ISPRINT(c)) {
-      buf[0] = c;
+      buf[0] = (char)c;
       mrb_str_cat(mrb, result, buf, 1);
       continue;
     }
@@ -1259,13 +1273,13 @@ str_escape(mrb_state *mrb, mrb_value str, mrb_bool inspect)
       default: cc = 0; break;
     }
     if (cc) {
-      buf[0] = '\\';
+      buf[0] = '\';
       buf[1] = (char)cc;
       mrb_str_cat(mrb, result, buf, 2);
       continue;
     }
     else {
-      buf[0] = '\\';
+      buf[0] = '\';
       buf[1] = 'x';
       buf[3] = mrb_digitmap[c % 16]; c /= 16;
       buf[2] = mrb_digitmap[c % 16];
@@ -1276,7 +1290,7 @@ str_escape(mrb_state *mrb, mrb_value str, mrb_bool inspect)
   mrb_str_cat_lit(mrb, result, "\"");
 #ifdef MRB_UTF8_STRING
   if (inspect) {
-    mrb_str_ptr(str)->flags |= ascii_flag;
+    /* Do not touch +str+ here; it may have been collected during allocations. */
     mrb_str_ptr(result)->flags |= ascii_flag;
   }
   else {
@@ -1284,9 +1298,11 @@ str_escape(mrb_state *mrb, mrb_value str, mrb_bool inspect)
   }
 #endif
 
+  mrb_gc_arena_restore(mrb, ai);
   return result;
 }
 
+
 static void
 mrb_str_aset(mrb_state *mrb, mrb_value str, mrb_value indx, mrb_value alen, mrb_value replace)
 {