diff --git a/src/njs_lvlhsh.c b/src/njs_lvlhsh.c
index 8443a08..8edce89 100644
--- a/src/njs_lvlhsh.c
+++ b/src/njs_lvlhsh.c
@@ -143,6 +143,17 @@
 
 #define NJS_LVLHSH_BUCKET_DONE  ((void *) -1)
 
+/*
+ * Validate decoded pointers before dereferencing them.  This is a
+ * defensive check against corrupted lvlhsh nodes (e.g. after memory
+ * corruption elsewhere) to avoid SEGV in lookup routines.
+ */
+#if (NJS_64BIT)
+#define njs_lvlhsh_ptr_is_valid(p)  (((uintptr_t) (p) >> 48) == 0)
+#else
+#define njs_lvlhsh_ptr_is_valid(p)  (1)
+#endif
+
 
 static njs_int_t njs_lvlhsh_level_find(njs_lvlhsh_query_t *lhq, void **lvl,
     uint32_t key, njs_uint_t nlvl);
@@ -173,7 +184,11 @@ njs_lvlhsh_find(const njs_lvlhsh_t *lh, njs_lvlhsh_query_t *lhq)
 {
     void  *slot;
 
-    slot = lh->slot;
+        if (njs_slow_path(lh == NULL || !njs_lvlhsh_ptr_is_valid(lh))) {
+        return NJS_DECLINED;
+    }
+
+slot = lh->slot;
 
     if (njs_fast_path(slot != NULL)) {
 
@@ -200,6 +215,10 @@ njs_lvlhsh_level_find(njs_lvlhsh_query_t *lhq, void **lvl, uint32_t key,
     mask = ((uintptr_t) 1 << shift) - 1;
 
     lvl = njs_lvlhsh_level(lvl, mask);
+
+    if (njs_slow_path(!njs_lvlhsh_ptr_is_valid(lvl))) {
+        return NJS_DECLINED;
+    }
     slot = lvl[key & mask];
 
     if (slot != NULL) {
@@ -219,15 +238,47 @@ static njs_int_t
 njs_lvlhsh_bucket_find(njs_lvlhsh_query_t *lhq, void **bkt)
 {
     void        *value;
-    uint32_t    *bucket, *e;
+    uint32_t    *bucket, *e, *end;
     njs_uint_t  n;
+    njs_uint_t  max;
+
+    /*
+     * A bucket pointer has a packed format: low bits contain a bucket flag
+     * and number of valid entries in the bucket.
+     *
+     * If an invalid/corrupted bucket pointer reaches this function, the first
+     * entry access may segfault.  These checks are cheap and are intended to
+     * prevent out-of-bounds/unmapped reads.
+     */
+    max = lhq->proto->bucket_end / NJS_LVLHSH_ENTRY_SIZE;
 
     do {
+        if (njs_slow_path(bkt == NJS_LVLHSH_BUCKET_DONE
+                          || !njs_lvlhsh_is_bucket(bkt)))
+        {
+            return NJS_DECLINED;
+        }
+
         bucket = njs_lvlhsh_bucket(lhq->proto, bkt);
+
+        if (njs_slow_path(!njs_lvlhsh_ptr_is_valid(bucket))) {
+            return NJS_DECLINED;
+        }
         n = njs_lvlhsh_bucket_entries(lhq->proto, bkt);
+
+        if (njs_slow_path(n == 0 || n > max)) {
+            return NJS_DECLINED;
+        }
+
         e = bucket;
+        end = njs_lvlhsh_bucket_end(lhq->proto, bucket);
 
         do {
+            if (njs_slow_path(e >= end)) {
+                /* Corrupted entry counter, stop before reading past bucket. */
+                return NJS_DECLINED;
+            }
+
             if (njs_lvlhsh_valid_entry(e)) {
                 n--;
 
diff --git a/src/njs_object_prop.c b/src/njs_object_prop.c
index dc1aa21..bd87920 100644
--- a/src/njs_object_prop.c
+++ b/src/njs_object_prop.c
@@ -7,6 +7,16 @@
 
 #include <njs_main.h>
 
+/*
+ * Defensive pointer validation: avoid dereferencing corrupted object pointers
+ * during prototype-chain property lookups.
+ */
+#if (NJS_64BIT)
+#define njs_object_ptr_is_valid(p)  (((uintptr_t) (p) >> 48) == 0)
+#else
+#define njs_object_ptr_is_valid(p)  (1)
+#endif
+
 
 static njs_int_t njs_descriptor_prop(njs_vm_t *vm,
     njs_object_prop_t *prop, const njs_value_t *desc);
@@ -56,6 +66,10 @@ njs_object_property(njs_vm_t *vm, const njs_value_t *value,
     object = njs_object(value);
 
     do {
+        if (njs_slow_path(!njs_object_ptr_is_valid(object))) {
+            njs_set_undefined(retval);
+            return NJS_DECLINED;
+        }
         ret = njs_lvlhsh_find(&object->hash, lhq);
 
         if (njs_fast_path(ret == NJS_OK)) {