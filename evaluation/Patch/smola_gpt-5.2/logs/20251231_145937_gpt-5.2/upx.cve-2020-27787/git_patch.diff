diff --git a/src/p_lx_elf.cpp b/src/p_lx_elf.cpp
index 96f5838..c813cc0 100644
--- a/src/p_lx_elf.cpp
+++ b/src/p_lx_elf.cpp
@@ -1573,8 +1573,33 @@ PackLinuxElf32::invert_pt_dynamic(Elf32_Dyn const *dynp)
     }
     Elf32_Dyn const *const dynp0 = dynp;
     unsigned ndx = 1+ 0;
-    if (dynp)
-    for (; ; ++ndx, ++dynp) {
+    if (!dynp)
+        return;
+    // Bound parsing of the PT_DYNAMIC segment to the recorded segment size.
+    // Without this, a crafted file with a missing DT_NULL can cause
+    // out-of-bounds reads and later invalid pointer arithmetic.
+    unsigned const max_bytes = sz_dynseg;
+    if (max_bytes < sizeof(Elf32_Dyn)) {
+        throwCantPack("bad PT_DYNAMIC");
+    }
+    // Defensive: ensure dynp actually points inside a known buffer (file_image or ibuf).
+    unsigned char const *dp = (unsigned char const *)(void const *)dynp0;
+    unsigned char const *base = 0;
+    unsigned bufsz = 0;
+    if (ibuf.getSize() && dp >= (unsigned char const *)(unsigned char *)ibuf
+    &&  dp <  (unsigned char const *)(unsigned char *)ibuf + ibuf.getSize()) {
+        base = (unsigned char const *)(unsigned char *)ibuf; bufsz = ibuf.getSize();
+    }
+    else if (file_image.getSize() && dp >= (unsigned char const *)(unsigned char *)file_image
+    &&       dp <  (unsigned char const *)(unsigned char *)file_image + file_image.getSize()) {
+        base = (unsigned char const *)(unsigned char *)file_image; bufsz = file_image.getSize();
+    }
+    if (!base || max_bytes > bufsz || (unsigned)(dp - base) > bufsz - max_bytes) {
+        if (opt && opt->cmd != CMD_COMPRESS)
+            throwCantUnpack("bad PT_DYNAMIC");
+        throwCantPack("bad PT_DYNAMIC");
+    }
+    for (; (unsigned)((char const *)dynp - (char const *)dynp0) + sizeof(*dynp) <= max_bytes; ++ndx, ++dynp) {
         unsigned const d_tag = get_te32(&dynp->d_tag);
         if (d_tag < DT_NUM) {
             if (Elf32_Dyn::DT_NEEDED != d_tag
@@ -1592,6 +1617,9 @@ PackLinuxElf32::invert_pt_dynamic(Elf32_Dyn const *dynp)
             break;  // check here so that dt_table[DT_NULL] is set
         }
     }
+    if (!dt_table[Elf32_Dyn::DT_NULL]) {
+        throwCantPack("bad PT_DYNAMIC: missing DT_NULL");
+    }
     upx_dt_init = 0;
          if (dt_table[Elf32_Dyn::DT_INIT])          upx_dt_init = Elf32_Dyn::DT_INIT;
     else if (dt_table[Elf32_Dyn::DT_PREINIT_ARRAY]) upx_dt_init = Elf32_Dyn::DT_PREINIT_ARRAY;
@@ -4478,6 +4506,11 @@ void PackLinuxElf64::unpack(OutputFile *fo)
     // Packed ET_DYN has original PT_DYNAMIC for info needed by rtld.
     Elf64_Phdr const *const dynhdr = elf_find_ptype(Elf64_Phdr::PT_DYNAMIC, phdri, c_phnum);
     bool const is_shlib = !!dynhdr;
+    if (is_shlib && Elf64_Ehdr::ET_DYN != get_te16(&ehdri.e_type)) {
+        // Packed ET_EXE should not contain PT_DYNAMIC. Reject crafted inputs
+        // that would otherwise send us down the shared-library restore path.
+        throwCantUnpack("bad PT_DYNAMIC");
+    }
     if (is_shlib) {
         // Unpack and output the Ehdr and Phdrs for real.
         // This depends on position within input file fi.
@@ -4486,7 +4519,11 @@ void PackLinuxElf64::unpack(OutputFile *fo)
 
         // The first PT_LOAD.  Part is not compressed (for benefit of rtld.)
         fi->seek(0, SEEK_SET);
-        fi->readx(ibuf, get_te64(&dynhdr->p_offset) + get_te64(&dynhdr->p_filesz));
+        upx_uint64_t const first_len = get_te64(&dynhdr->p_offset) + get_te64(&dynhdr->p_filesz);
+        if (first_len > (upx_uint64_t)ibuf.getSize()) {
+            throwCantUnpack("bad PT_DYNAMIC");
+        }
+        fi->readx(ibuf, first_len);
         overlay_offset -= sizeof(linfo);
         xct_off = overlay_offset;
         e_shoff = get_te64(&ehdri.e_shoff);
@@ -4501,6 +4538,11 @@ void PackLinuxElf64::unpack(OutputFile *fo)
             // un-Relocate dynsym (DT_SYMTAB) which is below xct_off
             dynseg = (Elf64_Dyn const *)ibuf.subref(
                 "bad DYNAMIC", get_te64(&dynhdr->p_offset), get_te64(&dynhdr->p_filesz));
+            sz_dynseg = get_te64(&dynhdr->p_filesz);
+            if (sz_dynseg < sizeof(Elf64_Dyn)
+            ||  (sz_dynseg % sizeof(Elf64_Dyn)) != 0) {
+                throwCantUnpack("bad PT_DYNAMIC");
+            }
             dynstr = (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB);
             sec_dynsym = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM);
             if (sec_dynsym) {
@@ -4537,6 +4579,10 @@ void PackLinuxElf64::unpack(OutputFile *fo)
             }
         }
 
+        if (old_data_len == 0) {
+            throwCantUnpack("bad PT_LOAD");
+        }
+
         total_in  = xct_off;
         total_out = xct_off;
         ph.u_len = 0;
@@ -4644,6 +4690,9 @@ void PackLinuxElf64::unpack(OutputFile *fo)
                 load_off = get_te64(&phdr->p_offset);
                 load_va = get_te64(&phdr->p_vaddr);
                 fi->seek(old_data_off, SEEK_SET);
+                if (old_data_len > (upx_uint64_t)ibuf.getSize()) {
+                    throwCantUnpack("bad PT_LOAD");
+                }
                 fi->readx(ibuf, old_data_len);
                 total_in  += old_data_len;
                 total_out += old_data_len;
@@ -4658,8 +4707,22 @@ void PackLinuxElf64::unpack(OutputFile *fo)
                     if (dyn_off < load_off) {
                         continue;  // Oops.  Not really is_shlib ?  [built by 'rust' ?]
                     }
-                    Elf64_Dyn *dyn = (Elf64_Dyn *)((unsigned char *)ibuf +
-                        (dyn_off - load_off));
+                    // dyn_off/dyn_len refer to the PT_DYNAMIC region inside the currently loaded PT_LOAD.
+                    // Validate that it lies within ibuf (old_data_len bytes) before dereferencing.
+                    upx_uint64_t const dyn_disp = dyn_off - load_off;
+                    if (dyn_disp > (upx_uint64_t)old_data_len
+                    ||  dyn_len  > (upx_uint64_t)old_data_len - dyn_disp
+                    ||  dyn_len  < sizeof(Elf64_Dyn)
+                    ||  (dyn_len % sizeof(Elf64_Dyn)) != 0) {
+                        throwCantUnpack("bad PT_DYNAMIC");
+                    }
+                    sz_dynseg = dyn_len;
+                    if (dyn_disp > 0xffffffffu || dyn_len > 0xffffffffu) {
+                        throwCantUnpack("bad PT_DYNAMIC");
+                    }
+                    unsigned char *const dyn_bytes = ibuf.subref(
+                        "bad PT_DYNAMIC", (unsigned)dyn_disp, (unsigned)dyn_len);
+                    Elf64_Dyn *dyn = (Elf64_Dyn *)(void *)dyn_bytes;
                     dynseg = dyn; invert_pt_dynamic(dynseg);
                     for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {
                         upx_uint64_t const tag = get_te64(&dyn->d_tag);
@@ -4943,12 +5006,17 @@ PackLinuxElf32::check_pt_dynamic(Elf32_Phdr const *const phdr)
     unsigned vaddr = get_te32(&phdr->p_vaddr);
     unsigned filesz = get_te32(&phdr->p_filesz), memsz = get_te32(&phdr->p_memsz);
     unsigned align = get_te32(&phdr->p_align);
+    unsigned const fend = t + filesz;
+    unsigned const mend = t + memsz;
     if (s < t || (u32_t)file_size < s
     ||  (3 & t) || (7 & (filesz | memsz))  // .balign 4; 8==sizeof(Elf32_Dyn)
     ||  (-1+ align) & (t ^ vaddr)
     ||  filesz < sizeof(Elf32_Dyn)
     ||  memsz  < sizeof(Elf32_Dyn)
-    ||  filesz < memsz) {
+    ||  filesz < memsz
+    ||  fend < t || mend < t
+    ||  (u32_t)file_size < (u32_t)fend
+    ||  (u32_t)file_size < (u32_t)mend) {
         char msg[50]; snprintf(msg, sizeof(msg), "bad PT_DYNAMIC phdr[%u]",
             (unsigned)(phdr - phdri));
         throwCantPack(msg);
@@ -5044,12 +5112,17 @@ PackLinuxElf64::check_pt_dynamic(Elf64_Phdr const *const phdr)
     upx_uint64_t vaddr = get_te64(&phdr->p_vaddr);
     upx_uint64_t filesz = get_te64(&phdr->p_filesz), memsz = get_te64(&phdr->p_memsz);
     upx_uint64_t align = get_te64(&phdr->p_align);
+    upx_uint64_t const fend = t + filesz;
+    upx_uint64_t const mend = t + memsz;
     if (s < t || (upx_uint64_t)file_size < s
     ||  (7 & t) || (0xf & (filesz | memsz))  // .balign 8; 16==sizeof(Elf64_Dyn)
     ||  (-1+ align) & (t ^ vaddr)
     ||  filesz < sizeof(Elf64_Dyn)
     ||  memsz  < sizeof(Elf64_Dyn)
-    ||  filesz < memsz) {
+    ||  filesz < memsz
+    ||  fend < t || mend < t
+    ||  (upx_uint64_t)file_size < fend
+    ||  (upx_uint64_t)file_size < mend) {
         char msg[50]; snprintf(msg, sizeof(msg), "bad PT_DYNAMIC phdr[%u]",
             (unsigned)(phdr - phdri));
         throwCantPack(msg);
@@ -5066,8 +5139,33 @@ PackLinuxElf64::invert_pt_dynamic(Elf64_Dyn const *dynp)
     }
     Elf64_Dyn const *const dynp0 = dynp;
     unsigned ndx = 1+ 0;
-    if (dynp)
-    for (; ; ++ndx, ++dynp) {
+    if (!dynp)
+        return;
+    // Bound parsing of the PT_DYNAMIC segment to the recorded segment size.
+    // Without this, a crafted file with a missing DT_NULL can cause
+    // out-of-bounds reads and later invalid pointer arithmetic.
+    upx_uint64_t const max_bytes = sz_dynseg;
+    if (max_bytes < sizeof(Elf64_Dyn)) {
+        throwCantPack("bad PT_DYNAMIC");
+    }
+    // Defensive: ensure dynp actually points inside a known buffer (file_image or ibuf).
+    unsigned char const *dp = (unsigned char const *)(void const *)dynp0;
+    unsigned char const *base = 0;
+    upx_uint64_t bufsz = 0;
+    if (ibuf.getSize() && dp >= (unsigned char const *)(unsigned char *)ibuf
+    &&  dp <  (unsigned char const *)(unsigned char *)ibuf + ibuf.getSize()) {
+        base = (unsigned char const *)(unsigned char *)ibuf; bufsz = ibuf.getSize();
+    }
+    else if (file_image.getSize() && dp >= (unsigned char const *)(unsigned char *)file_image
+    &&       dp <  (unsigned char const *)(unsigned char *)file_image + file_image.getSize()) {
+        base = (unsigned char const *)(unsigned char *)file_image; bufsz = file_image.getSize();
+    }
+    if (!base || max_bytes > bufsz || (upx_uint64_t)(dp - base) > bufsz - max_bytes) {
+        if (opt && opt->cmd != CMD_COMPRESS)
+            throwCantUnpack("bad PT_DYNAMIC");
+        throwCantPack("bad PT_DYNAMIC");
+    }
+    for (; (upx_uint64_t)((char const *)dynp - (char const *)dynp0) + sizeof(*dynp) <= max_bytes; ++ndx, ++dynp) {
         upx_uint64_t const d_tag = get_te64(&dynp->d_tag);
         if (d_tag>>32) { // outrageous
             char msg[50]; snprintf(msg, sizeof(msg),
@@ -5090,6 +5188,9 @@ PackLinuxElf64::invert_pt_dynamic(Elf64_Dyn const *dynp)
             break;  // check here so that dt_table[DT_NULL] is set
         }
     }
+    if (!dt_table[Elf64_Dyn::DT_NULL]) {
+        throwCantPack("bad PT_DYNAMIC: missing DT_NULL");
+    }
     upx_dt_init = 0;
          if (dt_table[Elf64_Dyn::DT_INIT])          upx_dt_init = Elf64_Dyn::DT_INIT;
     else if (dt_table[Elf64_Dyn::DT_PREINIT_ARRAY]) upx_dt_init = Elf64_Dyn::DT_PREINIT_ARRAY;
@@ -5439,7 +5540,11 @@ void PackLinuxElf32::unpack(OutputFile *fo)
 
         // The first PT_LOAD.  Part is not compressed (for benefit of rtld.)
         fi->seek(0, SEEK_SET);
-        fi->readx(ibuf, get_te32(&dynhdr->p_offset) + get_te32(&dynhdr->p_filesz));
+        unsigned const first_len = get_te32(&dynhdr->p_offset) + get_te32(&dynhdr->p_filesz);
+        if (first_len > ibuf.getSize()) {
+            throwCantUnpack("bad PT_DYNAMIC");
+        }
+        fi->readx(ibuf, first_len);
         overlay_offset -= sizeof(linfo);
         xct_off = overlay_offset;
         e_shoff = get_te32(&ehdri.e_shoff);
@@ -5454,6 +5559,11 @@ void PackLinuxElf32::unpack(OutputFile *fo)
             // un-Relocate dynsym (DT_SYMTAB) which is below xct_off
             dynseg = (Elf32_Dyn const *)ibuf.subref(
                 "bad DYNAMIC", get_te32(&dynhdr->p_offset), get_te32(&dynhdr->p_filesz));
+            sz_dynseg = get_te32(&dynhdr->p_filesz);
+            if (sz_dynseg < sizeof(Elf32_Dyn)
+            ||  (sz_dynseg % sizeof(Elf32_Dyn)) != 0) {
+                throwCantUnpack("bad PT_DYNAMIC");
+            }
             dynstr = (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);
             sec_dynsym = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);
             if (sec_dynsym) {
@@ -5490,6 +5600,10 @@ void PackLinuxElf32::unpack(OutputFile *fo)
             }
         }
 
+        if (old_data_len == 0) {
+            throwCantUnpack("bad PT_LOAD");
+        }
+
         total_in  = xct_off;
         total_out = xct_off;
         ph.u_len = 0;
@@ -5597,6 +5711,9 @@ void PackLinuxElf32::unpack(OutputFile *fo)
                 load_off = get_te32(&phdr->p_offset);
                 load_va  = get_te32(&phdr->p_vaddr);
                 fi->seek(old_data_off, SEEK_SET);
+                if (old_data_len > ibuf.getSize()) {
+                    throwCantUnpack("bad PT_LOAD");
+                }
                 fi->readx(ibuf, old_data_len);
                 total_in  += old_data_len;
                 total_out += old_data_len;
@@ -5611,8 +5728,19 @@ void PackLinuxElf32::unpack(OutputFile *fo)
                     if (dyn_off < load_off) {
                         continue;  // Oops.  Not really is_shlib ?  [built by 'rust' ?]
                     }
-                    Elf32_Dyn *dyn = (Elf32_Dyn *)((unsigned char *)ibuf +
-                        (dyn_off - load_off));
+                    // dyn_off/dyn_len refer to the PT_DYNAMIC region inside the currently loaded PT_LOAD.
+                    // Validate that it lies within ibuf (old_data_len bytes) before dereferencing.
+                    unsigned const dyn_disp = dyn_off - load_off;
+                    if (dyn_disp > old_data_len
+                    ||  dyn_len  > old_data_len - dyn_disp
+                    ||  dyn_len  < sizeof(Elf32_Dyn)
+                    ||  (dyn_len % sizeof(Elf32_Dyn)) != 0) {
+                        throwCantUnpack("bad PT_DYNAMIC");
+                    }
+                    sz_dynseg = dyn_len;
+                    unsigned char *const dyn_bytes = ibuf.subref(
+                        "bad PT_DYNAMIC", dyn_disp, dyn_len);
+                    Elf32_Dyn *dyn = (Elf32_Dyn *)(void *)dyn_bytes;
                     dynseg = dyn; invert_pt_dynamic(dynseg);
                     for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {
                         unsigned const tag = get_te32(&dyn->d_tag);