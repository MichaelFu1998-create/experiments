diff --git a/src/mat5.c b/src/mat5.c
index 2841b58..df67cb7 100644
--- a/src/mat5.c
+++ b/src/mat5.c
@@ -97,6 +97,170 @@ static size_t Mat_WriteCompressedEmptyVariable5(mat_t *mat,const char *name,
                   int rank,size_t *dims,z_streamp z);
 #endif
 
+
+#if defined(HAVE_ZLIB)
+/*
+ * Safely read (inflate) the dimensions tag and dimension values for a
+ * compressed MAT5 variable.
+ *
+ * The generic InflateDimensions() routine requires a caller-provided buffer
+ * large enough to hold (8 + 4*rank) bytes. Several callers historically passed
+ * a fixed-size stack buffer which can overflow on malformed files with a very
+ * large rank.
+ *
+ * This helper inflates the dimensions into a temporary heap buffer and stores
+ * the rank and dimensions directly into @c out.
+ *
+ * If @c uncompressed_bytes is non-NULL, it is set to the number of uncompressed
+ * bytes consumed (dimensions tag + padded dimensions payload).
+ */
+static size_t
+InflateReadRankDims5(mat_t *mat, matvar_t *matvar, matvar_t *out,
+                     int *uncompressed_bytes)
+{
+    mat_uint8_t comp_buf[32];
+    mat_int32_t tag[2];
+    int err;
+    size_t bytesread = 0;
+    int rank, payload_bytes, padded_payload, i;
+    mat_uint32_t *dims_u32 = NULL;
+
+    if ( uncompressed_bytes )
+        *uncompressed_bytes = 0;
+
+    if ( mat == NULL || matvar == NULL || out == NULL ||
+         matvar->internal == NULL || matvar->internal->z == NULL )
+        return 0;
+
+    /* Inflate the dimensions tag (8 bytes) */
+    if ( !matvar->internal->z->avail_in ) {
+        matvar->internal->z->avail_in = 1;
+        matvar->internal->z->next_in  = comp_buf;
+        bytesread += fread(comp_buf,1,1,(FILE*)mat->fp);
+    }
+    matvar->internal->z->avail_out = 8;
+    matvar->internal->z->next_out  = (Bytef*)tag;
+    err = inflate(matvar->internal->z,Z_NO_FLUSH);
+    if ( err != Z_OK ) {
+        Mat_Critical("InflateReadRankDims5: inflate returned %s",
+                     zError(err == Z_NEED_DICT ? Z_DATA_ERROR : err));
+        return bytesread;
+    }
+    while ( matvar->internal->z->avail_out && !matvar->internal->z->avail_in ) {
+        matvar->internal->z->avail_in = 1;
+        matvar->internal->z->next_in  = comp_buf;
+        bytesread += fread(comp_buf,1,1,(FILE*)mat->fp);
+        err = inflate(matvar->internal->z,Z_NO_FLUSH);
+        if ( err != Z_OK ) {
+            Mat_Critical("InflateReadRankDims5: inflate returned %s",
+                         zError(err == Z_NEED_DICT ? Z_DATA_ERROR : err));
+            return bytesread;
+        }
+    }
+
+    if ( mat->byteswap ) {
+        Mat_int32Swap(tag);
+        Mat_int32Swap(tag+1);
+    }
+    if ( (tag[0] & 0x0000ffff) != MAT_T_INT32 ) {
+        Mat_Critical("InflateReadRankDims5: Reading dimensions expected type MAT_T_INT32");
+        return bytesread;
+    }
+
+    payload_bytes = tag[1];
+    if ( payload_bytes < 0 || (payload_bytes % 4) != 0 ) {
+        Mat_Critical("InflateReadRankDims5: Invalid dimensions size %d", payload_bytes);
+        return bytesread;
+    }
+    rank = payload_bytes / 4;
+
+    /* Sanity limit to avoid pathological allocations/CPU on malformed files */
+    if ( rank > 1024 ) {
+        Mat_Critical("InflateReadRankDims5: Unsupported rank %d", rank);
+        padded_payload = payload_bytes;
+        if ( padded_payload % 8 != 0 )
+            padded_payload += 8 - (padded_payload % 8);
+        bytesread += InflateSkip(mat, matvar->internal->z, padded_payload);
+        if ( uncompressed_bytes )
+            *uncompressed_bytes = 8 + padded_payload;
+        return bytesread;
+    }
+
+    padded_payload = payload_bytes;
+    if ( padded_payload % 8 != 0 )
+        padded_payload += 8 - (padded_payload % 8);
+
+    if ( uncompressed_bytes )
+        *uncompressed_bytes = 8 + padded_payload;
+
+    /* Free any pre-existing dimensions in out */
+    if ( out->dims != NULL ) {
+        free(out->dims);
+        out->dims = NULL;
+    }
+    out->rank = 0;
+
+    if ( padded_payload > 0 ) {
+        dims_u32 = (mat_uint32_t*)malloc((size_t)padded_payload);
+        if ( dims_u32 == NULL ) {
+            Mat_Critical("InflateReadRankDims5: Couldn't allocate memory for dimensions");
+            bytesread += InflateSkip(mat, matvar->internal->z, padded_payload);
+            return bytesread;
+        }
+
+        if ( !matvar->internal->z->avail_in ) {
+            matvar->internal->z->avail_in = 1;
+            matvar->internal->z->next_in  = comp_buf;
+            bytesread += fread(comp_buf,1,1,(FILE*)mat->fp);
+        }
+        matvar->internal->z->avail_out = padded_payload;
+        matvar->internal->z->next_out  = (Bytef*)dims_u32;
+        err = inflate(matvar->internal->z,Z_NO_FLUSH);
+        if ( err != Z_OK ) {
+            Mat_Critical("InflateReadRankDims5: inflate returned %s",
+                         zError(err == Z_NEED_DICT ? Z_DATA_ERROR : err));
+            free(dims_u32);
+            return bytesread;
+        }
+        while ( matvar->internal->z->avail_out && !matvar->internal->z->avail_in ) {
+            matvar->internal->z->avail_in = 1;
+            matvar->internal->z->next_in  = comp_buf;
+            bytesread += fread(comp_buf,1,1,(FILE*)mat->fp);
+            err = inflate(matvar->internal->z,Z_NO_FLUSH);
+            if ( err != Z_OK ) {
+                Mat_Critical("InflateReadRankDims5: inflate returned %s",
+                             zError(err == Z_NEED_DICT ? Z_DATA_ERROR : err));
+                free(dims_u32);
+                return bytesread;
+            }
+        }
+
+        out->dims = (size_t*)malloc((size_t)rank*sizeof(*out->dims));
+        if ( out->dims == NULL ) {
+            Mat_Critical("InflateReadRankDims5: Error allocating memory for dims");
+            free(dims_u32);
+            return bytesread;
+        }
+        out->rank = rank;
+        for ( i = 0; i < rank; i++ ) {
+            mat_uint32_t dim = dims_u32[i];
+            if ( mat->byteswap )
+                dim = Mat_uint32Swap(&dim);
+            out->dims[i] = dim;
+        }
+        free(dims_u32);
+    }
+
+    if ( matvar->internal->z->avail_in ) {
+        (void)fseek((FILE*)mat->fp,-(int)matvar->internal->z->avail_in,SEEK_CUR);
+        bytesread -= matvar->internal->z->avail_in;
+        matvar->internal->z->avail_in = 0;
+    }
+
+    return bytesread;
+}
+#endif
+
 /** @brief determines the number of bytes for a given class type
  *
  * @ingroup mat_internal
@@ -1271,29 +1435,10 @@ ReadNextCell( mat_t *mat, matvar_t *matvar )
                 bytesread+=InflateSkip(mat,matvar->internal->z,nbytes);
             }
             if ( cells[i]->class_type != MAT_C_OPAQUE ) {
-                bytesread += InflateDimensions(mat,matvar,uncomp_buf);
-                nbytes -= 8;
-                if ( mat->byteswap ) {
-                    (void)Mat_uint32Swap(uncomp_buf);
-                    (void)Mat_uint32Swap(uncomp_buf+1);
-                }
-                /* Rank and Dimension */
-                if ( uncomp_buf[0] == MAT_T_INT32 ) {
-                    int j = 0;
-
-                    cells[i]->rank = uncomp_buf[1];
-                    nbytes -= cells[i]->rank;
-                    cells[i]->rank /= 4;
-                    cells[i]->dims = (size_t*)malloc(cells[i]->rank*sizeof(*cells[i]->dims));
-                    if ( mat->byteswap ) {
-                        for ( j = 0; j < cells[i]->rank; j++ )
-                            cells[i]->dims[j] = Mat_uint32Swap(uncomp_buf+2+j);
-                    } else {
-                        for ( j = 0; j < cells[i]->rank; j++ )
-                            cells[i]->dims[j] = uncomp_buf[2+j];
-                    }
-                    if ( cells[i]->rank % 2 != 0 )
-                        nbytes -= 4;
+                {
+                    int dim_ub = 0;
+                    bytesread += InflateReadRankDims5(mat,matvar,cells[i],&dim_ub);
+                    nbytes -= dim_ub;
                 }
                 bytesread += InflateVarNameTag(mat,matvar,uncomp_buf);
                 nbytes -= 8;
@@ -1607,29 +1752,10 @@ ReadNextStructField( mat_t *mat, matvar_t *matvar )
                 bytesread+=InflateSkip(mat,matvar->internal->z,nbytes);
             }
             if ( fields[i]->class_type != MAT_C_OPAQUE ) {
-                bytesread += InflateDimensions(mat,matvar,uncomp_buf);
-                nbytes -= 8;
-                if ( mat->byteswap ) {
-                    (void)Mat_uint32Swap(uncomp_buf);
-                    (void)Mat_uint32Swap(uncomp_buf+1);
-                }
-                /* Rank and dimension */
-                if ( uncomp_buf[0] == MAT_T_INT32 ) {
-                    j = 0;
-                    fields[i]->rank = uncomp_buf[1];
-                    nbytes -= fields[i]->rank;
-                    fields[i]->rank /= 4;
-                    fields[i]->dims = (size_t*)malloc(fields[i]->rank*
-                                             sizeof(*fields[i]->dims));
-                    if ( mat->byteswap ) {
-                        for ( j = 0; j < fields[i]->rank; j++ )
-                            fields[i]->dims[j] = Mat_uint32Swap(uncomp_buf+2+j);
-                    } else {
-                        for ( j = 0; j < fields[i]->rank; j++ )
-                            fields[i]->dims[j] = uncomp_buf[2+j];
-                    }
-                    if ( fields[i]->rank % 2 != 0 )
-                        nbytes -= 4;
+                {
+                    int dim_ub = 0;
+                    bytesread += InflateReadRankDims5(mat,matvar,fields[i],&dim_ub);
+                    nbytes -= dim_ub;
                 }
                 bytesread += InflateVarNameTag(mat,matvar,uncomp_buf);
                 nbytes -= 8;
@@ -5638,26 +5764,8 @@ Mat_VarReadNextInfo5( mat_t *mat )
                 }
             }
             if ( matvar->class_type != MAT_C_OPAQUE ) {
-                /* Inflate dimensions */
-                bytesread += InflateDimensions(mat,matvar,uncomp_buf);
-                if ( mat->byteswap ) {
-                    (void)Mat_uint32Swap(uncomp_buf);
-                    (void)Mat_uint32Swap(uncomp_buf+1);
-                }
-                /* Rank and dimension */
-                if ( uncomp_buf[0] == MAT_T_INT32 ) {
-                    int i;
-                    nbytes = uncomp_buf[1];
-                    matvar->rank = nbytes / 4;
-                    matvar->dims = (size_t*)malloc(matvar->rank*sizeof(*matvar->dims));
-                    if ( mat->byteswap ) {
-                        for ( i = 0; i < matvar->rank; i++ )
-                            matvar->dims[i] = Mat_uint32Swap(&(uncomp_buf[2+i]));
-                    } else {
-                        for ( i = 0; i < matvar->rank; i++ )
-                            matvar->dims[i] = uncomp_buf[2+i];
-                    }
-                }
+                /* Inflate dimensions safely */
+                bytesread += InflateReadRankDims5(mat,matvar,matvar,NULL);
                 /* Inflate variable name tag */
                 bytesread += InflateVarNameTag(mat,matvar,uncomp_buf);
                 if ( mat->byteswap )