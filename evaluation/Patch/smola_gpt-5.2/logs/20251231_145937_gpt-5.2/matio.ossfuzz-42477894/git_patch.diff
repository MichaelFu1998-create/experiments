diff --git a/src/inflate.c b/src/inflate.c
index 33e2577..cccf61e 100644
--- a/src/inflate.c
+++ b/src/inflate.c
@@ -389,6 +389,11 @@ InflateRankDims(mat_t *mat, matvar_t *matvar, void *buf, size_t nbytes, mat_uint
         return bytesread;
     }
     rank = tag[1];
+    if ( rank < 0 ) {
+        *((mat_int32_t *)buf+1) = 0;
+        Mat_Critical("InflateRankDims: Invalid dimensions size");
+        return bytesread;
+    }
     if ( rank % 8 != 0 )
         i = 8-(rank %8);
     else
@@ -402,11 +407,17 @@ InflateRankDims(mat_t *mat, matvar_t *matvar, void *buf, size_t nbytes, mat_uint
     }
 
     matvar->internal->z->avail_out = rank;
-    if ( sizeof(mat_uint32_t)*(rank + 2) <= nbytes ) {
-        matvar->internal->z->next_out = ZLIB_BYTE_PTR((mat_int32_t *)buf+2);
+    if ( 8 + (size_t)rank <= nbytes ) {
+        matvar->internal->z->next_out = ZLIB_BYTE_PTR((mat_uint8_t*)buf + 8);
     } else {
         /* Cannot use too small buf, but can allocate output buffer dims */
-        *dims = (mat_uint32_t*)calloc(rank, sizeof(mat_uint32_t));
+        size_t ndims_bytes = (size_t)rank;
+        if ( ndims_bytes % sizeof(mat_uint32_t) != 0 ) {
+            *((mat_int32_t *)buf+1) = 0;
+            Mat_Critical("InflateRankDims: dimensions size is not a multiple of 4");
+            return bytesread;
+        }
+        *dims = (mat_uint32_t*)calloc(ndims_bytes/sizeof(mat_uint32_t), sizeof(mat_uint32_t));
         if ( NULL != *dims ) {
             matvar->internal->z->next_out = ZLIB_BYTE_PTR(*dims);
         } else {
diff --git a/src/mat5.c b/src/mat5.c
index 02a4ebf..dd3f5a2 100644
--- a/src/mat5.c
+++ b/src/mat5.c
@@ -992,6 +992,12 @@ ReadNextCell( mat_t *mat, matvar_t *matvar )
                     cells[i]->rank = uncomp_buf[1];
                     nbytes -= cells[i]->rank;
                     cells[i]->rank /= 4;
+                    if ( !do_clean && cells[i]->rank > (int)(sizeof(uncomp_buf)/sizeof(uncomp_buf[0]) - 2) ) {
+                        Mat_VarFree(cells[i]);
+                        cells[i] = NULL;
+                        Mat_Critical("Invalid rank/dimensions (too large for internal buffer)");
+                        break;
+                    }
                     cells[i]->dims = (size_t*)malloc(cells[i]->rank*sizeof(*cells[i]->dims));
                     if ( mat->byteswap ) {
                         for ( j = 0; j < cells[i]->rank; j++ )
@@ -4887,6 +4893,15 @@ Mat_VarReadNextInfo5( mat_t *mat )
                     size_t size;
                     nbytes = uncomp_buf[1];
                     matvar->rank = nbytes / 4;
+                    if ( !do_clean && matvar->rank > (int)(sizeof(uncomp_buf)/sizeof(uncomp_buf[0]) - 2) ) {
+                        if ( do_clean )
+                            free(dims);
+                        (void)fseek((FILE*)mat->fp,nBytes-bytesread,SEEK_CUR);
+                        Mat_VarFree(matvar);
+                        matvar = NULL;
+                        Mat_Critical("Invalid rank/dimensions (too large for internal buffer)");
+                        break;
+                    }
                     err = SafeMul(&size, matvar->rank, sizeof(*matvar->dims));
                     if ( err ) {
                         if ( do_clean )