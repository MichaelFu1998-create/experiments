diff --git a/programs/escape.c b/programs/escape.c
index 8a90741..c99e270 100644
--- a/programs/escape.c
+++ b/programs/escape.c
@@ -28,43 +28,87 @@ htmlescape (const char *restrict src, const int cp)
 {
   int len;
   char *dest, *d;
-  unsigned char *s;
+  const unsigned char *s;
+
   if (!src)
     return NULL;
-  len = strlen (src) + 10;
-  d = malloc (len);
-  s = (unsigned char *)src;
-  dest = d;
-  while (*s++)
+  (void)cp;
+
+  /* Reserve a little extra; string may grow due to escaping.
+     Must also ensure the output is always NUL-terminated. */
+  len = (int)strlen (src) + 16;
+  dest = malloc (len);
+  if (!dest)
+    return NULL;
+
+  d = dest;
+  *d = 0;
+  s = (const unsigned char *)src;
+
+  while (*s)
     {
-      const int off = d - dest;
-      if (off >= len - 8)
+      const unsigned char c = *s++;
+      const int off = (int)(d - dest);
+      int need;
+
+      switch (c)
         {
-          len += 10;
-          dest = realloc (dest, len);
+        case '"': need = 6; break;   /* &quot; */
+        case '\'': need = 5; break; /* &#39; */
+        case '`': need = 5; break;   /* &#96; */
+        case '&': need = 5; break;   /* &amp; */
+        case '<': need = 4; break;   /* &lt; */
+        case '>': need = 4; break;   /* &gt; */
+        case '{': need = 6; break;   /* &#123; */
+        case '}': need = 6; break;   /* &#125; */
+        default:
+          if (c >= 127)
+            need = 8; /* enough for "&#xFF;" */
+          else if (c >= 20)
+            need = 1;
+          else
+            need = 0;
+        }
+
+      if (off + need + 1 > len)
+        {
+          int newlen = len;
+          while (off + need + 1 > newlen)
+            newlen += 16;
+          char *tmp = realloc (dest, newlen);
+          if (!tmp)
+            {
+              free (dest);
+              return NULL;
+            }
+          dest = tmp;
+          len = newlen;
           d = dest + off;
         }
-      switch (*s)
+
+      switch (c)
         {
-        case '"': strcat (d, "&quot;"); d += 6; break;
-        case '\'': strcat (d, "&#39;"); d += 5; break;
-        case '`': strcat (d, "&#96;"); d += 5; break;
-        case '&': strcat (d, "&amp;"); d += 5; break;
-        case '<': strcat (d, "&lt;"); d += 4; break;
-        case '>': strcat (d, "&gt;"); d += 4; break;
-        case '{': strcat (d, "&#123;"); d += 6; break;
-        case '}': strcat (d, "&#125;"); d += 6; break;
+        case '"': memcpy (d, "&quot;", 6); d += 6; break;
+        case '\'': memcpy (d, "&#39;", 5); d += 5; break;
+        case '`': memcpy (d, "&#96;", 5); d += 5; break;
+        case '&': memcpy (d, "&amp;", 5); d += 5; break;
+        case '<': memcpy (d, "&lt;", 4); d += 4; break;
+        case '>': memcpy (d, "&gt;", 4); d += 4; break;
+        case '{': memcpy (d, "&#123;", 6); d += 6; break;
+        case '}': memcpy (d, "&#125;", 6); d += 6; break;
         default:
-          if (*s >= 127) // maybe encodings, no utf8 (see htmlwescape)
+          if (c >= 127) /* maybe encodings, no utf8 (see htmlwescape) */
             {
-              sprintf (d, "&#x%X;", *s); // 4 + 4
-              d += strlen (d);
+              int n = snprintf (d, (size_t)(len - off), "&#x%X;", c);
+              if (n > 0)
+                d += n;
             }
-          else if (*s >= 20)
-            *d++ = *s;
+          else if (c >= 20)
+            *d++ = (char)c;
         }
+      *d = 0;
     }
-  *d = 0;
+
   return dest;
 }
 
@@ -78,40 +122,79 @@ htmlwescape (BITCODE_TU wstr)
 
   if (!wstr)
     return NULL;
+
   while ((c = *tmp++))
     len++;
   len += 16;
-  d = dest = malloc (len);
+  dest = malloc (len);
+  if (!dest)
+    return NULL;
+  d = dest;
+  *d = 0;
 
-  while (*wstr++)
+  while (*wstr)
     {
-      const int off = d - dest;
-      if (off >= len - 8)
+      const BITCODE_RS wc = *wstr++;
+      const int off = (int)(d - dest);
+      int need;
+
+      switch (wc)
+        {
+        case 34: need = 6; break;  /* &quot; */
+        case 39: need = 5; break;  /* &#39; */
+        case 38: need = 5; break;  /* &amp; */
+        case 60: need = 4; break;  /* &lt; */
+        case 62: need = 4; break;  /* &gt; */
+        case 96: need = 5; break;  /* &#96; */
+        case 123: need = 6; break; /* &#123; */
+        case 125: need = 6; break; /* &#125; */
+        default:
+          if (wc >= 127)
+            need = 12; /* enough for "&#xFFFF;" etc */
+          else if (wc >= 20)
+            need = 1;
+          else
+            need = 0;
+        }
+
+      if (off + need + 1 > len)
         {
-          len += 16;
-          dest = realloc (dest, len);
+          int newlen = len;
+          while (off + need + 1 > newlen)
+            newlen += 16;
+          char *tmp2 = realloc (dest, newlen);
+          if (!tmp2)
+            {
+              free (dest);
+              return NULL;
+            }
+          dest = tmp2;
+          len = newlen;
           d = dest + off;
         }
-      switch (*wstr)
+
+      switch (wc)
         {
-        case 34: strcat (d, "&quot;"); d += 6; break;
-        case 39: strcat (d, "&#39;"); d += 5; break;
-        case 38: strcat (d, "&amp;"); d += 5; break;
-        case 60: strcat (d, "&lt;"); d += 4; break;
-        case 62: strcat (d, "&gt;"); d += 4; break;
-        case 96: strcat (d, "&#96;"); d += 5; break;
-        case 123: strcat (d, "&#123;"); d += 6; break;
-        case 125: strcat (d, "&#125;"); d += 6; break;
+        case 34: memcpy (d, "&quot;", 6); d += 6; break;
+        case 39: memcpy (d, "&#39;", 5); d += 5; break;
+        case 38: memcpy (d, "&amp;", 5); d += 5; break;
+        case 60: memcpy (d, "&lt;", 4); d += 4; break;
+        case 62: memcpy (d, "&gt;", 4); d += 4; break;
+        case 96: memcpy (d, "&#96;", 5); d += 5; break;
+        case 123: memcpy (d, "&#123;", 6); d += 6; break;
+        case 125: memcpy (d, "&#125;", 6); d += 6; break;
         default:
-          if (*wstr >= 127) // utf8 encodings
+          if (wc >= 127) // utf8 encodings
             {
-              sprintf (d, "&#x%X;", *wstr);
-              d += strlen (d);
+              int n = snprintf (d, (size_t)(len - off), "&#x%X;", (unsigned)wc);
+              if (n > 0)
+                d += n;
             }
-          else if (*wstr >= 20)
-            *d++ = *wstr;
+          else if (wc >= 20)
+            *d++ = (char)wc;
         }
+      *d = 0;
     }
-  *d = 0;
+
   return dest;
 }