diff --git a/src/filters/reframe_mp3.c b/src/filters/reframe_mp3.c
index e81dd17..565b54d 100644
--- a/src/filters/reframe_mp3.c
+++ b/src/filters/reframe_mp3.c
@@ -265,9 +265,24 @@ void id3dmx_flush(GF_Filter *filter, u8 *id3_buf, u32 id3_buf_size, GF_FilterPid
 			break;
 		}
 
-		if (buf_alloc<=fsize) {
-			_buf = gf_realloc(_buf, fsize+3);
-			buf_alloc = fsize+3;
+		/* we read at _buf+1 for alignment and then write two terminating 0 bytes at
+		 * _buf[fsize+1] and _buf[fsize+2], so we always need (fsize+3) bytes.
+		 * Previous check (buf_alloc<=fsize) could keep a smaller buffer for a
+		 * larger access, leading to OOB write on the final terminator.
+		 */
+		if (fsize > (u32) -4) {
+			GF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, ("[MP3Dmx] ID3 frame size too large\n"));
+			break;
+		}
+		if (buf_alloc < fsize + 3) {
+			u32 new_alloc = fsize + 3;
+			char *tmp = gf_realloc(_buf, new_alloc);
+			if (!tmp) {
+				GF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, ("[MP3Dmx] Failed to allocate %u bytes for ID3 frame\n", new_alloc));
+				break;
+			}
+			_buf = tmp;
+			buf_alloc = new_alloc;
 		}
 		//read into _buf+1 so that buf+1 is always %2 mem aligned as it can be loaded as unsigned short
 		gf_bs_read_data(bs, _buf+1, fsize);