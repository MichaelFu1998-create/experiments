diff --git a/config.h b/config.h
new file mode 100644
index 0000000..be48641
--- /dev/null
+++ b/config.h
@@ -0,0 +1,136 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Define if building universal (internal helper macro) */
+/* #undef AC_APPLE_UNIVERSAL_BUILD */
+
+/* Define if you want to use libfaad together with Digital Radio Mondiale
+   (DRM) */
+/* #undef DRM */
+
+/* Define if you want support for Digital Radio Mondiale (DRM) parametric
+   stereo */
+/* #undef DRM_PS */
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define HAVE_DLFCN_H 1
+
+/* Define to 1 if you have the <errno.h> header file. */
+#define HAVE_ERRNO_H 1
+
+/* Define if needed */
+/* #undef HAVE_FLOAT32_T */
+
+/* Define to 1 if you have the <float.h> header file. */
+#define HAVE_FLOAT_H 1
+
+/* Define to 1 if you have the `getpwuid' function. */
+#define HAVE_GETPWUID 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define if you have the IOKit API */
+/* #undef HAVE_IOKIT_IOKITLIB_H */
+
+/* Define to 1 if you have the <limits.h> header file. */
+#define HAVE_LIMITS_H 1
+
+/* Define if you have C99's lrintf function. */
+#define HAVE_LRINTF 1
+
+/* Define to 1 if you have the <mathf.h> header file. */
+/* #undef HAVE_MATHF_H */
+
+/* Define to 1 if you have the `memcpy' function. */
+#define HAVE_MEMCPY 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the `strchr' function. */
+#define HAVE_STRCHR 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the `strsep' function. */
+#define HAVE_STRSEP 1
+
+/* Define to 1 if you have the <sysfs/libsysfs.h> header file. */
+/* #undef HAVE_SYSFS_LIBSYSFS_H */
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#define HAVE_SYS_TIME_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to the sub-directory where libtool stores uninstalled libraries. */
+#define LT_OBJDIR ".libs/"
+
+/* Name of package */
+#define PACKAGE "faad2"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT ""
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "faad2"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "faad2 2.8.8"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "faad2"
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL ""
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "2.8.8"
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
+#define TIME_WITH_SYS_TIME 1
+
+/* Version number of package */
+#define VERSION "2.8.8"
+
+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
+   significant byte first (like Motorola and SPARC, unlike Intel). */
+#if defined AC_APPLE_UNIVERSAL_BUILD
+# if defined __BIG_ENDIAN__
+#  define WORDS_BIGENDIAN 1
+# endif
+#else
+# ifndef WORDS_BIGENDIAN
+/* #  undef WORDS_BIGENDIAN */
+# endif
+#endif
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
+/* #undef inline */
+#endif
+
+/* Define to `long int' if <sys/types.h> does not define. */
+/* #undef off_t */
diff --git a/libfaad/sbr_hfadj.c b/libfaad/sbr_hfadj.c
index 3f310b8..75d9d4e 100644
--- a/libfaad/sbr_hfadj.c
+++ b/libfaad/sbr_hfadj.c
@@ -58,9 +58,40 @@ uint8_t hf_adjustment(sbr_info *sbr, qmf_t Xsbr[MAX_NTSRHFG][64]
 #endif
                       ,uint8_t ch)
 {
+    /* Guard against corrupted bitstreams causing out-of-bounds indices */
+    uint8_t L_E = sbr->L_E[ch];
+    uint8_t M = sbr->M;
+    if (L_E > MAX_L_E) L_E = MAX_L_E;
+    if (M > MAX_M) M = MAX_M;
+
     ALIGN sbr_hfadj_info adj = {{{0}}};
     uint8_t ret = 0;
 
+    /*
+     * Robustness against bitstream errors:
+     * A number of SBR header fields are used as loop bounds and as indices
+     * into fixed-size stack/struct arrays (e.g. adj.*[MAX_L_E][MAX_M]).
+     * If these fields are corrupted, the decoder could write past stack
+     * buffers (OOB write) and crash.
+     */
+    if (sbr == NULL)
+        return 1;
+    if (ch > 1)
+        return 1;
+    if (sbr->L_E[ch] > MAX_L_E)
+        return 1;
+    /* t_Q has 3 entries [0..2] -> current_t_noise_band+1 must be <= 2 */
+    if (sbr->L_Q[ch] > 2)
+        return 1;
+    if (sbr->M > MAX_M)
+        return 1;
+    /* prevent (m + kx) from indexing past QMF subbands */
+    if (sbr->kx > 64 || (uint16_t)sbr->kx + (uint16_t)sbr->M > 64)
+        return 1;
+    /* limiter tables are dimensioned [4][64] and limGain has 4 entries */
+    if (sbr->bs_limiter_bands > 3 || sbr->bs_limiter_gains > 3)
+        return 1;
+
     if (sbr->bs_frame_class[ch] == FIXFIX)
     {
         sbr->l_A[ch] = -1;
@@ -76,6 +107,12 @@ uint8_t hf_adjustment(sbr_info *sbr, qmf_t Xsbr[MAX_NTSRHFG][64]
             sbr->l_A[ch] = sbr->L_E[ch] + 1 - sbr->bs_pointer[ch];
     }
 
+    /* Clamp l_A into a safe range, since bit errors may make it invalid */
+    if (sbr->l_A[ch] < -1)
+        sbr->l_A[ch] = -1;
+    if (sbr->l_A[ch] > (int8_t)sbr->L_E[ch])
+        sbr->l_A[ch] = -1;
+
     ret = estimate_current_envelope(sbr, &adj, Xsbr, ch);
     if (ret > 0)
         return 1;
@@ -438,6 +475,12 @@ static real_t find_log2_Qplus1(sbr_info *sbr, uint8_t k, uint8_t l, uint8_t ch)
 
 static void calculate_gain(sbr_info *sbr, sbr_hfadj_info *adj, uint8_t ch)
 {
+    /* Guard against corrupted bitstreams causing out-of-bounds indices */
+    uint8_t L_E = sbr->L_E[ch];
+    uint8_t M = sbr->M;
+    if (L_E > MAX_L_E) L_E = MAX_L_E;
+    if (M > MAX_M) M = MAX_M;
+
     /* log2 values of limiter gains */
     static real_t limGain[] = {
         REAL_CONST(-1.0), REAL_CONST(0.0), REAL_CONST(1.0), REAL_CONST(33.219)
@@ -453,7 +496,7 @@ static void calculate_gain(sbr_info *sbr, sbr_hfadj_info *adj, uint8_t ch)
     ALIGN real_t S_M[MAX_M];
 
 
-    for (l = 0; l < sbr->L_E[ch]; l++)
+    for (l = 0; l < L_E; l++)
     {
         uint8_t current_f_noise_band = 0;
         uint8_t current_res_band = 0;
@@ -486,6 +529,14 @@ static void calculate_gain(sbr_info *sbr, sbr_hfadj_info *adj, uint8_t ch)
             ml2 = sbr->f_table_lim[sbr->bs_limiter_bands][k+1];
 
 
+
+            /* Clamp potentially corrupted limiter band bounds */
+            if (ml1 >= M)
+                continue;
+            if (ml2 > M)
+                ml2 = M;
+            if (ml2 <= ml1)
+                continue;
             /* calculate the accumulated E_orig and E_curr over the limiter band */
             for (m = ml1; m < ml2; m++)
             {
@@ -670,20 +721,20 @@ static void calculate_gain(sbr_info *sbr, sbr_hfadj_info *adj, uint8_t ch)
             {
                 /* apply compensation to gain, noise floor sf's and sinusoid levels */
 #ifndef SBR_LOW_POWER
-                adj->G_lim_boost[l][m] = pow2_fix((G_lim[m] + G_boost) >> 1);
+                if (l < MAX_L_E && m < MAX_M) adj->G_lim_boost[l][m] = pow2_fix((G_lim[m] + G_boost) >> 1);
 #else
                 /* sqrt() will be done after the aliasing reduction to save a
                  * few multiplies
                  */
-                adj->G_lim_boost[l][m] = pow2_fix(G_lim[m] + G_boost);
+                if (l < MAX_L_E && m < MAX_M) adj->G_lim_boost[l][m] = pow2_fix(G_lim[m] + G_boost);
 #endif
-                adj->Q_M_lim_boost[l][m] = pow2_fix((Q_M_lim[m] + G_boost) >> 1);
+                if (l < MAX_L_E && m < MAX_M) adj->Q_M_lim_boost[l][m] = pow2_fix((Q_M_lim[m] + G_boost) >> 1);
 
                 if (S_M[m] != LOG2_MIN_INF)
                 {
-                    adj->S_M_boost[l][m] = pow2_int((S_M[m] + G_boost) >> 1);
+                    if (l < MAX_L_E && m < MAX_M) adj->S_M_boost[l][m] = pow2_int((S_M[m] + G_boost) >> 1);
                 } else {
-                    adj->S_M_boost[l][m] = 0;
+                    if (l < MAX_L_E && m < MAX_M) adj->S_M_boost[l][m] = 0;
                 }
             }
         }
@@ -904,6 +955,12 @@ static real_t find_log2_Qplus1(sbr_info *sbr, uint8_t k, uint8_t l, uint8_t ch)
 
 static void calculate_gain(sbr_info *sbr, sbr_hfadj_info *adj, uint8_t ch)
 {
+    /* Guard against corrupted bitstreams causing out-of-bounds indices */
+    uint8_t L_E = sbr->L_E[ch];
+    uint8_t M = sbr->M;
+    if (L_E > MAX_L_E) L_E = MAX_L_E;
+    if (M > MAX_M) M = MAX_M;
+
     /* log2 values of limiter gains */
     static real_t limGain[] = { -1.0, 0.0, 1.0, 33.219 };
     uint8_t m, l, k;
@@ -917,7 +974,7 @@ static void calculate_gain(sbr_info *sbr, sbr_hfadj_info *adj, uint8_t ch)
     ALIGN real_t S_M[MAX_M];
 
 
-    for (l = 0; l < sbr->L_E[ch]; l++)
+    for (l = 0; l < L_E; l++)
     {
         uint8_t current_f_noise_band = 0;
         uint8_t current_res_band = 0;
@@ -950,6 +1007,14 @@ static void calculate_gain(sbr_info *sbr, sbr_hfadj_info *adj, uint8_t ch)
             ml2 = sbr->f_table_lim[sbr->bs_limiter_bands][k+1];
 
 
+
+            /* Clamp potentially corrupted limiter band bounds */
+            if (ml1 >= M)
+                continue;
+            if (ml2 > M)
+                ml2 = M;
+            if (ml2 <= ml1)
+                continue;
             /* calculate the accumulated E_orig and E_curr over the limiter band */
             for (m = ml1; m < ml2; m++)
             {
@@ -1129,20 +1194,20 @@ static void calculate_gain(sbr_info *sbr, sbr_hfadj_info *adj, uint8_t ch)
             {
                 /* apply compensation to gain, noise floor sf's and sinusoid levels */
 #ifndef SBR_LOW_POWER
-                adj->G_lim_boost[l][m] = QUANTISE2REAL(pow2((G_lim[m] + G_boost) / 2.0));
+                if (l < MAX_L_E && m < MAX_M) adj->G_lim_boost[l][m] = QUANTISE2REAL(pow2((G_lim[m] + G_boost) / 2.0));
 #else
                 /* sqrt() will be done after the aliasing reduction to save a
                  * few multiplies
                  */
-                adj->G_lim_boost[l][m] = QUANTISE2REAL(pow2(G_lim[m] + G_boost));
+                if (l < MAX_L_E && m < MAX_M) adj->G_lim_boost[l][m] = QUANTISE2REAL(pow2(G_lim[m] + G_boost));
 #endif
-                adj->Q_M_lim_boost[l][m] = QUANTISE2REAL(pow2((Q_M_lim[m] + 10 + G_boost) / 2.0));
+                if (l < MAX_L_E && m < MAX_M) adj->Q_M_lim_boost[l][m] = QUANTISE2REAL(pow2((Q_M_lim[m] + 10 + G_boost) / 2.0));
 
                 if (S_M[m] != LOG2_MIN_INF)
                 {
-                    adj->S_M_boost[l][m] = QUANTISE2REAL(pow2((S_M[m] + 10 + G_boost) / 2.0));
+                    if (l < MAX_L_E && m < MAX_M) adj->S_M_boost[l][m] = QUANTISE2REAL(pow2((S_M[m] + 10 + G_boost) / 2.0));
                 } else {
-                    adj->S_M_boost[l][m] = 0;
+                    if (l < MAX_L_E && m < MAX_M) adj->S_M_boost[l][m] = 0;
                 }
             }
         }
@@ -1153,6 +1218,12 @@ static void calculate_gain(sbr_info *sbr, sbr_hfadj_info *adj, uint8_t ch)
 
 static void calculate_gain(sbr_info *sbr, sbr_hfadj_info *adj, uint8_t ch)
 {
+    /* Guard against corrupted bitstreams causing out-of-bounds indices */
+    uint8_t L_E = sbr->L_E[ch];
+    uint8_t M = sbr->M;
+    if (L_E > MAX_L_E) L_E = MAX_L_E;
+    if (M > MAX_M) M = MAX_M;
+
     static real_t limGain[] = { 0.5, 1.0, 2.0, 1e10 };
     uint8_t m, l, k;
 
@@ -1164,7 +1235,7 @@ static void calculate_gain(sbr_info *sbr, sbr_hfadj_info *adj, uint8_t ch)
     ALIGN real_t G_boost;
     ALIGN real_t S_M[MAX_M];
 
-    for (l = 0; l < sbr->L_E[ch]; l++)
+    for (l = 0; l < L_E; l++)
     {
         uint8_t current_f_noise_band = 0;
         uint8_t current_res_band = 0;
@@ -1194,6 +1265,14 @@ static void calculate_gain(sbr_info *sbr, sbr_hfadj_info *adj, uint8_t ch)
             ml2 = sbr->f_table_lim[sbr->bs_limiter_bands][k+1];
 
 
+
+            /* Clamp potentially corrupted limiter band bounds */
+            if (ml1 >= M)
+                continue;
+            if (ml2 > M)
+                ml2 = M;
+            if (ml2 <= ml1)
+                continue;
             /* calculate the accumulated E_orig and E_curr over the limiter band */
             for (m = ml1; m < ml2; m++)
             {
@@ -1330,20 +1409,20 @@ static void calculate_gain(sbr_info *sbr, sbr_hfadj_info *adj, uint8_t ch)
             {
                 /* apply compensation to gain, noise floor sf's and sinusoid levels */
 #ifndef SBR_LOW_POWER
-                adj->G_lim_boost[l][m] = sqrt(G_lim[m] * G_boost);
+                if (l < MAX_L_E && m < MAX_M) adj->G_lim_boost[l][m] = sqrt(G_lim[m] * G_boost);
 #else
                 /* sqrt() will be done after the aliasing reduction to save a
                  * few multiplies
                  */
-                adj->G_lim_boost[l][m] = G_lim[m] * G_boost;
+                if (l < MAX_L_E && m < MAX_M) adj->G_lim_boost[l][m] = G_lim[m] * G_boost;
 #endif
-                adj->Q_M_lim_boost[l][m] = sqrt(Q_M_lim[m] * G_boost);
+                if (l < MAX_L_E && m < MAX_M) adj->Q_M_lim_boost[l][m] = sqrt(Q_M_lim[m] * G_boost);
 
                 if (S_M[m] != 0)
                 {
-                    adj->S_M_boost[l][m] = sqrt(S_M[m] * G_boost);
+                    if (l < MAX_L_E && m < MAX_M) adj->S_M_boost[l][m] = sqrt(S_M[m] * G_boost);
                 } else {
-                    adj->S_M_boost[l][m] = 0;
+                    if (l < MAX_L_E && m < MAX_M) adj->S_M_boost[l][m] = 0;
                 }
             }
         }
@@ -1502,9 +1581,9 @@ static void aliasing_reduction(sbr_info *sbr, sbr_hfadj_info *adj, real_t *deg,
                  m < sbr->f_table_lim[sbr->bs_limiter_bands][k+1]; m++)
             {
 #ifdef FIXED_POINT
-                 adj->G_lim_boost[l][m] = SBR_SQRT_Q2(adj->G_lim_boost[l][m]);
+                 if (l < MAX_L_E && m < MAX_M) adj->G_lim_boost[l][m] = SBR_SQRT_Q2(adj->G_lim_boost[l][m]);
 #else
-                 adj->G_lim_boost[l][m] = sqrt(adj->G_lim_boost[l][m]);
+                 if (l < MAX_L_E && m < MAX_M) adj->G_lim_boost[l][m] = sqrt(adj->G_lim_boost[l][m]);
 #endif
             }
         }