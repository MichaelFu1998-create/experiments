diff --git a/libheif/uncompressed_image.cc b/libheif/uncompressed_image.cc
index 5218165..e31acea 100644
--- a/libheif/uncompressed_image.cc
+++ b/libheif/uncompressed_image.cc
@@ -362,9 +362,17 @@ Error Box_uncC::write(StreamWriter& writer) const
 
 static Error uncompressed_image_type_is_supported(std::shared_ptr<Box_uncC>& uncC, std::shared_ptr<Box_cmpd>& cmpd)
 {
+  const auto& cmpd_components = cmpd->get_components();
+
   for (Box_uncC::Component component : uncC->get_components()) {
     uint16_t component_index = component.component_index;
-    uint16_t component_type = cmpd->get_components()[component_index].component_type;
+    if (component_index >= cmpd_components.size()) {
+      return Error(heif_error_Invalid_input,
+                   heif_suberror_Invalid_parameter_value,
+                   "uncC component_index references non-existing cmpd component");
+    }
+
+    uint16_t component_type = cmpd_components[component_index].component_type;
     if (component_type > 7) {
       std::stringstream sstr;
       sstr << "Uncompressed image with component_type " << ((int) component_type) << " is not implemented yet";
@@ -464,9 +472,17 @@ static Error get_heif_chroma_uncompressed(std::shared_ptr<Box_uncC>& uncC, std::
   // each 1-bit represents an existing component in the image
   uint16_t componentSet = 0;
 
+  const auto& cmpd_components = cmpd->get_components();
+
   for (Box_uncC::Component component : uncC->get_components()) {
     uint16_t component_index = component.component_index;
-    uint16_t component_type = cmpd->get_components()[component_index].component_type;
+    if (component_index >= cmpd_components.size()) {
+      return Error(heif_error_Invalid_input,
+                   heif_suberror_Invalid_parameter_value,
+                   "uncC component_index references non-existing cmpd component");
+    }
+
+    uint16_t component_type = cmpd_components[component_index].component_type;
 
     if (component_type > component_type_max_valid) {
       std::stringstream sstr;
@@ -522,6 +538,13 @@ int UncompressedImageCodec::get_luma_bits_per_pixel_from_configuration_unci(cons
   auto ipco = heif_file.get_ipco_box();
   auto ipma = heif_file.get_ipma_box();
 
+  // Robustness against malformed files: these boxes are optional and can be absent.
+  // Returning "unknown" here prevents crashes further down when the caller only
+  // wants a best-effort answer.
+  if (!ipco || !ipma) {
+    return -1;
+  }
+
   auto box1 = ipco->get_property_for_item_ID(imageID, ipma, fourcc("uncC"));
   std::shared_ptr<Box_uncC> uncC_box = std::dynamic_pointer_cast<Box_uncC>(box1);
   auto box2 = ipco->get_property_for_item_ID(imageID, ipma, fourcc("cmpd"));
@@ -530,11 +553,23 @@ int UncompressedImageCodec::get_luma_bits_per_pixel_from_configuration_unci(cons
     return -1;
   }
 
+  const auto& cmpd_components = cmpd_box->get_components();
+  if (cmpd_components.empty()) {
+    return -1;
+  }
+
   int luma_bits = 0;
   int alternate_channel_bits = 0;
   for (Box_uncC::Component component : uncC_box->get_components()) {
     uint16_t component_index = component.component_index;
-    auto component_type = cmpd_box->get_components()[component_index].component_type;
+
+    // The uncC component_index refers into the cmpd component list.
+    // Malformed input may reference a non-existing entry; avoid OOB/UAF.
+    if (component_index >= cmpd_components.size()) {
+      continue;
+    }
+
+    auto component_type = cmpd_components[component_index].component_type;
     switch (component_type) {
       case component_type_monochrome:
       case component_type_red:
@@ -679,9 +714,17 @@ Error UncompressedImageCodec::decode_uncompressed_image(const std::shared_ptr<co
   std::map<heif_channel, uint32_t> channel_to_pixelOffset;
 
   uint32_t componentOffset = 0;
+  const auto& cmpd_components = cmpd->get_components();
+
   for (Box_uncC::Component component : uncC->get_components()) {
     uint16_t component_index = component.component_index;
-    uint16_t component_type = cmpd->get_components()[component_index].component_type;
+    if (component_index >= cmpd_components.size()) {
+      return Error(heif_error_Invalid_input,
+                   heif_suberror_Invalid_parameter_value,
+                   "uncC component_index references non-existing cmpd component");
+    }
+
+    uint16_t component_type = cmpd_components[component_index].component_type;
     if (component_type == component_type_Y ||
         component_type == component_type_monochrome) {
       img->add_plane(heif_channel_Y, width, height, component.component_bit_depth);