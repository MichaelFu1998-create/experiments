diff --git a/libheif/uncompressed_image.cc b/libheif/uncompressed_image.cc
index 5218165..b8e6922 100644
--- a/libheif/uncompressed_image.cc
+++ b/libheif/uncompressed_image.cc
@@ -364,6 +364,11 @@ static Error uncompressed_image_type_is_supported(std::shared_ptr<Box_uncC>& unc
 {
   for (Box_uncC::Component component : uncC->get_components()) {
     uint16_t component_index = component.component_index;
+    if (component_index >= cmpd->get_components().size()) {
+      return Error(heif_error_Invalid_input,
+                   heif_suberror_Invalid_parameter_value,
+                   "Uncompressed codec: component index out of range");
+    }
     uint16_t component_type = cmpd->get_components()[component_index].component_type;
     if (component_type > 7) {
       std::stringstream sstr;
@@ -578,24 +583,41 @@ static unsigned int get_bytes_per_pixel(const std::shared_ptr<Box_uncC>& uncC)
   return bytes;
 }
 
+static uint64_t get_tile_padding(uint64_t content_bytes_per_tile, uint32_t tile_align_size)
+{
+  if (tile_align_size == 0) {
+    return 0;
+  }
+
+  const uint64_t rem = content_bytes_per_tile % tile_align_size;
+  return rem ? (tile_align_size - rem) : 0;
+}
+
 static long unsigned int get_tile_base_offset(uint32_t col, uint32_t row, const std::shared_ptr<Box_uncC>& uncC, const std::vector<heif_channel>& channels, uint32_t width, uint32_t height)
 {
-  uint32_t numTileColumns = uncC->get_number_of_tile_columns();
-  uint32_t numTileRows = uncC->get_number_of_tile_rows();
-  uint32_t tile_width = width / numTileColumns;
-  uint32_t tile_height = height / numTileRows;
-  long unsigned int content_bytes_per_tile = tile_width * tile_height * get_bytes_per_pixel(uncC);
-  uint32_t tile_align_size = uncC->get_tile_align_size();
-  long unsigned int tile_padding = 0;
-  if (tile_align_size > 0) {
-    tile_padding = tile_align_size - (content_bytes_per_tile % tile_align_size);
+  (void) channels; // currently unused
+
+  const uint32_t numTileColumns = uncC->get_number_of_tile_columns();
+  const uint32_t numTileRows = uncC->get_number_of_tile_rows();
+  if (numTileColumns == 0 || numTileRows == 0) {
+    return 0;
+  }
+
+  const uint32_t tile_width = width / numTileColumns;
+  const uint32_t tile_height = height / numTileRows;
+  if (tile_width == 0 || tile_height == 0) {
+    return 0;
   }
-  long unsigned int bytes_per_tile = content_bytes_per_tile + tile_padding;
-  uint32_t tile_idx_y = row / tile_height;
-  uint32_t tile_idx_x = col / tile_width;
-  uint32_t tile_idx = tile_idx_y * numTileColumns + tile_idx_x;
-  long unsigned int tile_base_offset = tile_idx * bytes_per_tile;
-  return tile_base_offset;
+
+  const uint64_t content_bytes_per_tile = (uint64_t) tile_width * tile_height * get_bytes_per_pixel(uncC);
+  const uint64_t tile_padding = get_tile_padding(content_bytes_per_tile, uncC->get_tile_align_size());
+  const uint64_t bytes_per_tile = content_bytes_per_tile + tile_padding;
+
+  const uint32_t tile_idx_y = row / tile_height;
+  const uint32_t tile_idx_x = col / tile_width;
+  const uint64_t tile_idx = (uint64_t) tile_idx_y * numTileColumns + tile_idx_x;
+
+  return (long unsigned int) (tile_idx * bytes_per_tile);
 }
 
 
@@ -671,6 +693,44 @@ Error UncompressedImageCodec::decode_uncompressed_image(const std::shared_ptr<co
   if (error) {
     return error;
   }
+
+  // Validate tile parameters and input buffer size early (before allocating planes).
+  const uint32_t numTileColumns = uncC->get_number_of_tile_columns();
+  const uint32_t numTileRows = uncC->get_number_of_tile_rows();
+
+  if (width == 0 || height == 0 || numTileColumns == 0 || numTileRows == 0) {
+    return Error(heif_error_Invalid_input,
+                 heif_suberror_Invalid_parameter_value,
+                 "Invalid image/tile dimensions for uncompressed codec");
+  }
+
+  if ((width % numTileColumns) != 0 || (height % numTileRows) != 0) {
+    return Error(heif_error_Invalid_input,
+                 heif_suberror_Invalid_parameter_value,
+                 "Uncompressed codec: image size is not divisible by tile grid");
+  }
+
+  const uint32_t tile_width = width / numTileColumns;
+  const uint32_t tile_height = height / numTileRows;
+
+  if (tile_width == 0 || tile_height == 0) {
+    return Error(heif_error_Invalid_input,
+                 heif_suberror_Invalid_parameter_value,
+                 "Uncompressed codec: invalid tile size");
+  }
+
+  // Ensure buffer is large enough before any memcpy() / indexed reads.
+  const uint64_t content_bytes_per_tile = (uint64_t) tile_width * tile_height * get_bytes_per_pixel(uncC);
+  const uint64_t tile_padding = get_tile_padding(content_bytes_per_tile, uncC->get_tile_align_size());
+  const uint64_t bytes_per_tile_u64 = content_bytes_per_tile + tile_padding;
+  const uint64_t num_tiles_u64 = (uint64_t) numTileColumns * numTileRows;
+  const uint64_t expected_bytes_u64 = num_tiles_u64 * bytes_per_tile_u64;
+
+  if (expected_bytes_u64 > (uint64_t) uncompressed_data.size()) {
+    return Error(heif_error_Invalid_input,
+                 heif_suberror_End_of_data,
+                 "Uncompressed image data is truncated");
+  }
   img->create(width, height,
               colourspace,
               chroma);
@@ -684,37 +744,65 @@ Error UncompressedImageCodec::decode_uncompressed_image(const std::shared_ptr<co
     uint16_t component_type = cmpd->get_components()[component_index].component_type;
     if (component_type == component_type_Y ||
         component_type == component_type_monochrome) {
-      img->add_plane(heif_channel_Y, width, height, component.component_bit_depth);
+      if (!img->add_plane(heif_channel_Y, width, height, component.component_bit_depth)) {
+        return Error(heif_error_Memory_allocation_error,
+                     heif_suberror_Unspecified,
+                     "Cannot allocate image plane");
+      }
       channels.push_back(heif_channel_Y);
       channel_to_pixelOffset.emplace(heif_channel_Y, componentOffset);
     }
     else if (component_type == component_type_Cb) {
-      img->add_plane(heif_channel_Cb, width, height, component.component_bit_depth);
+      if (!img->add_plane(heif_channel_Cb, width, height, component.component_bit_depth)) {
+        return Error(heif_error_Memory_allocation_error,
+                     heif_suberror_Unspecified,
+                     "Cannot allocate image plane");
+      }
       channels.push_back(heif_channel_Cb);
       channel_to_pixelOffset.emplace(heif_channel_Cb, componentOffset);
     }
     else if (component_type == component_type_Cr) {
-      img->add_plane(heif_channel_Cr, width, height, component.component_bit_depth);
+      if (!img->add_plane(heif_channel_Cr, width, height, component.component_bit_depth)) {
+        return Error(heif_error_Memory_allocation_error,
+                     heif_suberror_Unspecified,
+                     "Cannot allocate image plane");
+      }
       channels.push_back(heif_channel_Cr);
       channel_to_pixelOffset.emplace(heif_channel_Cr, componentOffset);
     }
     else if (component_type == component_type_red) {
-      img->add_plane(heif_channel_R, width, height, component.component_bit_depth);
+      if (!img->add_plane(heif_channel_R, width, height, component.component_bit_depth)) {
+        return Error(heif_error_Memory_allocation_error,
+                     heif_suberror_Unspecified,
+                     "Cannot allocate image plane");
+      }
       channels.push_back(heif_channel_R);
       channel_to_pixelOffset.emplace(heif_channel_R, componentOffset);
     }
     else if (component_type == component_type_green) {
-      img->add_plane(heif_channel_G, width, height, component.component_bit_depth);
+      if (!img->add_plane(heif_channel_G, width, height, component.component_bit_depth)) {
+        return Error(heif_error_Memory_allocation_error,
+                     heif_suberror_Unspecified,
+                     "Cannot allocate image plane");
+      }
       channels.push_back(heif_channel_G);
       channel_to_pixelOffset.emplace(heif_channel_G, componentOffset);
     }
     else if (component_type == component_type_blue) {
-      img->add_plane(heif_channel_B, width, height, component.component_bit_depth);
+      if (!img->add_plane(heif_channel_B, width, height, component.component_bit_depth)) {
+        return Error(heif_error_Memory_allocation_error,
+                     heif_suberror_Unspecified,
+                     "Cannot allocate image plane");
+      }
       channels.push_back(heif_channel_B);
       channel_to_pixelOffset.emplace(heif_channel_B, componentOffset);
     }
     else if (component_type == component_type_alpha) {
-      img->add_plane(heif_channel_Alpha, width, height, component.component_bit_depth);
+      if (!img->add_plane(heif_channel_Alpha, width, height, component.component_bit_depth)) {
+        return Error(heif_error_Memory_allocation_error,
+                     heif_suberror_Unspecified,
+                     "Cannot allocate image plane");
+      }
       channels.push_back(heif_channel_Alpha);
       channel_to_pixelOffset.emplace(heif_channel_Alpha, componentOffset);
     }
@@ -723,27 +811,30 @@ Error UncompressedImageCodec::decode_uncompressed_image(const std::shared_ptr<co
     componentOffset++;
   }
 
-  // TODO: properly interpret uncompressed_data per uncC config, subsampling etc.
-  uint32_t bytes_per_channel = width * height;
-  uint32_t numTileColumns = uncC->get_number_of_tile_columns();
-  uint32_t numTileRows = uncC->get_number_of_tile_rows();
-  uint32_t tile_width = width / numTileColumns;
-  uint32_t tile_height = height / numTileRows;
   if (uncC->get_interleave_type() == interleave_type_component) {
     // Source is planar
     // TODO: assumes 8 bits
     long unsigned int content_bytes_per_tile = tile_width * tile_height * get_bytes_per_pixel(uncC);
     uint32_t tile_align_size = uncC->get_tile_align_size();
-    long unsigned int tile_padding = 0;
-    if (tile_align_size > 0) {
-      tile_padding = tile_align_size - (content_bytes_per_tile % tile_align_size);
-    };
+    long unsigned int tile_padding = (long unsigned int) get_tile_padding(content_bytes_per_tile, tile_align_size);
     long unsigned int bytes_per_tile = content_bytes_per_tile + tile_padding;
     for (uint32_t c = 0; c < channels.size(); c++) {
       int stride;
       uint8_t* dst = img->get_plane(channels[c], &stride);
+      if (dst == nullptr) {
+        return Error(heif_error_Invalid_input,
+                     heif_suberror_Unspecified,
+                     "Uncompressed codec: missing destination plane");
+      }
       if ((numTileRows == 1) && (numTileColumns == 1) && (((uint32_t) stride) == width)) {
-        memcpy(dst, uncompressed_data.data() + c * bytes_per_channel, bytes_per_channel);
+        const uint64_t bytes_per_channel = (uint64_t) width * height;
+        const uint64_t src_off = (uint64_t) c * bytes_per_channel;
+        if (src_off + bytes_per_channel > uncompressed_data.size()) {
+          return Error(heif_error_Invalid_input,
+                       heif_suberror_End_of_data,
+                       "Uncompressed image data is truncated");
+        }
+        memcpy(dst, uncompressed_data.data() + src_off, (size_t) bytes_per_channel);
       }
       else {
         int pixel_offset = channel_to_pixelOffset[channels[c]];
@@ -755,6 +846,11 @@ Error UncompressedImageCodec::decode_uncompressed_image(const std::shared_ptr<co
             long unsigned int tile_base_offset = tile_idx * bytes_per_tile;
             long unsigned int src_offset = tile_base_offset + pixel_offset * tile_width * tile_height;
             long unsigned int dst_offset = row * stride + col;
+            if ((uint64_t) src_offset + tile_width > uncompressed_data.size()) {
+              return Error(heif_error_Invalid_input,
+                           heif_suberror_End_of_data,
+                           "Uncompressed image data is truncated");
+            }
             memcpy(dst + dst_offset, uncompressed_data.data() + src_offset /** + row * tile_width **/, tile_width);   // TODO: ** is a hack
           }
         }
@@ -771,6 +867,11 @@ Error UncompressedImageCodec::decode_uncompressed_image(const std::shared_ptr<co
       int pixel_offset = channel_to_pixelOffset[channels[c]];
       int stride;
       uint8_t* dst = img->get_plane(channels[c], &stride);
+      if (dst == nullptr) {
+        return Error(heif_error_Invalid_input,
+                     heif_suberror_Unspecified,
+                     "Uncompressed codec: missing destination plane");
+      }
       for (uint32_t row = 0; row < height; row++) {
         long unsigned int tile_row_idx = row % tile_height;
         size_t tile_row_offset = tile_width * tile_row_idx * channels.size();
@@ -781,6 +882,11 @@ Error UncompressedImageCodec::decode_uncompressed_image(const std::shared_ptr<co
           size_t tile_offset = tile_row_offset + tile_col * pixel_stride + pixel_offset;
           size_t src_offset = tile_base_offset + tile_offset;
           uint32_t dstPixelIndex = row * stride + col;
+          if (src_offset >= uncompressed_data.size()) {
+            return Error(heif_error_Invalid_input,
+                         heif_suberror_End_of_data,
+                         "Uncompressed image data is truncated");
+          }
           dst[dstPixelIndex] = src[src_offset];
         }
         for (; col < (uint32_t) stride; col++) {
@@ -798,6 +904,11 @@ Error UncompressedImageCodec::decode_uncompressed_image(const std::shared_ptr<co
       int pixel_offset = channel_to_pixelOffset[channels[c]];
       int stride;
       uint8_t* dst = img->get_plane(channels[c], &stride);
+      if (dst == nullptr) {
+        return Error(heif_error_Invalid_input,
+                     heif_suberror_Unspecified,
+                     "Uncompressed codec: missing destination plane");
+      }
       for (uint32_t row = 0; row < height; row++) {
         long unsigned int tile_row_idx = row % tile_height;
         size_t tile_row_offset = tile_width * (tile_row_idx * channels.size() + pixel_offset);
@@ -808,6 +919,11 @@ Error UncompressedImageCodec::decode_uncompressed_image(const std::shared_ptr<co
           size_t tile_offset = tile_row_offset + tile_col;
           size_t src_offset = tile_base_offset + tile_offset;
           uint32_t dst_offset = row * stride + col;
+          if ((uint64_t) src_offset + tile_width > uncompressed_data.size()) {
+            return Error(heif_error_Invalid_input,
+                         heif_suberror_End_of_data,
+                         "Uncompressed image data is truncated");
+          }
           memcpy(dst + dst_offset, uncompressed_data.data() + src_offset, tile_width);
         }
         for (; col < (uint32_t) stride; col++) {