diff --git a/src/kernel.c b/src/kernel.c
index 8551b50..f963554 100644
--- a/src/kernel.c
+++ b/src/kernel.c
@@ -278,6 +278,46 @@ copy_class(mrb_state *mrb, mrb_value dst, mrb_value src)
 static void
 init_copy(mrb_state *mrb, mrb_value dest, mrb_value obj)
 {
+  /* TT_ICLASS is for internal use (mixed-in module holder).
+     It is not a normal Ruby object and must not invoke Ruby-level
+     initialize_copy. Also, mrb_obj_dup() is used internally to copy
+     prepended iclasses; those duplicates must have their internal
+     pointers initialized here.
+
+     If we call initialize_copy for TT_ICLASS, the object may still have
+     uninitialized fields (iv/mt/super/c), which can lead to crashes.
+  */
+  if (mrb_type(obj) == MRB_TT_ICLASS) {
+    struct RClass *dc = mrb_class_ptr(dest);
+    struct RClass *sc = mrb_class_ptr(obj);
+
+    dc->iv = sc->iv;
+    /* ICLASS usually shares the method table with the original module.
+       Only the prepended origin ICLASS owns its mt and must duplicate it. */
+    if (sc->flags & MRB_FLAG_IS_ORIGIN) {
+      if (sc->mt) {
+        dc->mt = kh_copy(mt, mrb, sc->mt);
+      }
+      else {
+        dc->mt = kh_init(mt, mrb);
+      }
+    }
+    else {
+      dc->mt = sc->mt;
+    }
+    dc->super = sc->super;
+    dc->c = sc->c;
+    dc->flags = sc->flags;
+
+    if (dc->super) {
+      mrb_field_write_barrier(mrb, (struct RBasic*)dc, (struct RBasic*)dc->super);
+    }
+    if (dc->c) {
+      mrb_field_write_barrier(mrb, (struct RBasic*)dc, (struct RBasic*)dc->c);
+    }
+    return;
+  }
+
   switch (mrb_type(obj)) {
     case MRB_TT_CLASS:
     case MRB_TT_MODULE: