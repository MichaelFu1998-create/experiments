diff --git a/src/bifs/field_decode.c b/src/bifs/field_decode.c
index b507792..4aac773 100644
--- a/src/bifs/field_decode.c
+++ b/src/bifs/field_decode.c
@@ -233,7 +233,11 @@ GF_Err gf_bifs_dec_sf_field(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *n
 		 1 - memory mode, register command buffer for later parsing
 		 2 - InputSensor only works on decompressed commands
 		*/
-		if (codec->dec_memory_mode || (node->sgprivate->tag==TAG_MPEG4_InputSensor)) {
+		if (!is_mem_com && (codec->dec_memory_mode || (node->sgprivate->tag==TAG_MPEG4_InputSensor))) {
+			/* In memory decoder, is_mem_com means the CommandBuffer field points to a
+			 * temporary command-internal structure (freed when the command is deleted).
+			 * Register only persistent node-owned command buffers for later parsing. */
+
 			CommandBufferItem *cbi = (CommandBufferItem *)gf_malloc(sizeof(CommandBufferItem));
 			cbi->node = node;
 			gf_node_register(cbi->node, NULL);
diff --git a/src/bifs/memory_decoder.c b/src/bifs/memory_decoder.c
index d617d33..8407309 100644
--- a/src/bifs/memory_decoder.c
+++ b/src/bifs/memory_decoder.c
@@ -953,12 +953,31 @@ GF_Err gf_bifs_flush_command_list(GF_BifsDecoder *codec)
 	GF_List *nextPass = gf_list_new();
 	while (NbPass) {
 		while (gf_list_count(codec->command_buffers)) {
+			Bool drop_cbi = GF_FALSE;
 			cbi = (CommandBufferItem *)gf_list_get(codec->command_buffers, 0);
 			gf_list_rem(codec->command_buffers, 0);
 
+			/* Command buffers are referenced through nodes/fields. In memory mode
+			 * we may defer parsing to a later pass, but the underlying SFCommandBuffer
+			 * may have been replaced or destroyed in the meantime (node deletion,
+			 * buffer replacement, etc.). Avoid dereferencing stale/NULL pointers.
+			 */
+			if (!cbi || !cbi->cb) {
+				if (cbi) {
+					gf_node_unregister(cbi->node, NULL);
+					gf_free(cbi);
+				}
+				continue;
+			}
+
 			codec->current_graph = gf_node_get_graph(cbi->node);
 			e = GF_OK;
 			if (cbi->cb->bufferSize) {
+				if (!cbi->cb->buffer) {
+					gf_node_unregister(cbi->node, NULL);
+					gf_free(cbi);
+					continue;
+				}
 				bs = gf_bs_new((char*)cbi->cb->buffer, cbi->cb->bufferSize, GF_BITSTREAM_READ);
 				gf_bs_set_eos_callback(bs, BM_EndOfStream, codec);
 				e = BM_ParseCommand(codec, bs, cbi->cb->commandList);
@@ -977,6 +996,7 @@ GF_Err gf_bifs_flush_command_list(GF_BifsDecoder *codec)
 				gf_list_rem(cbi->cb->commandList, 0);
 				cf = (GF_CommandField *) gf_list_get(com->command_fields, 0);
 				if (cf && cf->fieldType==GF_SG_VRML_SFCOMMANDBUFFER) {
+					if (cbi->cb == cf->field_ptr) drop_cbi = GF_TRUE;
 					for (i=0; i<gf_list_count(codec->command_buffers); i++) {
 						CommandBufferItem *cbi2 = (CommandBufferItem *)gf_list_get(codec->command_buffers, i);
 						if (cbi2->cb == cf->field_ptr) {
@@ -986,9 +1006,24 @@ GF_Err gf_bifs_flush_command_list(GF_BifsDecoder *codec)
 							i--;
 						}
 					}
+					/* also check items already queued for next pass */
+					for (i=0; i<gf_list_count(nextPass); i++) {
+						CommandBufferItem *cbi2 = (CommandBufferItem *)gf_list_get(nextPass, i);
+						if (cbi2->cb == cf->field_ptr) {
+							gf_node_unregister(cbi2->node, NULL);
+							gf_free(cbi2);
+							gf_list_rem(nextPass, i);
+							i--;
+						}
+					}
 				}
 				gf_sg_command_del(com);
 			}
+			if (drop_cbi) {
+				gf_node_unregister(cbi->node, NULL);
+				gf_free(cbi);
+				continue;
+			}
 			gf_list_add(nextPass, cbi);
 		}
 		if (!gf_list_count(nextPass)) break;