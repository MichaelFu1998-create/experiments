diff --git a/programs/escape.c b/programs/escape.c
index 8a90741..1e4c419 100644
--- a/programs/escape.c
+++ b/programs/escape.c
@@ -23,47 +23,85 @@
 #include "common.h"
 #include "escape.h"
 
+/* Ensure buffer has space for `need` bytes plus trailing NUL.
+   Keeps d in sync if dest reallocates.
+ */
+static void
+ensure_space (char **destp, char **dp, size_t *lenp, const size_t need)
+{
+  const size_t off = (size_t)(*dp - *destp);
+  if (off + need + 1 > *lenp)
+    {
+      size_t newlen = *lenp;
+      while (off + need + 1 > newlen)
+        newlen += 16;
+      *destp = realloc (*destp, newlen);
+      *dp = *destp + off;
+      *lenp = newlen;
+    }
+}
+
+static void
+append_lit (char **destp, char **dp, size_t *lenp, const char *lit)
+{
+  const size_t l = strlen (lit);
+  ensure_space (destp, dp, lenp, l);
+  memcpy (*dp, lit, l);
+  *dp += l;
+}
+
 char * ATTRIBUTE_MALLOC
 htmlescape (const char *restrict src, const int cp)
 {
-  int len;
+  size_t len;
   char *dest, *d;
-  unsigned char *s;
+  const unsigned char *s;
+  unsigned char c;
+
+  (void)cp;
   if (!src)
     return NULL;
-  len = strlen (src) + 10;
-  d = malloc (len);
-  s = (unsigned char *)src;
-  dest = d;
-  while (*s++)
+
+  len = strlen (src) + 16;
+  dest = d = malloc (len);
+  if (!dest)
+    return NULL;
+
+  s = (const unsigned char *)src;
+
+  /* Keep output as we build it; never read past the end of src.
+     (The previous implementation used while (*s++) then accessed *s,
+     which reads one byte past the NUL terminator, and used strcat on
+     uninitialized memory.)
+   */
+  while ((c = *s++))
     {
-      const int off = d - dest;
-      if (off >= len - 8)
+      switch (c)
         {
-          len += 10;
-          dest = realloc (dest, len);
-          d = dest + off;
-        }
-      switch (*s)
-        {
-        case '"': strcat (d, "&quot;"); d += 6; break;
-        case '\'': strcat (d, "&#39;"); d += 5; break;
-        case '`': strcat (d, "&#96;"); d += 5; break;
-        case '&': strcat (d, "&amp;"); d += 5; break;
-        case '<': strcat (d, "&lt;"); d += 4; break;
-        case '>': strcat (d, "&gt;"); d += 4; break;
-        case '{': strcat (d, "&#123;"); d += 6; break;
-        case '}': strcat (d, "&#125;"); d += 6; break;
+        case '"': append_lit (&dest, &d, &len, "&quot;"); break;
+        case '\'': append_lit (&dest, &d, &len, "&#39;"); break;
+        case '`': append_lit (&dest, &d, &len, "&#96;"); break;
+        case '&': append_lit (&dest, &d, &len, "&amp;"); break;
+        case '<': append_lit (&dest, &d, &len, "&lt;"); break;
+        case '>': append_lit (&dest, &d, &len, "&gt;"); break;
+        case '{': append_lit (&dest, &d, &len, "&#123;"); break;
+        case '}': append_lit (&dest, &d, &len, "&#125;"); break;
         default:
-          if (*s >= 127) // maybe encodings, no utf8 (see htmlwescape)
+          if (c >= 127) /* maybe encodings, no utf8 (see htmlwescape) */
             {
-              sprintf (d, "&#x%X;", *s); // 4 + 4
+              /* Enough for "&#x%X;" with up to 2 hex bytes + NUL */
+              ensure_space (&dest, &d, &len, 16);
+              sprintf (d, "&#x%X;", (unsigned int)c);
               d += strlen (d);
             }
-          else if (*s >= 20)
-            *d++ = *s;
+          else if (c >= 20)
+            {
+              ensure_space (&dest, &d, &len, 1);
+              *d++ = (char)c;
+            }
         }
     }
+
   *d = 0;
   return dest;
 }
@@ -71,47 +109,52 @@ htmlescape (const char *restrict src, const int cp)
 char * ATTRIBUTE_MALLOC
 htmlwescape (BITCODE_TU wstr)
 {
-  int len = 0;
+  size_t len = 0;
   char *dest, *d;
   BITCODE_TU tmp = wstr;
   BITCODE_RS c;
 
   if (!wstr)
     return NULL;
+
   while ((c = *tmp++))
     len++;
+
   len += 16;
-  d = dest = malloc (len);
+  dest = d = malloc (len);
+  if (!dest)
+    return NULL;
 
-  while (*wstr++)
+  /* Never read past end of input; do not use strcat into non-NUL-terminated
+     buffer.
+   */
+  while ((c = *wstr++))
     {
-      const int off = d - dest;
-      if (off >= len - 8)
-        {
-          len += 16;
-          dest = realloc (dest, len);
-          d = dest + off;
-        }
-      switch (*wstr)
+      switch (c)
         {
-        case 34: strcat (d, "&quot;"); d += 6; break;
-        case 39: strcat (d, "&#39;"); d += 5; break;
-        case 38: strcat (d, "&amp;"); d += 5; break;
-        case 60: strcat (d, "&lt;"); d += 4; break;
-        case 62: strcat (d, "&gt;"); d += 4; break;
-        case 96: strcat (d, "&#96;"); d += 5; break;
-        case 123: strcat (d, "&#123;"); d += 6; break;
-        case 125: strcat (d, "&#125;"); d += 6; break;
+        case 34: append_lit (&dest, &d, &len, "&quot;"); break;
+        case 39: append_lit (&dest, &d, &len, "&#39;"); break;
+        case 38: append_lit (&dest, &d, &len, "&amp;"); break;
+        case 60: append_lit (&dest, &d, &len, "&lt;"); break;
+        case 62: append_lit (&dest, &d, &len, "&gt;"); break;
+        case 96: append_lit (&dest, &d, &len, "&#96;"); break;
+        case 123: append_lit (&dest, &d, &len, "&#123;"); break;
+        case 125: append_lit (&dest, &d, &len, "&#125;"); break;
         default:
-          if (*wstr >= 127) // utf8 encodings
+          if (c >= 127) /* utf8 encodings */
             {
-              sprintf (d, "&#x%X;", *wstr);
+              ensure_space (&dest, &d, &len, 16);
+              sprintf (d, "&#x%X;", (unsigned int)c);
               d += strlen (d);
             }
-          else if (*wstr >= 20)
-            *d++ = *wstr;
+          else if (c >= 20)
+            {
+              ensure_space (&dest, &d, &len, 1);
+              *d++ = (char)c;
+            }
         }
     }
+
   *d = 0;
   return dest;
 }