diff --git a/src/md4c.c b/src/md4c.c
index 9e720be..4554ae7 100644
--- a/src/md4c.c
+++ b/src/md4c.c
@@ -5707,6 +5707,16 @@ md_analyze_line(MD_CTX* ctx, OFF beg, OFF* p_end,
     OFF hr_killer = 0;
     int ret = 0;
 
+    /* MD_LINE_ANALYSIS contains bit-fields. Assigning to a single bit-field
+     * may compile into a read-modify-write of the whole storage unit, which
+     * would read any previously uninitialized bits (e.g. the adjacent
+     * data field). Ensure the whole struct is initialized before we start
+     * filling it.
+     *
+     * This prevents MemorySanitizer reports on malformed inputs.
+     */
+    memset(line, 0, sizeof(*line));
+
     line->indent = md_line_indentation(ctx, total_indent, off, &off);
     total_indent += line->indent;
     line->beg = off;
@@ -6316,8 +6326,32 @@ md_parse(const MD_CHAR* text, MD_SIZE size, const MD_PARSER* parser, void* userd
     }
 
     /* Setup context structure. */
+    /* Some code paths historically relied on the input being NUL-terminated
+     * (e.g. fast scans using C string routines). The public API, however,
+     * only provides (text,size) and callers often pass non-terminated buffers
+     * (like data read by fread()). To avoid any accidental reads past the
+     * provided size (which MemorySanitizer reports as use-of-uninitialized
+     * value and can lead to DoS), work with a padded, zero-terminated copy.
+     */
+    const MD_CHAR* input_padded = text;
+    MD_CHAR* input_copy = NULL;
+    if(size > 0) {
+        /* Add a few extra zeroed code units as a safety margin. */
+        const size_t pad = 8;
+        /* Guard against overflow in the multiplication below. */
+        if((size_t)size + pad > (size_t)size) {
+            size_t alloc_units = (size_t)size + pad;
+            input_copy = (MD_CHAR*) malloc(alloc_units * sizeof(MD_CHAR));
+            if(input_copy != NULL) {
+                memset(input_copy, 0, alloc_units * sizeof(MD_CHAR));
+                memcpy(input_copy, text, (size_t)size * sizeof(MD_CHAR));
+                input_padded = input_copy;
+            }
+        }
+    }
+
     memset(&ctx, 0, sizeof(MD_CTX));
-    ctx.text = text;
+    ctx.text = input_padded;
     ctx.size = size;
     memcpy(&ctx.parser, parser, sizeof(MD_PARSER));
     ctx.userdata = userdata;
@@ -6343,6 +6377,7 @@ md_parse(const MD_CHAR* text, MD_SIZE size, const MD_PARSER* parser, void* userd
     free(ctx.marks);
     free(ctx.block_bytes);
     free(ctx.containers);
+    free(input_copy);
 
     return ret;
 }