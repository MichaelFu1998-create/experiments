diff --git a/src/filters/reframe_mpgvid.c b/src/filters/reframe_mpgvid.c
index 328db28..4bacc44 100644
--- a/src/filters/reframe_mpgvid.c
+++ b/src/filters/reframe_mpgvid.c
@@ -546,7 +546,14 @@ GF_Err mpgviddmx_process(GF_Filter *filter)
 	byte_offset = gf_filter_pck_get_byte_offset(pck);
 
 	start = data;
-	remain = pck_size;
+	/* pck_size is u32 but remain is signed. Ensure we never end up with a
+	   negative remain through signed overflow, as remain is used as memcpy size. */
+	if (pck_size > 0x7FFFFFFF) {
+		GF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, ("[MPGVid] Packet too large (%u bytes), dropping\n", pck_size));
+		gf_filter_pid_drop_packet(ctx->ipid);
+		return GF_OK;
+	}
+	remain = (s32) pck_size;
 
 	//input pid sets some timescale - we flushed pending data , update cts
 	if (!ctx->resume_from && ctx->timescale) {
@@ -601,15 +608,29 @@ GF_Err mpgviddmx_process(GF_Filter *filter)
 
 		//resume from data copied internally
 		if (ctx->hdr_store_size) {
-			assert(ctx->resume_from <= ctx->hdr_store_size);
-			start = data = ctx->hdr_store + ctx->resume_from;
-			remain = pck_size = ctx->hdr_store_size - ctx->resume_from;
+			/* Be robust to inconsistent resume offsets (may happen when data is
+			   reaggregated between pause/resume). */
+			if (ctx->resume_from > ctx->hdr_store_size) {
+				GF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, ("[MPGVid] Invalid resume offset %u (store size %u), resetting\n", ctx->resume_from, ctx->hdr_store_size));
+				ctx->resume_from = 0;
+			} else {
+				start = (u8 *) (ctx->hdr_store + ctx->resume_from);
+				data = ctx->hdr_store;
+				pck_size = ctx->hdr_store_size - ctx->resume_from;
+				remain = (s32) pck_size;
+				ctx->resume_from = 0;
+			}
 		} else {
-			assert(remain >= (s32) ctx->resume_from);
-			start += ctx->resume_from;
-			remain -= ctx->resume_from;
+			/* resume_from is unsigned, avoid signed wrap in remain */
+			if ((u32) remain < ctx->resume_from) {
+				GF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, ("[MPGVid] Invalid resume offset %u (packet size %d), resetting\n", ctx->resume_from, remain));
+				ctx->resume_from = 0;
+			} else {
+				start += ctx->resume_from;
+				remain -= (s32) ctx->resume_from;
+				ctx->resume_from = 0;
+			}
 		}
-		ctx->resume_from = 0;
 	}
 
 	if (!ctx->bs) {
@@ -639,9 +660,13 @@ GF_Err mpgviddmx_process(GF_Filter *filter)
 		Bool copy_last_bytes = GF_FALSE;
 
 		//not enough bytes to parse start code
-		if (remain<5) {
-			memcpy(ctx->hdr_store, start, remain);
-			ctx->bytes_in_header = remain;
+		if (remain < 5) {
+			if (remain > 0) {
+				memcpy(ctx->hdr_store, start, (size_t) remain);
+				ctx->bytes_in_header = (u32) remain;
+			} else {
+				ctx->bytes_in_header = 0;
+			}
 			break;
 		}
 		current = -1;
@@ -649,10 +674,17 @@ GF_Err mpgviddmx_process(GF_Filter *filter)
 		//we have some potential bytes of a start code in the store, copy some more bytes and check if valid start code.
 		//if not, dispatch these bytes as continuation of the data
 		if (ctx->bytes_in_header) {
+			/* bytes_in_header should stay below 8, otherwise 8 - bytes_in_header underflows */
+			if (ctx->bytes_in_header >= 8) {
+				GF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, ("[MPGVid] Invalid header byte count %u, resetting\n", ctx->bytes_in_header));
+				ctx->bytes_in_header = 0;
+				current = -1;
+			} else {
 
 			memcpy(ctx->hdr_store + ctx->bytes_in_header, start, 8 - ctx->bytes_in_header);
 			current = mpgviddmx_next_start_code(ctx->hdr_store, 8);
 
+			}
 			//no start code in stored buffer
 			if ((current<0) || (current >= (s32) ctx->bytes_in_header) )  {
 				if (ctx->opid) {