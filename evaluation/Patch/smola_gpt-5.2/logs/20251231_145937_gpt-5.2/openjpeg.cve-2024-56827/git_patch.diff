diff --git a/build/src/bin/common/opj_apps_config.h b/build/src/bin/common/opj_apps_config.h
new file mode 100644
index 0000000..419ff2c
--- /dev/null
+++ b/build/src/bin/common/opj_apps_config.h
@@ -0,0 +1,13 @@
+#include "opj_config_private.h"
+
+/* create opj_apps_config.h for CMake */
+
+/* #undef OPJ_HAVE_LIBPNG */
+/* #undef OPJ_HAVE_PNG_H */
+/* #undef OPJ_HAVE_LIBTIFF */
+/* #undef OPJ_HAVE_TIFF_H */
+
+/* #undef OPJ_HAVE_LIBLCMS1 */
+/* #undef OPJ_HAVE_LIBLCMS2 */
+/* #undef OPJ_HAVE_LCMS1_H */
+/* #undef OPJ_HAVE_LCMS2_H */
diff --git a/build/src/lib/openjp2/opj_config.h b/build/src/lib/openjp2/opj_config.h
new file mode 100644
index 0000000..e495440
--- /dev/null
+++ b/build/src/lib/openjp2/opj_config.h
@@ -0,0 +1,14 @@
+#ifndef OPJ_CONFIG_H_INCLUDED
+#define OPJ_CONFIG_H_INCLUDED
+
+/* create opj_config.h for CMake */
+
+/*--------------------------------------------------------------------------*/
+/* OpenJPEG Versioning                                                      */
+
+/* Version number. */
+#define OPJ_VERSION_MAJOR 2
+#define OPJ_VERSION_MINOR 5
+#define OPJ_VERSION_BUILD 2
+
+#endif
diff --git a/build/src/lib/openjp2/opj_config_private.h b/build/src/lib/openjp2/opj_config_private.h
new file mode 100644
index 0000000..81a15df
--- /dev/null
+++ b/build/src/lib/openjp2/opj_config_private.h
@@ -0,0 +1,50 @@
+/* create opj_config_private.h for CMake */
+
+#define OPJ_PACKAGE_VERSION "2.5.2"
+
+/* Not used by openjp2*/
+/*#define HAVE_MEMORY_H 1*/
+/*#define HAVE_STDLIB_H 1*/
+/*#define HAVE_STRINGS_H 1*/
+/*#define HAVE_STRING_H 1*/
+/*#define HAVE_SYS_STAT_H 1*/
+/*#define HAVE_SYS_TYPES_H 1 */
+/*#define HAVE_UNISTD_H 1*/
+/*#define HAVE_INTTYPES_H 1 */
+/*#define HAVE_STDINT_H 1 */
+
+/* #undef _LARGEFILE_SOURCE */
+/* #undef _LARGE_FILES */
+/* #undef _FILE_OFFSET_BITS */
+#define OPJ_HAVE_FSEEKO ON
+
+/* find whether or not have <malloc.h> */
+#define OPJ_HAVE_MALLOC_H
+/* check if function `aligned_alloc` exists */
+/* #undef OPJ_HAVE_ALIGNED_ALLOC */
+/* check if function `_aligned_malloc` exists */
+/* #undef OPJ_HAVE__ALIGNED_MALLOC */
+/* check if function `memalign` exists */
+#define OPJ_HAVE_MEMALIGN
+/* check if function `posix_memalign` exists */
+#define OPJ_HAVE_POSIX_MEMALIGN
+
+#if !defined(_POSIX_C_SOURCE)
+#if defined(OPJ_HAVE_FSEEKO) || defined(OPJ_HAVE_POSIX_MEMALIGN)
+/* Get declarations of fseeko, ftello, posix_memalign. */
+#define _POSIX_C_SOURCE 200112L
+#endif
+#endif
+
+/* Byte order.  */
+/* All compilers that support Mac OS X define either __BIG_ENDIAN__ or
+__LITTLE_ENDIAN__ to match the endianness of the architecture being
+compiled for. This is not necessarily the same as the architecture of the
+machine doing the building. In order to support Universal Binaries on
+Mac OS X, we prefer those defines to decide the endianness.
+On other platforms we use the result of the TRY_RUN. */
+#if !defined(__APPLE__)
+/* #undef OPJ_BIG_ENDIAN */
+#elif defined(__BIG_ENDIAN__)
+# define OPJ_BIG_ENDIAN
+#endif
diff --git a/src/lib/openjp2/j2k.c b/src/lib/openjp2/j2k.c
index 7dc389f..7b5526c 100644
--- a/src/lib/openjp2/j2k.c
+++ b/src/lib/openjp2/j2k.c
@@ -8424,6 +8424,13 @@ static OPJ_BOOL opj_j2k_add_tlmarker(OPJ_UINT32 tileno,
     assert(cstr_index != 00);
     assert(cstr_index->tile_index != 00);
 
+    /* Robustness against invalid/malicious codestreams: tileno can be
+     * corrupted and would cause out-of-bounds access on tile_index[]. */
+    if (cstr_index == NULL || cstr_index->tile_index == NULL ||
+            tileno >= cstr_index->nb_of_tiles) {
+        return OPJ_FALSE;
+    }
+
     /* expand the list? */
     if ((cstr_index->tile_index[tileno].marknum + 1) >
             cstr_index->tile_index[tileno].maxmarknum) {
@@ -8457,7 +8464,16 @@ static OPJ_BOOL opj_j2k_add_tlmarker(OPJ_UINT32 tileno,
         OPJ_UINT32 l_current_tile_part = cstr_index->tile_index[tileno].current_tpsno;
 
         if (cstr_index->tile_index[tileno].tp_index) {
-            cstr_index->tile_index[tileno].tp_index[l_current_tile_part].start_pos = pos;
+            /* current_tpsno comes from TPSot and might be outside the
+             * allocated tp_index[] range (for example if the SOT header is
+             * inconsistent with the TLM marker segments). */
+            OPJ_UINT32 l_max_tp = cstr_index->tile_index[tileno].current_nb_tps;
+            if (l_max_tp == 0) {
+                l_max_tp = cstr_index->tile_index[tileno].nb_tps;
+            }
+            if (l_current_tile_part < l_max_tp) {
+                cstr_index->tile_index[tileno].tp_index[l_current_tile_part].start_pos = pos;
+            }
         }
 
     }