diff --git a/src/filters/load_text.c b/src/filters/load_text.c
index 6373398..0af7558 100644
--- a/src/filters/load_text.c
+++ b/src/filters/load_text.c
@@ -310,6 +310,14 @@ char *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32 unicod
 	char *sOK;
 	char szLineConv[2048];
 	unsigned short *sptr;
+	u32 copy_size;
+
+	/*
+	 * The caller may pass a pointer within a larger buffer (eg szLine+nb_empty)
+	 * with a reduced lineSize. Always bound any copy back to the destination
+	 * buffer size.
+	 */
+	copy_size = lineSize ? lineSize : 1;
 
 	memset(szLine, 0, sizeof(char)*lineSize);
 	sOK = gf_fgets(szLine, lineSize, txt_in);
@@ -378,7 +386,7 @@ char *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32 unicod
 			j = GF_ARRAY_LENGTH(szLineConv) -1 ;
 		}
 		szLineConv[j] = 0;
-		strcpy(szLine, szLineConv);
+		gf_strlcpy(szLine, szLineConv, copy_size);
 		return sOK;
 	}
 
@@ -399,10 +407,12 @@ char *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32 unicod
 		}
 	}
 	sptr = (u16 *)szLine;
-	i = gf_utf8_wcstombs(szLineConv, 2048, (const unsigned short **) &sptr);
+	i = gf_utf8_wcstombs(szLineConv, GF_ARRAY_LENGTH(szLineConv), (const unsigned short **) &sptr);
 	if (i == GF_UTF8_FAIL) i = 0;
+	if (i >= GF_ARRAY_LENGTH(szLineConv))
+		i = GF_ARRAY_LENGTH(szLineConv) - 1;
 	szLineConv[i] = 0;
-	strcpy(szLine, szLineConv);
+	gf_strlcpy(szLine, szLineConv, copy_size);
 	/*this is ugly indeed: since input is UTF16-LE, there are many chances the gf_fgets never reads the \0 after a \n*/
 	if (unicode_type==3) gf_fgetc(txt_in);
 	return sOK;