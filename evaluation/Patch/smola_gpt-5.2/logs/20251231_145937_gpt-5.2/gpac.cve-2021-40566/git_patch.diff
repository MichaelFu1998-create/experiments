diff --git a/src/filters/reframe_mpgvid.c b/src/filters/reframe_mpgvid.c
index 308546f..5172ca3 100644
--- a/src/filters/reframe_mpgvid.c
+++ b/src/filters/reframe_mpgvid.c
@@ -27,6 +27,7 @@
 #include <gpac/constants.h>
 #include <gpac/filters.h>
 #include <gpac/internal/media_dev.h>
+#include <stddef.h>
 
 #ifndef GPAC_DISABLE_AV_PARSERS
 
@@ -804,13 +805,34 @@ GF_Err mpgviddmx_process(GF_Filter *filter)
 				e = gf_m4v_parse_config(ctx->vparser, &ctx->dsi);
 				//not enough data, accumulate until we can parse the full header
 				if (e==GF_EOS) {
+					/*
+						When accumulating header data, we may already have re-assigned the packet
+						data pointer to ctx->hdr_store (see aggregation logic earlier in this
+						function). If we then grow ctx->hdr_store using realloc(), the previous
+						buffer can be freed and 'data' becomes dangling, causing a heap-use-after-
+						free in the memcpy below (see ASan report).
+						Keep the copy source as an offset from hdr_store and rebase it after
+						realloc.
+					*/
 					if (vosh_start<0) vosh_start = 0;
-					if (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {
-						ctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - vosh_start);
-						ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);
+					{
+						char *copy_src = data + (u32) vosh_start;
+						ptrdiff_t copy_src_off = 0;
+						Bool copy_src_in_store = GF_FALSE;
+
+						if (ctx->hdr_store && (copy_src >= ctx->hdr_store) && (copy_src < ctx->hdr_store + ctx->hdr_store_alloc)) {
+							copy_src_in_store = GF_TRUE;
+							copy_src_off = copy_src - ctx->hdr_store;
+						}
+						if (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {
+							ctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - (u32) vosh_start);
+							ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);
+							if (!ctx->hdr_store) return GF_OUT_OF_MEM;
+							if (copy_src_in_store) copy_src = ctx->hdr_store + copy_src_off;
+						}
+						memcpy(ctx->hdr_store + ctx->hdr_store_size, copy_src, (size_t) (pck_size - vosh_start) );
+						ctx->hdr_store_size += pck_size - (u32) vosh_start;
 					}
-					memcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );
-					ctx->hdr_store_size += pck_size - (u32) vosh_start;
 					gf_filter_pid_drop_packet(ctx->ipid);
 					return GF_OK;
 				} else if (e != GF_OK) {
@@ -843,15 +865,29 @@ GF_Err mpgviddmx_process(GF_Filter *filter)
 				ctx->dsi.VideoPL = PL;
 				//not enough data, accumulate until we can parse the full header
 				if (e==GF_EOS) {
+					/* See comment in MPEG-1/2 branch: data may point inside hdr_store and
+					   gf_realloc() may free it, so rebase copy source after realloc. */
 					if (vosh_start<0) vosh_start = 0;
-					if (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {
-						ctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - (u32) vosh_start);
-						ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);
+					{
+						char *copy_src = data + (u32) vosh_start;
+						ptrdiff_t copy_src_off = 0;
+						Bool copy_src_in_store = GF_FALSE;
+
+						if (ctx->hdr_store && (copy_src >= ctx->hdr_store) && (copy_src < ctx->hdr_store + ctx->hdr_store_alloc)) {
+							copy_src_in_store = GF_TRUE;
+							copy_src_off = copy_src - ctx->hdr_store;
+						}
+						if (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {
+							ctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - (u32) vosh_start);
+							ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);
+							if (!ctx->hdr_store) return GF_OUT_OF_MEM;
+							if (copy_src_in_store) copy_src = ctx->hdr_store + copy_src_off;
+						}
+						memcpy(ctx->hdr_store + ctx->hdr_store_size, copy_src, (size_t) (pck_size - vosh_start) );
+						ctx->hdr_store_size += pck_size - (u32) vosh_start;
 					}
-					memcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );
-					ctx->hdr_store_size += pck_size - (u32) vosh_start;
-					gf_filter_pid_drop_packet(ctx->ipid);
-					return GF_OK;
+						gf_filter_pid_drop_packet(ctx->ipid);
+						return GF_OK;
 				} else if (e != GF_OK) {
 					GF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, ("[MPGVid] Failed to parse VOS header: %s\n", gf_error_to_string(e) ));
 				} else {