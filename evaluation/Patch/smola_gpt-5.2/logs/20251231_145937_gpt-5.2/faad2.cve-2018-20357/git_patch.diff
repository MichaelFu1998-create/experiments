diff --git a/config.h b/config.h
new file mode 100644
index 0000000..be48641
--- /dev/null
+++ b/config.h
@@ -0,0 +1,136 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Define if building universal (internal helper macro) */
+/* #undef AC_APPLE_UNIVERSAL_BUILD */
+
+/* Define if you want to use libfaad together with Digital Radio Mondiale
+   (DRM) */
+/* #undef DRM */
+
+/* Define if you want support for Digital Radio Mondiale (DRM) parametric
+   stereo */
+/* #undef DRM_PS */
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define HAVE_DLFCN_H 1
+
+/* Define to 1 if you have the <errno.h> header file. */
+#define HAVE_ERRNO_H 1
+
+/* Define if needed */
+/* #undef HAVE_FLOAT32_T */
+
+/* Define to 1 if you have the <float.h> header file. */
+#define HAVE_FLOAT_H 1
+
+/* Define to 1 if you have the `getpwuid' function. */
+#define HAVE_GETPWUID 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define if you have the IOKit API */
+/* #undef HAVE_IOKIT_IOKITLIB_H */
+
+/* Define to 1 if you have the <limits.h> header file. */
+#define HAVE_LIMITS_H 1
+
+/* Define if you have C99's lrintf function. */
+#define HAVE_LRINTF 1
+
+/* Define to 1 if you have the <mathf.h> header file. */
+/* #undef HAVE_MATHF_H */
+
+/* Define to 1 if you have the `memcpy' function. */
+#define HAVE_MEMCPY 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the `strchr' function. */
+#define HAVE_STRCHR 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the `strsep' function. */
+#define HAVE_STRSEP 1
+
+/* Define to 1 if you have the <sysfs/libsysfs.h> header file. */
+/* #undef HAVE_SYSFS_LIBSYSFS_H */
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#define HAVE_SYS_TIME_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to the sub-directory where libtool stores uninstalled libraries. */
+#define LT_OBJDIR ".libs/"
+
+/* Name of package */
+#define PACKAGE "faad2"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT ""
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "faad2"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "faad2 2.8.8"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "faad2"
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL ""
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "2.8.8"
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
+#define TIME_WITH_SYS_TIME 1
+
+/* Version number of package */
+#define VERSION "2.8.8"
+
+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
+   significant byte first (like Motorola and SPARC, unlike Intel). */
+#if defined AC_APPLE_UNIVERSAL_BUILD
+# if defined __BIG_ENDIAN__
+#  define WORDS_BIGENDIAN 1
+# endif
+#else
+# ifndef WORDS_BIGENDIAN
+/* #  undef WORDS_BIGENDIAN */
+# endif
+#endif
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
+/* #undef inline */
+#endif
+
+/* Define to `long int' if <sys/types.h> does not define. */
+/* #undef off_t */
diff --git a/libfaad/sbr_dec.c b/libfaad/sbr_dec.c
index 0705ddd..2d77c33 100644
--- a/libfaad/sbr_dec.c
+++ b/libfaad/sbr_dec.c
@@ -301,11 +301,22 @@ static uint8_t sbr_process_channel(sbr_info *sbr, real_t *channel_buf, qmf_t X[M
 {
     int16_t k, l;
     uint8_t ret = 0;
+    uint8_t ntsr;
 
 #ifdef SBR_LOW_POWER
     ALIGN real_t deg[64];
 #endif
 
+    /* Defensive checks: corrupted bitstreams can lead to uninitialised/invalid state */
+    if (sbr == NULL || channel_buf == NULL)
+        return 20;
+
+    if (ch > 1 || sbr->qmfa[ch] == NULL)
+        return 22;
+
+    /* Clamp to local buffer size to avoid out-of-bounds access on bitstream errors */
+    ntsr = (sbr->numTimeSlotsRate > MAX_NTSR) ? MAX_NTSR : sbr->numTimeSlotsRate;
+
 #ifdef DRM
     if (sbr->Is_DRM_SBR)
     {
@@ -317,19 +328,6 @@ static uint8_t sbr_process_channel(sbr_info *sbr, real_t *channel_buf, qmf_t X[M
     }
 #endif
 
-
-//#define PRE_QMF_PRINT
-#ifdef PRE_QMF_PRINT
-    {
-        int i;
-        for (i = 0; i < 1024; i++)
-        {
-            printf("%d\n", channel_buf[i]);
-        }
-    }
-#endif
-
-
     /* subband analysis */
     if (dont_process)
         sbr_qmf_analysis_32(sbr, sbr->qmfa[ch], channel_buf, sbr->Xsbr[ch], sbr->tHFGen, 32);
@@ -338,34 +336,20 @@ static uint8_t sbr_process_channel(sbr_info *sbr, real_t *channel_buf, qmf_t X[M
 
     if (!dont_process)
     {
-#if 1
-        /* insert high frequencies here */
         /* hf generation using patching */
         hf_generation(sbr, sbr->Xsbr[ch], sbr->Xsbr[ch]
 #ifdef SBR_LOW_POWER
             ,deg
 #endif
             ,ch);
-#endif
-
-#if 0 //def SBR_LOW_POWER
-        for (l = sbr->t_E[ch][0]; l < sbr->t_E[ch][sbr->L_E[ch]]; l++)
-        {
-            for (k = 0; k < sbr->kx; k++)
-            {
-                QMF_RE(sbr->Xsbr[ch][sbr->tHFAdj + l][k]) = 0;
-            }
-        }
-#endif
 
-#if 1
         /* hf adjustment */
         ret = hf_adjustment(sbr, sbr->Xsbr[ch]
 #ifdef SBR_LOW_POWER
             ,deg
 #endif
             ,ch);
-#endif
+
         if (ret > 0)
         {
             dont_process = 1;
@@ -374,13 +358,26 @@ static uint8_t sbr_process_channel(sbr_info *sbr, real_t *channel_buf, qmf_t X[M
 
     if ((sbr->just_seeked != 0) || dont_process)
     {
-        for (l = 0; l < sbr->numTimeSlotsRate; l++)
+        for (l = 0; l < ntsr; l++)
         {
+            int16_t src_l = (int16_t)sbr->tHFAdj + l;
+            if (src_l < 0 || src_l >= MAX_NTSRHFG)
+            {
+                for (k = 0; k < 64; k++)
+                {
+                    QMF_RE(X[l][k]) = 0;
+#ifndef SBR_LOW_POWER
+                    QMF_IM(X[l][k]) = 0;
+#endif
+                }
+                continue;
+            }
+
             for (k = 0; k < 32; k++)
             {
-                QMF_RE(X[l][k]) = QMF_RE(sbr->Xsbr[ch][l + sbr->tHFAdj][k]);
+                QMF_RE(X[l][k]) = QMF_RE(sbr->Xsbr[ch][src_l][k]);
 #ifndef SBR_LOW_POWER
-                QMF_IM(X[l][k]) = QMF_IM(sbr->Xsbr[ch][l + sbr->tHFAdj][k]);
+                QMF_IM(X[l][k]) = QMF_IM(sbr->Xsbr[ch][src_l][k]);
 #endif
             }
             for (k = 32; k < 64; k++)
@@ -392,9 +389,12 @@ static uint8_t sbr_process_channel(sbr_info *sbr, real_t *channel_buf, qmf_t X[M
             }
         }
     } else {
-        for (l = 0; l < sbr->numTimeSlotsRate; l++)
+        for (l = 0; l < ntsr; l++)
         {
             uint8_t kx_band, M_band, bsco_band;
+            int16_t kx_i, M_i, bsco_i;
+            int16_t k_max1, k_max2;
+            int16_t src_l;
 
             if (l < sbr->t_E[ch][0])
             {
@@ -407,37 +407,71 @@ static uint8_t sbr_process_channel(sbr_info *sbr, real_t *channel_buf, qmf_t X[M
                 bsco_band = sbr->bsco;
             }
 
+            /* Guard against invalid band values due to bit errors */
+            kx_i = (kx_band > 64) ? 64 : kx_band;
+            M_i = (M_band > 64) ? 64 : M_band;
+            bsco_i = (bsco_band > 64) ? 64 : bsco_band;
+
+            if (kx_i < 0) kx_i = 0;
+            if (M_i < 0) M_i = 0;
+            if (bsco_i < 0) bsco_i = 0;
+
+            if (kx_i > 64) kx_i = 64;
+            if (bsco_i > (64 - kx_i)) bsco_i = (64 - kx_i);
+            if (M_i > (64 - kx_i)) M_i = (64 - kx_i);
+
+            k_max1 = kx_i + bsco_i;
+            k_max2 = kx_i + M_i;
+            if (k_max1 > 64) k_max1 = 64;
+            if (k_max2 > 64) k_max2 = 64;
+
+            src_l = (int16_t)sbr->tHFAdj + l;
+            if (src_l < 0 || src_l >= MAX_NTSRHFG)
+            {
+                for (k = 0; k < 64; k++)
+                {
+                    QMF_RE(X[l][k]) = 0;
 #ifndef SBR_LOW_POWER
-            for (k = 0; k < kx_band + bsco_band; k++)
+                    QMF_IM(X[l][k]) = 0;
+#endif
+                }
+                continue;
+            }
+
+#ifndef SBR_LOW_POWER
+            for (k = 0; k < k_max1; k++)
             {
-                QMF_RE(X[l][k]) = QMF_RE(sbr->Xsbr[ch][l + sbr->tHFAdj][k]);
-                QMF_IM(X[l][k]) = QMF_IM(sbr->Xsbr[ch][l + sbr->tHFAdj][k]);
+                QMF_RE(X[l][k]) = QMF_RE(sbr->Xsbr[ch][src_l][k]);
+                QMF_IM(X[l][k]) = QMF_IM(sbr->Xsbr[ch][src_l][k]);
             }
-            for (k = kx_band + bsco_band; k < kx_band + M_band; k++)
+            for (k = k_max1; k < k_max2; k++)
             {
-                QMF_RE(X[l][k]) = QMF_RE(sbr->Xsbr[ch][l + sbr->tHFAdj][k]);
-                QMF_IM(X[l][k]) = QMF_IM(sbr->Xsbr[ch][l + sbr->tHFAdj][k]);
+                QMF_RE(X[l][k]) = QMF_RE(sbr->Xsbr[ch][src_l][k]);
+                QMF_IM(X[l][k]) = QMF_IM(sbr->Xsbr[ch][src_l][k]);
             }
-            for (k = max(kx_band + bsco_band, kx_band + M_band); k < 64; k++)
+            for (k = max(k_max1, k_max2); k < 64; k++)
             {
                 QMF_RE(X[l][k]) = 0;
                 QMF_IM(X[l][k]) = 0;
             }
 #else
-            for (k = 0; k < kx_band + bsco_band; k++)
+            for (k = 0; k < k_max1; k++)
             {
-                QMF_RE(X[l][k]) = QMF_RE(sbr->Xsbr[ch][l + sbr->tHFAdj][k]);
+                QMF_RE(X[l][k]) = QMF_RE(sbr->Xsbr[ch][src_l][k]);
             }
-            for (k = kx_band + bsco_band; k < min(kx_band + M_band, 63); k++)
+            for (k = k_max1; k < min(k_max2, 63); k++)
             {
-                QMF_RE(X[l][k]) = QMF_RE(sbr->Xsbr[ch][l + sbr->tHFAdj][k]);
+                QMF_RE(X[l][k]) = QMF_RE(sbr->Xsbr[ch][src_l][k]);
             }
-            for (k = max(kx_band + bsco_band, kx_band + M_band); k < 64; k++)
+            for (k = max(k_max1, k_max2); k < 64; k++)
             {
                 QMF_RE(X[l][k]) = 0;
             }
-            QMF_RE(X[l][kx_band - 1 + bsco_band]) +=
-                QMF_RE(sbr->Xsbr[ch][l + sbr->tHFAdj][kx_band - 1 + bsco_band]);
+            if (kx_i > 0 && (kx_i - 1 + bsco_i) < 64)
+            {
+                QMF_RE(X[l][kx_i - 1 + bsco_i]) +=
+                    QMF_RE(sbr->Xsbr[ch][src_l][kx_i - 1 + bsco_i]);
+            }
 #endif
         }
     }
@@ -445,6 +479,7 @@ static uint8_t sbr_process_channel(sbr_info *sbr, real_t *channel_buf, qmf_t X[M
     return ret;
 }
 
+
 uint8_t sbrDecodeCoupleFrame(sbr_info *sbr, real_t *left_chan, real_t *right_chan,
                              const uint8_t just_seeked, const uint8_t downSampledSBR)
 {
diff --git a/libfaad/sbr_hfadj.c b/libfaad/sbr_hfadj.c
index 3f310b8..dc87bf2 100644
--- a/libfaad/sbr_hfadj.c
+++ b/libfaad/sbr_hfadj.c
@@ -61,6 +61,26 @@ uint8_t hf_adjustment(sbr_info *sbr, qmf_t Xsbr[MAX_NTSRHFG][64]
     ALIGN sbr_hfadj_info adj = {{{0}}};
     uint8_t ret = 0;
 
+    /* Sanity checks: corrupted bitstreams can make SBR parameters invalid.
+     * Guard against out-of-bounds access in the HF adjustment tools. */
+    if (sbr == NULL)
+        return 1;
+
+    if (ch > 1)
+        return 1;
+
+    /* L_E is used as first index into fixed-size [MAX_L_E][MAX_M] arrays */
+    if (sbr->L_E[ch] <= 0 || sbr->L_E[ch] > MAX_L_E)
+        return 1;
+
+    /* These are used as indices into fixed-size tables/arrays */
+    if (sbr->bs_limiter_bands > 3 || sbr->bs_limiter_gains > 3)
+        return 1;
+
+    /* N_L[...] is used with k+1 indexing into f_table_lim[][k+1] */
+    if (sbr->N_L[sbr->bs_limiter_bands] > 63)
+        return 1;
+
     if (sbr->bs_frame_class[ch] == FIXFIX)
     {
         sbr->l_A[ch] = -1;
@@ -78,6 +98,15 @@ uint8_t hf_adjustment(sbr_info *sbr, qmf_t Xsbr[MAX_NTSRHFG][64]
 
     ret = estimate_current_envelope(sbr, &adj, Xsbr, ch);
     if (ret > 0)
+
+    /* estimate_current_envelope() may update SBR grid values; re-validate bounds */
+    if (sbr->L_E[ch] <= 0 || sbr->L_E[ch] > MAX_L_E)
+        return 1;
+    if (sbr->M > MAX_M)
+        return 1;
+    if (sbr->kx > 64)
+        return 1;
+
         return 1;
 
     calculate_gain(sbr, &adj, ch);
@@ -486,6 +515,14 @@ static void calculate_gain(sbr_info *sbr, sbr_hfadj_info *adj, uint8_t ch)
             ml2 = sbr->f_table_lim[sbr->bs_limiter_bands][k+1];
 
 
+
+            /* Guard against corrupted band tables causing stack/array overflows */
+            if (ml1 >= MAX_M)
+                continue;
+            if (ml2 > MAX_M)
+                ml2 = MAX_M;
+            if (ml2 <= ml1)
+                continue;
             /* calculate the accumulated E_orig and E_curr over the limiter band */
             for (m = ml1; m < ml2; m++)
             {
@@ -950,6 +987,14 @@ static void calculate_gain(sbr_info *sbr, sbr_hfadj_info *adj, uint8_t ch)
             ml2 = sbr->f_table_lim[sbr->bs_limiter_bands][k+1];
 
 
+
+            /* Guard against corrupted band tables causing stack/array overflows */
+            if (ml1 >= MAX_M)
+                continue;
+            if (ml2 > MAX_M)
+                ml2 = MAX_M;
+            if (ml2 <= ml1)
+                continue;
             /* calculate the accumulated E_orig and E_curr over the limiter band */
             for (m = ml1; m < ml2; m++)
             {