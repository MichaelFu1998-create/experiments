diff --git a/examples/dwg2svg2.c b/examples/dwg2svg2.c
index 60e3888..931668d 100644
--- a/examples/dwg2svg2.c
+++ b/examples/dwg2svg2.c
@@ -332,6 +332,11 @@ output_BLOCK_HEADER (dwg_object_ref *ref)
     }
 
   _hdr = dwg_object_to_BLOCK_HEADER (hdr);
+  if (!_hdr)
+    {
+      fprintf (stderr, "Found null BLOCK_HEADER object\\n");
+      return;
+    }
   dynget (_hdr, "BLOCK_HEADER", "name", &name);
   // name = dwg_obj_block_header_get_name (_hdr, &error);
   // log_if_error ("block_header_get_name");
diff --git a/src/dynapi.c b/src/dynapi.c
index 082d178..b588342 100644
--- a/src/dynapi.c
+++ b/src/dynapi.c
@@ -7756,10 +7756,13 @@ dwg_dynapi_entity_value (void *restrict _obj, const char *restrict name,
                          const char *restrict fieldname,
                          void *restrict out, Dwg_DYNAPI_field *restrict fp)
 {
-#ifndef HAVE_NONNULL
+  /*
+   * Even when compiled with nonnull attributes (HAVE_NONNULL), callers may
+   * still pass NULL at runtime (e.g. after a failed dwg_object_to_* cast).
+   * Never dereference NULL here.
+   */
   if (!_obj || !name || !fieldname || !out)
     return false;
-#endif
   {
     int error;
     const Dwg_Object* obj = dwg_obj_generic_to_object (_obj, &error);
@@ -7784,7 +7787,8 @@ dwg_dynapi_entity_value (void *restrict _obj, const char *restrict name,
         }
       if (fp)
         memcpy (fp, f, sizeof (Dwg_DYNAPI_field));
-      memcpy (out, &((char *)_obj)[f->offset], f->size);
+      if (f->size)
+        memcpy (out, &((char *)_obj)[f->offset], f->size);
       return true;
     }
   }