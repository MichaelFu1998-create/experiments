diff --git a/src/decode_r11.c b/src/decode_r11.c
index 7db9052..e7faf6a 100644
--- a/src/decode_r11.c
+++ b/src/decode_r11.c
@@ -136,8 +136,10 @@ decode_preR13_section_hdr (const char *restrict name, Dwg_Section_Type_r11 id,
   tbl->number = bit_read_RS (dat);
   tbl->flags = bit_read_RS (dat);
   tbl->address = bit_read_RL (dat);
-  strncpy (tbl->name, name, sizeof(tbl->name) - 1);
-  tbl->name[63] = '\0';
+  /* Avoid strncpy(): it always writes the full count (here 63 bytes) and may
+     touch poisoned/redzone bytes if tbl->name is close to an allocation
+     boundary in corrupted inputs. */
+  (void)snprintf (tbl->name, sizeof (tbl->name), "%s", name ? name : "");
   LOG_TRACE ("ptr table %-8s [%2d]: size:%-4u num:%-2d (0x%lx-0x%lx) flags:0x%x\n",
              tbl->name, id, tbl->size, tbl->number, (unsigned long)tbl->address,
              (unsigned long)(tbl->address + (tbl->number * tbl->size)),
@@ -186,11 +188,23 @@ decode_preR13_section_hdr (const char *restrict name, Dwg_Section_Type_r11 id,
     default:
       LOG_ERROR ("Yet unhandled section id %d", id);
     }
-  if (tbl->number && (tbl->address + (tbl->number * tbl->size) > dat->size))
+  /* Validate table bounds using 64-bit arithmetic to avoid overflows on
+     corrupted inputs. */
+  if (tbl->size == 0 || tbl->number < 0 || tbl->address > (uint64_t)dat->size)
     {
-      LOG_ERROR ("%s.size overflow", tbl->name)
+      LOG_ERROR ("Invalid %s section header", tbl->name)
       return DWG_ERR_INVALIDDWG;
     }
+  if (tbl->number)
+    {
+      uint64_t total = (uint64_t)(uint32_t)tbl->number * (uint64_t)tbl->size;
+      uint64_t end = tbl->address + total;
+      if (end < tbl->address || end > (uint64_t)dat->size)
+        {
+          LOG_ERROR ("%s.size overflow", tbl->name)
+          return DWG_ERR_INVALIDDWG;
+        }
+    }
   return 0;
 }
 
@@ -262,14 +276,22 @@ decode_preR13_section (Dwg_Section_Type_r11 id, Bit_Chain *restrict dat,
   Dwg_Object *obj;                                                            \
   Dwg_Object_##token *_obj;                                                   \
   Dwg_Object *ctrl = dwg_get_first_object (dwg, DWG_TYPE_##token##_CONTROL);  \
-  Dwg_Object_##token##_CONTROL *_ctrl                                         \
-      = ctrl->tio.object->tio.token##_CONTROL;                                \
+  Dwg_Object_##token##_CONTROL *_ctrl;                                        \
+  if (!ctrl || !ctrl->tio.object)                                             \
+    return DWG_ERR_INVALIDDWG;                                                \
+  _ctrl = ctrl->tio.object->tio.token##_CONTROL;                              \
+  if (!_ctrl)                                                                 \
+    return DWG_ERR_INVALIDDWG;                                                \
   if (dat->byte > dat->size || (num + i) > dwg->num_objects)                  \
     return DWG_ERR_INVALIDDWG;                                                \
   flag = bit_read_RC (dat);                                                   \
   name = bit_read_TF (dat, 32);                                               \
+  if (!name)                                                                  \
+    return DWG_ERR_INVALIDDWG;                                                \
   _obj = dwg_add_##token (dwg, (const char *)name);                           \
   obj = dwg_obj_generic_to_object (_obj, &error);                             \
+  if (!obj)                                                                   \
+    { free (name); return DWG_ERR_INVALIDDWG; }                               \
   _ctrl->entries[i] = dwg_add_handleref (dwg, 2, obj->handle.value, obj);     \
   obj->size = tbl->size;                                                      \
   obj->address = pos;                                                         \
@@ -305,7 +327,11 @@ decode_preR13_section (Dwg_Section_Type_r11 id, Bit_Chain *restrict dat,
               return DWG_ERR_INVALIDDWG;
             flag = bit_read_RC (dat);
             name = bit_read_TF (dat, 32);
+            if (!name)
+              return DWG_ERR_INVALIDDWG;
             _obj = dwg_add_BLOCK_HEADER (dwg, (const char *)name);
+            if (!_obj)
+              { free (name); return DWG_ERR_INVALIDDWG; }
             _obj->flag = flag;
             LOG_TRACE ("\n-- table entry BLOCK_HEADER [%d]: 0x%lx\n", i, pos);
             LOG_TRACE ("flag: %u [RC 70]\n", flag);
@@ -318,11 +344,12 @@ decode_preR13_section (Dwg_Section_Type_r11 id, Bit_Chain *restrict dat,
                 obj->address = pos;
               }
             ctrl = dwg_get_first_object (dwg, DWG_TYPE_BLOCK_CONTROL);
-            if (ctrl)
+            if (ctrl && ctrl->tio.object && obj)
               {
                 _ctrl = ctrl->tio.object->tio.BLOCK_CONTROL;
-                _ctrl->entries[i]
-                    = dwg_add_handleref (dwg, 2, obj->handle.value, obj);
+                if (_ctrl)
+                  _ctrl->entries[i]
+                      = dwg_add_handleref (dwg, 2, obj->handle.value, obj);
               }
 
             // TODO move to => dwg.spec
@@ -785,23 +812,28 @@ decode_preR13 (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)
     {
       dat->byte = 0x3ef;
       LOG_TRACE ("@0x%lx\n", dat->byte);
-      decode_preR13_section_hdr ("UCS", SECTION_UCS, dat, dwg);
+      if (decode_preR13_section_hdr ("UCS", SECTION_UCS, dat, dwg))
+        return DWG_ERR_INVALIDDWG;
       dat->byte = 0x500;
       LOG_TRACE ("@0x%lx\n", dat->byte);
-      decode_preR13_section_hdr ("VPORT", SECTION_VPORT, dat, dwg);
+      if (decode_preR13_section_hdr ("VPORT", SECTION_VPORT, dat, dwg))
+        return DWG_ERR_INVALIDDWG;
       dat->byte = 0x512;
       LOG_TRACE ("@0x%lx\n", dat->byte);
-      decode_preR13_section_hdr ("APPID", SECTION_APPID, dat, dwg);
+      if (decode_preR13_section_hdr ("APPID", SECTION_APPID, dat, dwg))
+        return DWG_ERR_INVALIDDWG;
       dat->byte = entities_start;
     }
   if (dwg->header.numheader_vars > 160) // r11
     {
       dat->byte = 0x522;
       LOG_TRACE ("@0x%lx\n", dat->byte);
-      decode_preR13_section_hdr ("DIMSTYLE", SECTION_DIMSTYLE, dat, dwg);
+      if (decode_preR13_section_hdr ("DIMSTYLE", SECTION_DIMSTYLE, dat, dwg))
+        return DWG_ERR_INVALIDDWG;
       dat->byte = 0x69f;
       LOG_TRACE ("@0x%lx\n", dat->byte);
-      decode_preR13_section_hdr ("VX", SECTION_VX, dat, dwg);
+      if (decode_preR13_section_hdr ("VX", SECTION_VX, dat, dwg))
+        return DWG_ERR_INVALIDDWG;
       dat->byte = entities_start;
     }