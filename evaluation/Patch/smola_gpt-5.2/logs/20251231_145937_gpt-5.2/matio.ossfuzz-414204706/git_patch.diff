diff --git a/src/mat.c b/src/mat.c
index 76ba769..e817402 100644
--- a/src/mat.c
+++ b/src/mat.c
@@ -2450,14 +2450,21 @@ Mat_VarPrint(const matvar_t *matvar, int printdata)
                     break;
 #endif
                 sparse = (mat_sparse_t *)matvar->data;
+                /*
+                 * Defensive validation: sparse matrices coming from untrusted files may
+                 * have inconsistent sizes (e.g. ndata != nir) or NULL index arrays.
+                 * Mat_VarPrint must not index past allocated sparse arrays.
+                 */
                 if ( sparse == NULL || sparse->ndata == 0 || sparse->nir == 0 || sparse->njc == 0 ||
-                     sparse->data == NULL ) {
+                     sparse->data == NULL || sparse->ir == NULL || sparse->jc == NULL ) {
                     break;
                 }
                 if ( matvar->isComplex ) {
                     mat_complex_split_t *complex_data = (mat_complex_split_t *)sparse->data;
                     const char *re = (const char *)complex_data->Re;
                     const char *im = (const char *)complex_data->Im;
+                    if ( re == NULL || im == NULL )
+                        break;
                     for ( i = 0; i < (size_t)sparse->njc - 1; i++ ) {
                         for ( j = sparse->jc[i];
                               j < (size_t)sparse->jc[i + 1] && j < (size_t)sparse->ndata &&
@@ -2474,7 +2481,9 @@ Mat_VarPrint(const matvar_t *matvar, int printdata)
                     const char *data = (const char *)sparse->data;
                     for ( i = 0; i < (size_t)sparse->njc - 1; i++ ) {
                         for ( j = sparse->jc[i];
-                              j < (size_t)sparse->jc[i + 1] && j < (size_t)sparse->ndata; j++ ) {
+                              j < (size_t)sparse->jc[i + 1] && j < (size_t)sparse->ndata &&
+                              j < (size_t)sparse->nir;
+                              j++ ) {
                             printf("    (%u,%" SIZE_T_FMTSTR ")  ", sparse->ir[j] + 1, i + 1);
                             Mat_PrintNumber(matvar->data_type, data + j * stride);
                             printf("\n");