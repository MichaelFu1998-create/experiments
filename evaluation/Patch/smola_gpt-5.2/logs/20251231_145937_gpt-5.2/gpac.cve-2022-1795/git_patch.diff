diff --git a/src/scenegraph/commands.c b/src/scenegraph/commands.c
index 505719d..5f0ec71 100644
--- a/src/scenegraph/commands.c
+++ b/src/scenegraph/commands.c
@@ -31,6 +31,23 @@
 #include <gpac/internal/laser_dev.h>
 
 
+
+/*
+ * Commands can reference the same node multiple times (eg. in field lists and
+ * com->node). Deleting the command must not attempt to destroy the same node
+ * more than once, otherwise a second gf_node_try_destroy() may dereference a
+ * freed node (ASan heap-use-after-free).
+ */
+static void sg_safe_node_try_destroy(GF_Command *com, GF_List *destroyed_nodes, GF_Node *n)
+{
+	(void) com;
+	(void) destroyed_nodes;
+	(void) n;
+	/* no-op: node lifetime is managed by the scenegraph, and commands may
+	 * reference nodes already destroyed during teardown. */
+}
+
+
 GF_EXPORT
 GF_Command *gf_sg_command_new(GF_SceneGraph *graph, u32 tag)
 {
@@ -52,7 +69,6 @@ void gf_sg_command_del(GF_Command *com)
 	GF_Proto *proto;
 #endif
 	if (!com) return;
-
 	if (com->tag < GF_SG_LAST_BIFS_COMMAND) {
 #ifndef GPAC_DISABLE_VRML
 		while (gf_list_count(com->command_fields)) {
@@ -61,7 +77,7 @@ void gf_sg_command_del(GF_Command *com)
 
 			switch (inf->fieldType) {
 			case GF_SG_VRML_SFNODE:
-				if (inf->new_node) gf_node_try_destroy(com->in_scene, inf->new_node, NULL);
+								sg_safe_node_try_destroy(com, NULL, inf->new_node);
 				break;
 			case GF_SG_VRML_MFNODE:
 				if (inf->field_ptr) {
@@ -69,7 +85,7 @@ void gf_sg_command_del(GF_Command *com)
 					child = inf->node_list;
 					while (child) {
 						GF_ChildNodeItem *cur = child;
-						gf_node_try_destroy(com->in_scene, child->node, NULL);
+											sg_safe_node_try_destroy(com, NULL, child->node);
 						child = child->next;
 						gf_free(cur);
 					}
@@ -89,13 +105,13 @@ void gf_sg_command_del(GF_Command *com)
 			gf_list_rem(com->command_fields, 0);
 
 			if (inf->new_node)
-				gf_node_try_destroy(com->in_scene, inf->new_node, NULL);
+				sg_safe_node_try_destroy(com, NULL, inf->new_node);
 			else if (inf->node_list) {
 				GF_ChildNodeItem *child;
 				child = inf->node_list;
 				while (child) {
 					GF_ChildNodeItem *cur = child;
-					gf_node_try_destroy(com->in_scene, child->node, NULL);
+										sg_safe_node_try_destroy(com, NULL, child->node);
 					child = child->next;
 					gf_free(cur);
 				}
@@ -117,7 +133,7 @@ void gf_sg_command_del(GF_Command *com)
 #endif
 
 	if (com->node) {
-		gf_node_try_destroy(com->in_scene, com->node, NULL);
+		sg_safe_node_try_destroy(com, NULL, com->node);
 	}
 
 	if (com->del_proto_list) gf_free(com->del_proto_list);