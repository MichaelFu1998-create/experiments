diff --git a/applications/mp4box/fileimport.c b/applications/mp4box/fileimport.c
index a4d5c2d..4fc63e1 100644
--- a/applications/mp4box/fileimport.c
+++ b/applications/mp4box/fileimport.c
@@ -1668,7 +1668,11 @@ GF_Err import_file(GF_ISOFile *dest, char *inName, u32 import_flags, GF_Fraction
 			}
 			if ((fullrange>=0) || (videofmt>=0) || (colorprim>=0) || (colortfc>=0) || (colormx>=0)) {
 				e = gf_media_change_color(dest, i+1, fullrange, videofmt, colorprim, colortfc, colormx);
-				GOTO_EXIT("changing color in bitstream")
+				/* Color signaling update is best-effort: malformed bitstreams may not carry parsable VUI. */
+				if (e) {
+					M4_LOG(GF_LOG_WARNING, ("Warning: could not change color in bitstream (%s) - ignoring\n", gf_error_to_string(e)));
+					e = GF_OK;
+				}
 			}
 			if (has_clap) {
 				e = gf_isom_set_clean_aperture(dest, track, 1, clap_wn, clap_wd, clap_hn, clap_hd, clap_hon, clap_hod, clap_von, clap_vod);
diff --git a/src/media_tools/av_parsers.c b/src/media_tools/av_parsers.c
index 43c3200..54e5816 100644
--- a/src/media_tools/av_parsers.c
+++ b/src/media_tools/av_parsers.c
@@ -6865,6 +6865,10 @@ GF_Err gf_avc_change_vui(GF_AVCConfig *avcc, GF_VUIInfo *vui_info)
 	GF_AVCConfigSlot *slc;
 	orig = NULL;
 
+	/* Can be called on malformed/absent AVC config (eg during import) */
+	if (!avcc || !vui_info) return GF_OK;
+	if (!avcc->sequenceParameterSets) return GF_OK;
+
 	memset(&avc, 0, sizeof(AVCState));
 	avc.sps_active_idx = -1;
 
@@ -6872,6 +6876,8 @@ GF_Err gf_avc_change_vui(GF_AVCConfig *avcc, GF_VUIInfo *vui_info)
 	while ((slc = (GF_AVCConfigSlot *)gf_list_enum(avcc->sequenceParameterSets, &i))) {
 		u8 *no_emulation_buf = NULL;
 		u32 no_emulation_buf_size = 0, emulation_bytes = 0;
+		/* need at least one byte for NAL header and some payload */
+		if (!slc->data || (slc->size < 2)) continue;
 		idx = gf_avc_read_sps(slc->data, slc->size, &avc, 0, &bit_offset);
 		if (idx<0) {
 			if ( orig )
@@ -6881,15 +6887,38 @@ GF_Err gf_avc_change_vui(GF_AVCConfig *avcc, GF_VUIInfo *vui_info)
 
 		/*SPS still contains emulation bytes*/
 		no_emulation_buf = gf_malloc((slc->size - 1) * sizeof(char));
+		if (!no_emulation_buf) {
+			if (orig) {
+				gf_bs_del(orig);
+				orig = NULL;
+			}
+			return GF_OUT_OF_MEM;
+		}
 		no_emulation_buf_size = gf_media_nalu_remove_emulation_bytes(slc->data + 1, no_emulation_buf, slc->size - 1);
 
 		orig = gf_bs_new(no_emulation_buf, no_emulation_buf_size, GF_BITSTREAM_READ);
+		if (!orig) {
+			gf_free(no_emulation_buf);
+			return GF_OUT_OF_MEM;
+		}
 		gf_bs_read_data(orig, no_emulation_buf, no_emulation_buf_size);
 		gf_bs_seek(orig, 0);
 		mod = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
+		if (!mod) {
+			gf_bs_del(orig);
+			orig = NULL;
+			gf_free(no_emulation_buf);
+			return GF_OUT_OF_MEM;
+		}
 
 		/*copy over till vui flag*/
-		assert(bit_offset >= 8);
+		if (bit_offset < 8) {
+			gf_bs_del(orig);
+			orig = NULL;
+			gf_bs_del(mod);
+			gf_free(no_emulation_buf);
+			continue;
+		}
 		while (bit_offset - 8/*bit_offset doesn't take care of the first byte (NALU type)*/) {
 			flag = gf_bs_read_int(orig, 1);
 			gf_bs_write_int(mod, flag, 1);