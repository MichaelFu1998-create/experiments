diff --git a/build/src/bin/common/opj_apps_config.h b/build/src/bin/common/opj_apps_config.h
new file mode 100644
index 0000000..43c63ca
--- /dev/null
+++ b/build/src/bin/common/opj_apps_config.h
@@ -0,0 +1,15 @@
+#include "opj_config_private.h"
+
+/* create opj_apps_config.h for CMake */
+
+/* #undef OPJ_HAVE_LIBPNG */
+/* #undef OPJ_HAVE_PNG_H */
+/* #undef OPJ_HAVE_LIBTIFF */
+/* #undef OPJ_HAVE_TIFF_H */
+
+/* #undef OPJ_HAVE_LIBLCMS1 */
+/* #undef OPJ_HAVE_LIBLCMS2 */
+/* #undef OPJ_HAVE_LCMS1_H */
+/* #undef OPJ_HAVE_LCMS2_H */
+
+
diff --git a/build/src/lib/openjp2/opj_config.h b/build/src/lib/openjp2/opj_config.h
new file mode 100644
index 0000000..87caa0d
--- /dev/null
+++ b/build/src/lib/openjp2/opj_config.h
@@ -0,0 +1,10 @@
+/* create opj_config.h for CMake */
+#define OPJ_HAVE_STDINT_H 		1
+
+/*--------------------------------------------------------------------------*/
+/* OpenJPEG Versioning                                                      */
+
+/* Version number. */
+#define OPJ_VERSION_MAJOR 2
+#define OPJ_VERSION_MINOR 1
+#define OPJ_VERSION_BUILD 1
diff --git a/build/src/lib/openjp2/opj_config_private.h b/build/src/lib/openjp2/opj_config_private.h
new file mode 100644
index 0000000..312e9c3
--- /dev/null
+++ b/build/src/lib/openjp2/opj_config_private.h
@@ -0,0 +1,49 @@
+/* create opj_config_private.h for CMake */
+#define OPJ_HAVE_INTTYPES_H 	1
+
+#define OPJ_PACKAGE_VERSION "2.1.1"
+
+/* Not used by openjp2*/
+/*#define HAVE_MEMORY_H 1*/
+/*#define HAVE_STDLIB_H 1*/
+/*#define HAVE_STRINGS_H 1*/
+/*#define HAVE_STRING_H 1*/
+/*#define HAVE_SYS_STAT_H 1*/
+/*#define HAVE_SYS_TYPES_H 1 */
+/*#define HAVE_UNISTD_H 1*/
+
+/* #undef _LARGEFILE_SOURCE */
+/* #undef _LARGE_FILES */
+/* #undef _FILE_OFFSET_BITS */
+#define OPJ_HAVE_FSEEKO ON
+
+/* find whether or not have <malloc.h> */
+#define OPJ_HAVE_MALLOC_H
+/* check if function `aligned_alloc` exists */
+/* #undef OPJ_HAVE_ALIGNED_ALLOC */
+/* check if function `_aligned_malloc` exists */
+/* #undef OPJ_HAVE__ALIGNED_MALLOC */
+/* check if function `memalign` exists */
+#define OPJ_HAVE_MEMALIGN
+/* check if function `posix_memalign` exists */
+#define OPJ_HAVE_POSIX_MEMALIGN
+
+#if !defined(_POSIX_C_SOURCE)
+#if defined(OPJ_HAVE_FSEEKO) || defined(OPJ_HAVE_POSIX_MEMALIGN)
+/* Get declarations of fseeko, ftello, posix_memalign. */
+#define _POSIX_C_SOURCE 200112L
+#endif
+#endif
+
+/* Byte order.  */
+/* All compilers that support Mac OS X define either __BIG_ENDIAN__ or
+__LITTLE_ENDIAN__ to match the endianness of the architecture being
+compiled for. This is not necessarily the same as the architecture of the
+machine doing the building. In order to support Universal Binaries on
+Mac OS X, we prefer those defines to decide the endianness.
+On other platforms we use the result of the TRY_RUN. */
+#if !defined(__APPLE__)
+/* #undef OPJ_BIG_ENDIAN */
+#elif defined(__BIG_ENDIAN__)
+# define OPJ_BIG_ENDIAN
+#endif
diff --git a/src/bin/jp2/convertbmp.c b/src/bin/jp2/convertbmp.c
index d264823..6d1695f 100644
--- a/src/bin/jp2/convertbmp.c
+++ b/src/bin/jp2/convertbmp.c
@@ -41,6 +41,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <ctype.h>
+#include <limits.h>
 
 #include "openjpeg.h"
 #include "convert.h"
@@ -140,6 +141,14 @@ static void bmp24toimage(const OPJ_UINT8* pData, OPJ_UINT32 stride, opj_image_t*
 
 	width  = image->comps[0].w;
 	height = image->comps[0].h;
+
+	if (height == 0U || width == 0U) {
+		return;
+	}
+	/* Stride must be large enough to hold a whole row */
+	if ((OPJ_UINT64)width * 3U > (OPJ_UINT64)stride) {
+		return;
+	}
 	
 	index = 0;
 	pSrc = pData + (height - 1U) * stride;
@@ -156,6 +165,60 @@ static void bmp24toimage(const OPJ_UINT8* pData, OPJ_UINT32 stride, opj_image_t*
 	}
 }
 
+
+static OPJ_BOOL opj_size_mul_overflow(OPJ_SIZE_T a, OPJ_SIZE_T b, OPJ_SIZE_T* res)
+{
+	if (res == NULL) {
+		return OPJ_TRUE;
+	}
+	if (a == 0U || b == 0U) {
+		*res = 0U;
+		return OPJ_FALSE;
+	}
+	if (a > ((OPJ_SIZE_T)-1) / b) {
+		return OPJ_TRUE;
+	}
+	*res = a * b;
+	return OPJ_FALSE;
+}
+
+static OPJ_BOOL bmp_compute_stride(OPJ_UINT32 width, OPJ_UINT32 bitcount,
+					  OPJ_UINT32 compression, OPJ_UINT32* stride_out)
+{
+	/* rows are aligned on 32bits */
+	OPJ_SIZE_T l_width = (OPJ_SIZE_T)width;
+	OPJ_SIZE_T l_bitcount = (OPJ_SIZE_T)bitcount;
+	OPJ_SIZE_T tmp = 0U;
+	OPJ_SIZE_T stride = 0U;
+
+	if (stride_out == NULL) {
+		return OPJ_FALSE;
+	}
+
+	/* RLE4 gets decoded as 8 bits data for now... */
+	if (bitcount == 4U && compression == 2U) {
+		l_bitcount = 8U;
+	}
+
+	if (opj_size_mul_overflow(l_width, l_bitcount, &tmp)) {
+		return OPJ_FALSE;
+	}
+	if (tmp > ((OPJ_SIZE_T)-1) - 31U) {
+		return OPJ_FALSE;
+	}
+	tmp += 31U;
+	stride = (tmp / 32U);
+	if (stride > ((OPJ_SIZE_T)-1) / 4U) {
+		return OPJ_FALSE;
+	}
+	stride *= 4U;
+	if (stride > (OPJ_SIZE_T)UINT_MAX) {
+		return OPJ_FALSE;
+	}
+	*stride_out = (OPJ_UINT32)stride;
+	return OPJ_TRUE;
+}
+
 static void bmp_mask_get_shift_and_prec(OPJ_UINT32 mask, OPJ_UINT32* shift, OPJ_UINT32* prec)
 {
 	OPJ_UINT32 l_shift, l_prec;
@@ -488,13 +551,20 @@ static OPJ_BOOL bmp_read_info_header(FILE* IN, OPJ_BITMAPINFOHEADER* header)
 static OPJ_BOOL bmp_read_raw_data(FILE* IN, OPJ_UINT8* pData, OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)
 {
 	OPJ_ARG_NOT_USED(width);
-	
-	if ( fread(pData, sizeof(OPJ_UINT8), stride * height, IN) != (stride * height) )
 	{
-		fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
-		return OPJ_FALSE;
+		OPJ_SIZE_T l_expected = 0U;
+		if (opj_size_mul_overflow((OPJ_SIZE_T)stride, (OPJ_SIZE_T)height, &l_expected)) {
+			fprintf(stderr, "\nError: invalid BMP dimensions (overflow).\n");
+			return OPJ_FALSE;
+		}
+		if (fread(pData, sizeof(OPJ_UINT8), (size_t)l_expected, IN) != (size_t)l_expected)
+		{
+			fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
+			return OPJ_FALSE;
+		}
 	}
 	return OPJ_TRUE;
+
 }
 
 static OPJ_BOOL bmp_read_rle8_data(FILE* IN, OPJ_UINT8* pData, OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)
@@ -503,7 +573,13 @@ static OPJ_BOOL bmp_read_rle8_data(FILE* IN, OPJ_UINT8* pData, OPJ_UINT32 stride
 	OPJ_UINT8 *pix;
 	const OPJ_UINT8 *beyond;
 	
-	beyond = pData + stride * height;
+	{
+		OPJ_SIZE_T l_size = 0U;
+		if (opj_size_mul_overflow((OPJ_SIZE_T)stride, (OPJ_SIZE_T)height, &l_size)) {
+			return OPJ_FALSE;
+		}
+		beyond = pData + l_size;
+	}
 	pix = pData;
 	
 	x = y = 0U;
@@ -559,7 +635,13 @@ static OPJ_BOOL bmp_read_rle4_data(FILE* IN, OPJ_UINT8* pData, OPJ_UINT32 stride
 	OPJ_UINT8 *pix;
 	const OPJ_UINT8 *beyond;
 	
-	beyond = pData + stride * height;
+	{
+		OPJ_SIZE_T l_size = 0U;
+		if (opj_size_mul_overflow((OPJ_SIZE_T)stride, (OPJ_SIZE_T)height, &l_size)) {
+			return OPJ_FALSE;
+		}
+		beyond = pData + l_size;
+	}
 	pix = pData;
 	x = y = 0U;
 	while(y < height)
@@ -640,6 +722,17 @@ opj_image_t* bmptoimage(const char *filename, opj_cparameters_t *parameters)
 		fclose(IN);
 		return NULL;
 	}
+
+	/* Reject invalid/too large dimensions */
+	if (Info_h.biWidth == 0U || Info_h.biHeight == 0U) {
+		fclose(IN);
+		return NULL;
+	}
+	/* Prevent overflow in opj_image_create() where comp->w * comp->h is evaluated in 32-bit */
+	if (Info_h.biWidth != 0U && Info_h.biHeight > UINT_MAX / Info_h.biWidth) {
+		fclose(IN);
+		return NULL;
+	}
 	
 	/* Load palette */
 	if (Info_h.biBitCount <= 8U)
@@ -675,11 +768,18 @@ opj_image_t* bmptoimage(const char *filename, opj_cparameters_t *parameters)
 		}
 	}
 	
-	stride = ((Info_h.biWidth * Info_h.biBitCount + 31U) / 32U) * 4U; /* rows are aligned on 32bits */
-	if (Info_h.biBitCount == 4 && Info_h.biCompression == 2) { /* RLE 4 gets decoded as 8 bits data for now... */
-		stride = ((Info_h.biWidth * 8U + 31U) / 32U) * 4U;
+	if (!bmp_compute_stride(Info_h.biWidth, Info_h.biBitCount, Info_h.biCompression, &stride)) {
+		fclose(IN);
+		return NULL;
+	}
+	{
+		OPJ_SIZE_T l_alloc_size = 0U;
+		if (opj_size_mul_overflow((OPJ_SIZE_T)stride, (OPJ_SIZE_T)Info_h.biHeight, &l_alloc_size)) {
+			fclose(IN);
+			return NULL;
+		}
+		pData = (OPJ_UINT8 *) calloc(1, (size_t)l_alloc_size);
 	}
-	pData = (OPJ_UINT8 *) calloc(1, stride * Info_h.biHeight * sizeof(OPJ_UINT8));
 	if (pData == NULL) {
 		fclose(IN);
 		return NULL;