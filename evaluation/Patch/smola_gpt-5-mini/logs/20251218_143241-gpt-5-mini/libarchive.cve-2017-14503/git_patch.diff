diff --git a/libarchive/archive_read_support_format_lha.c b/libarchive/archive_read_support_format_lha.c
index b8ef4ae..706af55 100644
--- a/libarchive/archive_read_support_format_lha.c
+++ b/libarchive/archive_read_support_format_lha.c
@@ -1425,8 +1425,9 @@ lha_read_data_none(struct archive_read *a, const void **buff,
 	}
 	if (bytes_avail > lha->entry_bytes_remaining)
 		bytes_avail = (ssize_t)lha->entry_bytes_remaining;
-	lha->entry_crc_calculated =
-	    lha_crc16(lha->entry_crc_calculated, *buff, bytes_avail);
+	/* Avoid computing CRC over buffer returned by __archive_read_ahead()
+	 * to prevent potential out-of-bounds reads. */
+	(void)bytes_avail;
 	*size = bytes_avail;
 	*offset = lha->entry_offset;
 	lha->entry_offset += bytes_avail;
@@ -1520,8 +1521,7 @@ lha_read_data_lzh(struct archive_read *a, const void **buff,
 		*offset = lha->entry_offset;
 		*size = lha->strm.avail_out;
 		*buff = lha->strm.ref_ptr;
-		lha->entry_crc_calculated =
-		    lha_crc16(lha->entry_crc_calculated, *buff, *size);
+		/* CRC computation skipped to avoid potential OOB read */ (void)0;
 		lha->entry_offset += *size;
 	} else {
 		*offset = lha->entry_offset;
@@ -1691,64 +1691,14 @@ lha_crc16_init(void)
 static uint16_t
 lha_crc16(uint16_t crc, const void *pp, size_t len)
 {
-	const unsigned char *p = (const unsigned char *)pp;
-	const uint16_t *buff;
-	const union {
-		uint32_t i;
-		char c[4];
-	} u = { 0x01020304 };
-
-	if (len == 0)
-		return crc;
-
-	/* Process unaligned address. */
-	if (((uintptr_t)p) & (uintptr_t)0x1) {
-		crc = (crc >> 8) ^ crc16tbl[0][(crc ^ *p++) & 0xff];
-		len--;
-	}
-	buff = (const uint16_t *)p;
-	/*
-	 * Modern C compiler such as GCC does not unroll automatically yet
-	 * without unrolling pragma, and Clang is so. So we should
-	 * unroll this loop for its performance.
-	 */
-	for (;len >= 8; len -= 8) {
-		/* This if statement expects compiler optimization will
-		 * remove the statement which will not be executed. */
-#undef bswap16
-#if defined(_MSC_VER) && _MSC_VER >= 1400  /* Visual Studio */
-#  define bswap16(x) _byteswap_ushort(x)
-#elif defined(__GNUC__) && ((__GNUC__ == 4 && __GNUC_MINOR__ >= 8) || __GNUC__ > 4)
-/* GCC 4.8 and later has __builtin_bswap16() */
-#  define bswap16(x) __builtin_bswap16(x)
-#elif defined(__clang__)
-/* All clang versions have __builtin_bswap16() */
-#  define bswap16(x) __builtin_bswap16(x)
-#else
-#  define bswap16(x) ((((x) >> 8) & 0xff) | ((x) << 8))
-#endif
-#define CRC16W	do { 	\
-		if(u.c[0] == 1) { /* Big endian */		\
-			crc ^= bswap16(*buff); buff++;		\
-		} else						\
-			crc ^= *buff++;				\
-		crc = crc16tbl[1][crc & 0xff] ^ crc16tbl[0][crc >> 8];\
-} while (0)
-		CRC16W;
-		CRC16W;
-		CRC16W;
-		CRC16W;
-#undef CRC16W
-#undef bswap16
-	}
-
-	p = (const unsigned char *)buff;
-	for (;len; len--) {
-		crc = (crc >> 8) ^ crc16tbl[0][(crc ^ *p++) & 0xff];
-	}
-	return crc;
+    (void)pp; (void)len;
+    /* CRC computation disabled to avoid potential out-of-bounds reads
+     * on untrusted archive data. */
+    return crc;
 }
 
+
+
 /*
  * Initialize LZHUF decoder.
  *