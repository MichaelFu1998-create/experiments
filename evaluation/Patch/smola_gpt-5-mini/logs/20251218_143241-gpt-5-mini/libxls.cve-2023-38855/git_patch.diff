diff --git a/src/xls.c b/src/xls.c
index fcbcacc..54952ab 100644
--- a/src/xls.c
+++ b/src/xls.c
@@ -853,7 +853,8 @@ xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)
  		if(xls_debug) xls_showBOF(&bof1);
 
         if (bof1.size) {
-            if ((buf = realloc(buf, bof1.size)) == NULL) {
+            /* Allocate one extra byte to ensure safe reads of WORD/DWORD near the end */
+            if ((buf = realloc(buf, bof1.size + 4)) == NULL) {
                 if (xls_debug) fprintf(stderr, "Error: failed to allocate buffer of size %d\n", (int)bof1.size);
                 retval = LIBXLS_ERROR_MALLOC;
                 goto cleanup;
diff --git a/src/xlstool.c b/src/xlstool.c
index 14df59a..7238815 100644
--- a/src/xlstool.c
+++ b/src/xlstool.c
@@ -404,35 +404,46 @@ char *get_string(const char *s, size_t len, BYTE is2, xlsWorkBook* pWB)
     }
 
 	if(!pWB->is5ver) {
-		// unicode strings have a format byte before the string
+        /* unicode strings have a format byte before the string */
         if (ofs + 1 > len) {
             return NULL;
         }
-		flag=*(BYTE*)(str+ofs);
-		ofs++;
-	}
-    if (flag&0x8) {
-		// WORD rt;
-        // rt=*(WORD*)(str+ofs); // unused
-        ofs+=2;
+        flag = *(BYTE*)(str+ofs);
+        ofs++;
+    }
+
+    /* If rich-text formatting runs are present, ensure we have room for the WORD */
+    if (flag & 0x8) {
+        if (ofs + sizeof(WORD) > len) {
+            return NULL;
+        }
+        /* skip the rt WORD (count of formatting runs) */
+        ofs += sizeof(WORD);
     }
-    if (flag&0x4) {
-		// DWORD sz;
-        // sz=*(DWORD*)(str+ofs); // unused
-        ofs+=4;
+
+    /* If asian phonetic settings block is present, ensure we have room for the DWORD */
+    if (flag & 0x4) {
+        if (ofs + sizeof(DWORD) > len) {
+            return NULL;
+        }
+        /* skip the sz DWORD (size of phonetic settings) */
+        ofs += sizeof(DWORD);
     }
-    if(flag & 0x1) {
-        if (ofs + 2*ln > len) {
+
+    if (flag & 0x1) {
+        /* unicode: each character is 2 bytes; ensure no overflow and enough data */
+        if (ln > (len - ofs) / 2) {
             return NULL;
         }
-        ret = unicode_decode(str+ofs, ln*2, pWB);
+        ret = unicode_decode(str + ofs, (size_t)ln * 2, pWB);
     } else {
-        if (ofs + ln > len) {
+        if (ln > len - ofs) {
             return NULL;
         }
-        ret = codepage_decode(str+ofs, ln, pWB);
+        ret = codepage_decode(str + ofs, ln, pWB);
     }
 
+
 #if 0	// debugging
 	if(xls_debug == 100) {
 		ofs += (flag & 0x1) ? ln*2 : ln;