diff --git a/build/src/bin/common/opj_apps_config.h b/build/src/bin/common/opj_apps_config.h
new file mode 100644
index 0000000..43c63ca
--- /dev/null
+++ b/build/src/bin/common/opj_apps_config.h
@@ -0,0 +1,15 @@
+#include "opj_config_private.h"
+
+/* create opj_apps_config.h for CMake */
+
+/* #undef OPJ_HAVE_LIBPNG */
+/* #undef OPJ_HAVE_PNG_H */
+/* #undef OPJ_HAVE_LIBTIFF */
+/* #undef OPJ_HAVE_TIFF_H */
+
+/* #undef OPJ_HAVE_LIBLCMS1 */
+/* #undef OPJ_HAVE_LIBLCMS2 */
+/* #undef OPJ_HAVE_LCMS1_H */
+/* #undef OPJ_HAVE_LCMS2_H */
+
+
diff --git a/build/src/lib/openjp2/opj_config.h b/build/src/lib/openjp2/opj_config.h
new file mode 100644
index 0000000..87caa0d
--- /dev/null
+++ b/build/src/lib/openjp2/opj_config.h
@@ -0,0 +1,10 @@
+/* create opj_config.h for CMake */
+#define OPJ_HAVE_STDINT_H 		1
+
+/*--------------------------------------------------------------------------*/
+/* OpenJPEG Versioning                                                      */
+
+/* Version number. */
+#define OPJ_VERSION_MAJOR 2
+#define OPJ_VERSION_MINOR 1
+#define OPJ_VERSION_BUILD 1
diff --git a/build/src/lib/openjp2/opj_config_private.h b/build/src/lib/openjp2/opj_config_private.h
new file mode 100644
index 0000000..312e9c3
--- /dev/null
+++ b/build/src/lib/openjp2/opj_config_private.h
@@ -0,0 +1,49 @@
+/* create opj_config_private.h for CMake */
+#define OPJ_HAVE_INTTYPES_H 	1
+
+#define OPJ_PACKAGE_VERSION "2.1.1"
+
+/* Not used by openjp2*/
+/*#define HAVE_MEMORY_H 1*/
+/*#define HAVE_STDLIB_H 1*/
+/*#define HAVE_STRINGS_H 1*/
+/*#define HAVE_STRING_H 1*/
+/*#define HAVE_SYS_STAT_H 1*/
+/*#define HAVE_SYS_TYPES_H 1 */
+/*#define HAVE_UNISTD_H 1*/
+
+/* #undef _LARGEFILE_SOURCE */
+/* #undef _LARGE_FILES */
+/* #undef _FILE_OFFSET_BITS */
+#define OPJ_HAVE_FSEEKO ON
+
+/* find whether or not have <malloc.h> */
+#define OPJ_HAVE_MALLOC_H
+/* check if function `aligned_alloc` exists */
+/* #undef OPJ_HAVE_ALIGNED_ALLOC */
+/* check if function `_aligned_malloc` exists */
+/* #undef OPJ_HAVE__ALIGNED_MALLOC */
+/* check if function `memalign` exists */
+#define OPJ_HAVE_MEMALIGN
+/* check if function `posix_memalign` exists */
+#define OPJ_HAVE_POSIX_MEMALIGN
+
+#if !defined(_POSIX_C_SOURCE)
+#if defined(OPJ_HAVE_FSEEKO) || defined(OPJ_HAVE_POSIX_MEMALIGN)
+/* Get declarations of fseeko, ftello, posix_memalign. */
+#define _POSIX_C_SOURCE 200112L
+#endif
+#endif
+
+/* Byte order.  */
+/* All compilers that support Mac OS X define either __BIG_ENDIAN__ or
+__LITTLE_ENDIAN__ to match the endianness of the architecture being
+compiled for. This is not necessarily the same as the architecture of the
+machine doing the building. In order to support Universal Binaries on
+Mac OS X, we prefer those defines to decide the endianness.
+On other platforms we use the result of the TRY_RUN. */
+#if !defined(__APPLE__)
+/* #undef OPJ_BIG_ENDIAN */
+#elif defined(__BIG_ENDIAN__)
+# define OPJ_BIG_ENDIAN
+#endif
diff --git a/src/bin/jp2/convertbmp.c b/src/bin/jp2/convertbmp.c
index d264823..42cf0d7 100644
--- a/src/bin/jp2/convertbmp.c
+++ b/src/bin/jp2/convertbmp.c
@@ -39,6 +39,8 @@
 
 #include <stdio.h>
 #include <stdlib.h>
+#include <stdint.h>
+#include <limits.h>
 #include <string.h>
 #include <ctype.h>
 
@@ -675,15 +677,47 @@ opj_image_t* bmptoimage(const char *filename, opj_cparameters_t *parameters)
 		}
 	}
 	
-	stride = ((Info_h.biWidth * Info_h.biBitCount + 31U) / 32U) * 4U; /* rows are aligned on 32bits */
-	if (Info_h.biBitCount == 4 && Info_h.biCompression == 2) { /* RLE 4 gets decoded as 8 bits data for now... */
-		stride = ((Info_h.biWidth * 8U + 31U) / 32U) * 4U;
+	/* Compute stride using size_t to avoid 32-bit integer overflow for large dimensions. */
+	{
+		size_t row_bits = (size_t)Info_h.biWidth * (size_t)Info_h.biBitCount;
+		/* add 31 and divide by 32, then multiply by 4 to get bytes per row aligned to 32 bits */
+		size_t row_size = ((row_bits + 31ULL) / 32ULL) * 4ULL;
+		if (row_size == 0ULL || row_size > (size_t)UINT32_MAX) {
+			fprintf(stderr, "BMP row size too large or overflow detected\n");
+			fclose(IN);
+			return NULL;
+		}
+		stride = (OPJ_UINT32)row_size; /* rows are aligned on 32bits */
 	}
-	pData = (OPJ_UINT8 *) calloc(1, stride * Info_h.biHeight * sizeof(OPJ_UINT8));
-	if (pData == NULL) {
+	if (Info_h.biBitCount == 4 && Info_h.biCompression == 2) { /* RLE 4 gets decoded as 8 bits data for now... */
+		/* Recompute stride for 8 bits per pixel equivalent */
+		size_t row_bits = (size_t)Info_h.biWidth * 8ULL;
+		size_t row_size = ((row_bits + 31ULL) / 32ULL) * 4ULL;
+		if (row_size == 0ULL || row_size > (size_t)UINT32_MAX) {
+			fprintf(stderr, "BMP row size too large or overflow detected\n");
+			fclose(IN);
+			return NULL;
+		}
+		stride = (OPJ_UINT32)row_size;
+	}
+	/* Check for multiplication overflow when computing the buffer size.
+		   stride and Info_h.biHeight are 32-bit values; their product may
+		   wrap around when computed in 32-bit arithmetic, leading to a
+		   too-small allocation and subsequent buffer over-reads. Compute
+		   the size in size_t and validate before allocation. */
+	if (Info_h.biHeight != 0U && stride > (OPJ_UINT32)(SIZE_MAX / (size_t)Info_h.biHeight)) {
+		fprintf(stderr, "BMP image dimensions too large or overflow detected\n");
 		fclose(IN);
 		return NULL;
 	}
+	{
+		size_t alloc_size = (size_t)stride * (size_t)Info_h.biHeight;
+		pData = (OPJ_UINT8 *) calloc(1, alloc_size);
+		if (pData == NULL) {
+			fclose(IN);
+			return NULL;
+		}
+	}
 	/* Place the cursor at the beginning of the image information */
 	fseek(IN, 0, SEEK_SET);
 	fseek(IN, (long)File_h.bfOffBits, SEEK_SET);