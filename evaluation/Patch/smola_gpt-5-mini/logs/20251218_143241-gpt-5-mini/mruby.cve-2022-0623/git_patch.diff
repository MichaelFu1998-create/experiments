diff --git a/include/mruby.h b/include/mruby.h
index 3e92021..1cd2998 100644
--- a/include/mruby.h
+++ b/include/mruby.h
@@ -1415,6 +1415,8 @@ MRB_API void mrb_check_type(mrb_state *mrb, mrb_value x, enum mrb_vtype t);
 
 MRB_INLINE void mrb_check_frozen(mrb_state *mrb, void *o)
 {
+  /* Avoid dereferencing NULL pointers: some callers may pass NULL (e.g. mrb_ptr on nil) */
+  if (o == NULL) return;
   if (mrb_frozen_p((struct RBasic*)o)) mrb_frozen_error(mrb, o);
 }
 
diff --git a/src/hash.c b/src/hash.c
index fc6b6fa..1ec7f77 100644
--- a/src/hash.c
+++ b/src/hash.c
@@ -1148,9 +1148,28 @@ mrb_hash_new_capa(mrb_state *mrb, mrb_int capa)
 
 static mrb_value mrb_hash_default(mrb_state *mrb, mrb_value hash);
 
+
+static inline void ensure_hash_value(mrb_state *mrb, mrb_value hash)
+{
+  /* Avoid dereferencing likely-invalid pointers. If `hash` is not an object
+     or points into the NULL/low page region, raise a type error instead of
+     crashing. */
+  void *ptr = mrb_ptr(hash);
+  if (ptr == NULL || (uintptr_t)ptr < 4096) {
+    mrb_raise(mrb, E_TYPE_ERROR, "Hash required");
+  }
+  if (!mrb_hash_p(hash)) {
+    mrb_raise(mrb, E_TYPE_ERROR, "Hash required");
+  }
+}
+
 static void
 hash_modify(mrb_state *mrb, mrb_value hash)
 {
+  /* Only check frozen for actual Hash objects. Some callers may pass
+     non-hash or immediate values, so guard against dereferencing
+     invalid pointers. */
+  if (!mrb_hash_p(hash)) return;
   mrb_check_frozen(mrb, mrb_hash_ptr(hash));
 }
 
@@ -1199,6 +1218,7 @@ mrb_hash_init_copy(mrb_state *mrb, mrb_value self)
 MRB_API mrb_value
 mrb_hash_dup(mrb_state *mrb, mrb_value self)
 {
+  ensure_hash_value(mrb, self);
   struct RHash* copy_h = h_alloc(mrb);
   mrb_value copy = mrb_obj_value(copy_h);
   copy_h->c = mrb_hash_ptr(self)->c;
@@ -1209,6 +1229,7 @@ mrb_hash_dup(mrb_state *mrb, mrb_value self)
 MRB_API mrb_value
 mrb_hash_get(mrb_state *mrb, mrb_value hash, mrb_value key)
 {
+  ensure_hash_value(mrb, hash);
   mrb_value val;
   mrb_sym mid;
 
@@ -1227,6 +1248,7 @@ mrb_hash_get(mrb_state *mrb, mrb_value hash, mrb_value key)
 MRB_API mrb_value
 mrb_hash_fetch(mrb_state *mrb, mrb_value hash, mrb_value key, mrb_value def)
 {
+  ensure_hash_value(mrb, hash);
   mrb_value val;
 
   if (h_get(mrb, mrb_hash_ptr(hash), key, &val)) {
@@ -1239,6 +1261,7 @@ mrb_hash_fetch(mrb_state *mrb, mrb_value hash, mrb_value key, mrb_value def)
 MRB_API void
 mrb_hash_set(mrb_state *mrb, mrb_value hash, mrb_value key, mrb_value val)
 {
+  ensure_hash_value(mrb, hash);
   hash_modify(mrb, hash);
   key = h_key_for(mrb, key);
   h_set(mrb, mrb_hash_ptr(hash), key, val);