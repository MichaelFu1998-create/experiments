diff --git a/src/filters/dasher.c b/src/filters/dasher.c
index 2619d22..0ace758 100644
--- a/src/filters/dasher.c
+++ b/src/filters/dasher.c
@@ -888,6 +888,7 @@ static GF_Err dasher_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is
 	const char *cue_file=NULL;
 	s64 old_clamp_dur = 0;
 	GF_DasherCtx *ctx = gf_filter_get_udta(filter);
+	if (!ctx) return GF_SERVICE_ERROR;
 
 	if (is_remove) {
 		ds = gf_filter_pid_get_udta(pid);
@@ -8317,8 +8318,10 @@ static void dasher_send_empty_segment(GF_DasherCtx *ctx, GF_DashStream *ds)
 		gf_filter_pck_send(pck);
 
 	if (ctx->do_index) {
-		GF_MPD_SegmentURL *s = gf_list_last(ds->rep->segment_list->segment_URLs);
-		s->first_tfdt = ds->first_cts_in_seg;
+		if (ds->rep && ds->rep->segment_list && ds->rep->segment_list->segment_URLs && gf_list_count(ds->rep->segment_list->segment_URLs)) {
+			GF_MPD_SegmentURL *s = gf_list_last(ds->rep->segment_list->segment_URLs);
+			if (s) s->first_tfdt = ds->first_cts_in_seg;
+		}
 	}
 
 	ds->first_cts_in_next_seg = ds->first_cts_in_seg + gf_timestamp_rescale(ds->dash_dur.num, ds->dash_dur.den, ds->timescale);
@@ -8331,6 +8334,7 @@ static GF_Err dasher_process(GF_Filter *filter)
 {
 	u32 i, count, nb_init, has_init, nb_reg_done;
 	GF_DasherCtx *ctx = gf_filter_get_udta(filter);
+	if (!ctx) return GF_SERVICE_ERROR;
 	GF_Err e;
 	Bool seg_done = GF_FALSE;
 	u32 nb_seg_waiting = 0;
@@ -9692,6 +9696,7 @@ static Bool dasher_process_event(GF_Filter *filter, const GF_FilterEvent *evt)
 	u32 i, count;
 	Bool flush_mpd = GF_FALSE;
 	GF_DasherCtx *ctx = gf_filter_get_udta(filter);
+	if (!ctx) return GF_SERVICE_ERROR;
 
 	ctx->last_evt_check_time = 0;
 
@@ -10065,6 +10070,7 @@ static GF_Err dasher_initialize(GF_Filter *filter)
 {
 	GF_Err e;
 	GF_DasherCtx *ctx = gf_filter_get_udta(filter);
+	if (!ctx) return GF_SERVICE_ERROR;
 	gf_filter_set_max_extra_input_pids(filter, -1);
 
 	ctx->pids = gf_list_new();
@@ -10148,6 +10154,7 @@ static GF_Err dasher_initialize(GF_Filter *filter)
 static void dasher_finalize(GF_Filter *filter)
 {
 	GF_DasherCtx *ctx = gf_filter_get_udta(filter);
+	if (!ctx) return;
 
 	while (gf_list_count(ctx->pids)) {
 		GF_DashStream *ds = gf_list_pop_back(ctx->pids);
diff --git a/src/media_tools/avilib.c b/src/media_tools/avilib.c
index 27cd811..697fb0a 100644
--- a/src/media_tools/avilib.c
+++ b/src/media_tools/avilib.c
@@ -541,35 +541,48 @@ static int avi_add_odml_index_entry(avi_t *AVI, unsigned char *tag, int flags, u
 
 static int avi_add_index_entry(avi_t *AVI, unsigned char *tag, int flags, u64 pos, u64 len)
 {
-	if(AVI->n_idx>=AVI->max_idx) {
-		void *ptr = gf_realloc((void *)AVI->idx,(AVI->max_idx+4096)*16);
+    /* defensively handle NULL AVI pointer */
+    if (!AVI) return -1;
 
-		if(ptr == 0) {
-			AVI_errno = AVI_ERR_NO_MEM;
-			return -1;
-		}
-		AVI->max_idx += 4096;
-		AVI->idx = (unsigned char((*)[16]) ) ptr;
-	}
+    /* Ensure index array is allocated */
+    if (AVI->idx == NULL || AVI->n_idx >= AVI->max_idx) {
+        size_t new_max_idx = (size_t)(AVI->max_idx + 4096);
+        void *ptr = NULL;
+        if (AVI->idx == NULL) {
+            ptr = gf_malloc(new_max_idx * 16);
+        } else {
+            ptr = gf_realloc((void *)AVI->idx, new_max_idx * 16);
+        }
 
-	/* Add index entry */
+        if (ptr == NULL) {
+            AVI_errno = AVI_ERR_NO_MEM;
+            return -1;
+        }
 
-	//   GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, ("[avilib] INDEX %s %ld %lu %lu\n", tag, flags, pos, len));
+        AVI->max_idx = (int)new_max_idx;
+        AVI->idx = (u8 (*)[16]) ptr;
+    }
 
-	memcpy(AVI->idx[AVI->n_idx],tag,4);
-	long2str(AVI->idx[AVI->n_idx]+ 4,flags);
-	long2str(AVI->idx[AVI->n_idx]+ 8, (s32) pos);
-	long2str(AVI->idx[AVI->n_idx]+12, (s32) len);
+    /* sanity check */
+    if (AVI->idx == NULL || AVI->n_idx < 0 || AVI->n_idx >= AVI->max_idx) {
+        AVI_errno = AVI_ERR_NO_MEM;
+        return -1;
+    }
 
-	/* Update counter */
+    memcpy(AVI->idx[AVI->n_idx], tag, 4);
+    long2str(AVI->idx[AVI->n_idx] + 4, flags);
+    long2str(AVI->idx[AVI->n_idx] + 8, (s32) pos);
+    long2str(AVI->idx[AVI->n_idx] + 12, (s32) len);
 
-	AVI->n_idx++;
+    /* Update counter */
+    AVI->n_idx++;
 
-	if(len>AVI->max_len) AVI->max_len=(u32) len;
+    if (len > AVI->max_len) AVI->max_len = (u32) len;
 
-	return 0;
+    return 0;
 }
 
+
 #if 0
 /* Returns 1 if more audio is in that video junk */
 int AVI_can_read_audio(avi_t *AVI)
diff --git a/src/media_tools/mpeg2_ps.c b/src/media_tools/mpeg2_ps.c
index 8e33e48..32b6f5a 100644
--- a/src/media_tools/mpeg2_ps.c
+++ b/src/media_tools/mpeg2_ps.c
@@ -160,10 +160,14 @@ static Bool file_read_bytes(FILE *fd,
                             u8 *buffer,
                             u32 len)
 {
-	u32 readval = (u32) gf_fread(buffer, len, fd);
-	return readval == len;
+    /* guard against NULL file pointers or buffers to avoid calling
+       fread with a NULL stream which leads to a crash under ASAN */
+    if (!fd || !buffer || len == 0) return 0;
+    size_t readval = gf_fread(buffer, (size_t)len, fd);
+    return (u32)readval == len;
 }
 
+
 // note: len could be negative.
 static void file_skip_bytes (FILE *fd, s32 len)
 {