diff --git a/src/mat5.c b/src/mat5.c
index abdb351..cf8b227 100644
--- a/src/mat5.c
+++ b/src/mat5.c
@@ -632,6 +632,8 @@ WriteCharData(mat_t *mat, void *data, int N,enum matio_types data_type)
     mat_int8_t pad1 = 0;
 
     switch ( data_type ) {
+        fprintf(stderr, "Mat_VarReadNextInfo5: switch data_type=%d nBytes=%d
+", data_type, nBytes);
         case MAT_T_UINT16:
         {
             nBytes = N*2;
@@ -729,6 +731,8 @@ WriteCompressedCharData(mat_t *mat,z_streamp z,void *data,int N,
         return 0;
 
     switch ( data_type ) {
+        fprintf(stderr, "Mat_VarReadNextInfo5: switch data_type=%d nBytes=%d
+", data_type, nBytes);
         case MAT_T_UINT8:
         case MAT_T_UINT16:
         case MAT_T_UTF8:
@@ -1634,10 +1638,31 @@ ReadRankDims(mat_t *mat, matvar_t *matvar, enum matio_types data_type, mat_uint3
     size_t bytesread = 0;
     /* Rank and dimension */
     if ( data_type == MAT_T_INT32 ) {
+        /* nbytes holds the byte length of the dimensions array.  It must be
+         * a multiple of sizeof(mat_uint32_t).  Compute the rank and ensure
+         * that the allocation for the dims array cannot overflow.  Use
+         * SafeMul to detect overflow when computing the allocation size.
+         */
+        if ( nbytes % sizeof(mat_uint32_t) != 0 ) {
+            Mat_Critical("Invalid dimension bytes: %u", nbytes);
+            return 0;
+        }
+
         matvar->rank = nbytes / sizeof(mat_uint32_t);
-        matvar->dims = (size_t*)malloc(matvar->rank*sizeof(*matvar->dims));
+        if ( matvar->rank == 0 )
+            return 0;
+
+        /* Check for multiplication overflow when allocating dims */
+        size_t alloc_bytes = 0;
+        if ( SafeMul(&alloc_bytes, matvar->rank, sizeof(*matvar->dims)) ) {
+            Mat_Critical("Integer overflow computing dims allocation");
+            matvar->rank = 0;
+            return 0;
+        }
+
+        matvar->dims = (size_t*)malloc(alloc_bytes);
         if ( NULL != matvar->dims ) {
-            int i;
+            size_t i;
             mat_uint32_t buf;
 
             for ( i = 0; i < matvar->rank; i++) {
@@ -1676,6 +1701,7 @@ ReadRankDims(mat_t *mat, matvar_t *matvar, enum matio_types data_type, mat_uint3
     return bytesread;
 }
 
+
 /** @brief Writes the header and data for a given type
  *
  * @ingroup mat_internal
@@ -3661,7 +3687,9 @@ Mat_VarRead5(mat_t *mat, matvar_t *matvar)
 
 #define GET_DATA_SLAB2_TYPE(T) \
     do { \
-        switch ( data_type ) { \
+        switch ( data_type ) {
+        fprintf(stderr, "Mat_VarReadNextInfo5: switch data_type=%d nBytes=%d
+", data_type, nBytes); \
             case MAT_T_DOUBLE: \
             { \
                 double *ptr_in = (double *)data_in; \
@@ -3746,7 +3774,9 @@ Mat_VarRead5(mat_t *mat, matvar_t *matvar)
 
 #define GET_DATA_SLABN_TYPE(T) \
     do { \
-        switch ( data_type ) { \
+        switch ( data_type ) {
+        fprintf(stderr, "Mat_VarReadNextInfo5: switch data_type=%d nBytes=%d
+", data_type, nBytes); \
             case MAT_T_DOUBLE: \
             { \
                 double *ptr_in = (double *)data_in; \
@@ -4751,6 +4781,9 @@ Mat_VarWrite5(mat_t *mat,matvar_t *matvar,int compress)
 matvar_t *
 Mat_VarReadNextInfo5( mat_t *mat )
 {
+    fprintf(stderr, "Mat_VarReadNextInfo5: enter
+");
+
     int err;
     mat_int32_t data_type, nBytes;
     long fpos;
@@ -4768,12 +4801,16 @@ Mat_VarReadNextInfo5( mat_t *mat )
     err = fread(&data_type,4,1,(FILE*)mat->fp);
     if ( err == 0 )
         return NULL;
+    fprintf(stderr, "Mat_VarReadNextInfo5: data_type=%d
+", data_type);
     err = fread(&nBytes,4,1,(FILE*)mat->fp);
     if ( mat->byteswap ) {
         (void)Mat_int32Swap(&data_type);
         (void)Mat_int32Swap(&nBytes);
     }
     switch ( data_type ) {
+        fprintf(stderr, "Mat_VarReadNextInfo5: switch data_type=%d nBytes=%d
+", data_type, nBytes);
         case MAT_T_COMPRESSED:
         {
 #if defined(HAVE_ZLIB)
@@ -4846,14 +4883,39 @@ Mat_VarReadNextInfo5( mat_t *mat )
                 if ( uncomp_buf[0] == MAT_T_INT32 ) {
                     int j;
                     nbytes = uncomp_buf[1];
-                    matvar->rank = nbytes / 4;
-                    matvar->dims = (size_t*)malloc(matvar->rank*sizeof(*matvar->dims));
-                    if ( mat->byteswap ) {
-                        for ( j = 0; j < matvar->rank; j++ )
-                            matvar->dims[j] = Mat_uint32Swap(dims + j);
+                    /* Validate nbytes and compute rank safely */
+                    if ( nbytes % sizeof(mat_uint32_t) != 0 ) {
+                        (void)fseek((FILE*)mat->fp,nBytes-bytesread,SEEK_CUR);
+                        Mat_VarFree(matvar);
+                        matvar = NULL;
+                        Mat_Critical("Invalid dimension bytes in compressed data: %u", nbytes);
+                        break;
+                    }
+                    matvar->rank = nbytes / sizeof(mat_uint32_t);
+                    if ( matvar->rank == 0 ) {
+                        matvar->dims = NULL;
                     } else {
-                        for ( j = 0; j < matvar->rank; j++ )
-                            matvar->dims[j] = dims[j];
+                        size_t alloc_bytes = 0;
+                        if ( SafeMul(&alloc_bytes, matvar->rank, sizeof(*matvar->dims)) ) {
+                            (void)fseek((FILE*)mat->fp,nBytes-bytesread,SEEK_CUR);
+                            Mat_VarFree(matvar);
+                            matvar = NULL;
+                            Mat_Critical("Integer overflow computing dims allocation");
+                            break;
+                        }
+                        matvar->dims = (size_t*)malloc(alloc_bytes);
+                        if ( matvar->dims != NULL ) {
+                            if ( mat->byteswap ) {
+                                for ( j = 0; j < matvar->rank; j++ )
+                                    matvar->dims[j] = Mat_uint32Swap(dims + j);
+                            } else {
+                                for ( j = 0; j < matvar->rank; j++ )
+                                    matvar->dims[j] = dims[j];
+                            }
+                        } else {
+                            matvar->rank = 0;
+                            Mat_Critical("Error allocating memory for dims");
+                        }
                     }
                 }
                 if ( do_clean )