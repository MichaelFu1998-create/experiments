diff --git a/MagickCore/statistic.c b/MagickCore/statistic.c
index a649880..4a82662 100644
--- a/MagickCore/statistic.c
+++ b/MagickCore/statistic.c
@@ -161,6 +161,18 @@ static PixelChannels **AcquirePixelThreadSet(const Image *image)
   size_t
     number_threads;
 
+  /* determine number of images and maximum columns across the list */
+  size_t nimgs = GetImageListLength(image);
+  size_t max_columns = 0;
+  {
+    const Image *p = image;
+    for ( ; p != (const Image *) NULL; p = GetNextImageInList(p))
+      if ((size_t) p->columns > max_columns)
+        max_columns = (size_t) p->columns;
+  }
+  /* allocate length conservatively: columns + number of images + safety margin */
+  size_t length = (size_t) image->columns + nimgs + 8;
+
   number_threads=(size_t) GetMagickResourceLimit(ThreadResource);
   pixels=(PixelChannels **) AcquireQuantumMemory(number_threads,
     sizeof(*pixels));
@@ -172,11 +184,11 @@ static PixelChannels **AcquirePixelThreadSet(const Image *image)
     register ssize_t
       j;
 
-    pixels[i]=(PixelChannels *) AcquireQuantumMemory(image->columns,
+    pixels[i]=(PixelChannels *) AcquireQuantumMemory(length,
       sizeof(**pixels));
     if (pixels[i] == (PixelChannels *) NULL)
       return(DestroyPixelThreadSet(pixels));
-    for (j=0; j < (ssize_t) image->columns; j++)
+    for (j=0; j < (ssize_t) length; j++)
     {
       register ssize_t
         k;
@@ -188,6 +200,7 @@ static PixelChannels **AcquirePixelThreadSet(const Image *image)
   return(pixels);
 }
 
+
 static inline double EvaluateMax(const double x,const double y)
 {
   if (x > y)
@@ -541,7 +554,14 @@ MagickExport Image *EvaluateImages(const Image *images,
             status=MagickFalse;
             continue;
           }
-        evaluate_pixel=evaluate_pixels[id];
+        /* allocate per-row buffer sized to number of images for median */
+        evaluate_pixel=(PixelChannels *) NULL;
+        evaluate_pixel=(PixelChannels *) AcquireQuantumMemory(number_images, sizeof(*evaluate_pixel));
+        if (evaluate_pixel == (PixelChannels *) NULL)
+          {
+            status=MagickFalse;
+            continue;
+          }
         for (x=0; x < (ssize_t) image->columns; x++)
         {
           register ssize_t
@@ -592,6 +612,8 @@ MagickExport Image *EvaluateImages(const Image *images,
         }
         if (SyncCacheViewAuthenticPixels(evaluate_view,exception) == MagickFalse)
           status=MagickFalse;
+        if (evaluate_pixel != (PixelChannels *) NULL)
+          evaluate_pixel=(PixelChannels *) RelinquishMagickMemory(evaluate_pixel);
         if (images->progress_monitor != (MagickProgressMonitor) NULL)
           {
             MagickBooleanType
@@ -648,7 +670,13 @@ MagickExport Image *EvaluateImages(const Image *images,
             status=MagickFalse;
             continue;
           }
-        evaluate_pixel=evaluate_pixels[id];
+        /* allocate per-row buffer sized to image columns for non-median ops */
+        evaluate_pixel=(PixelChannels *) AcquireQuantumMemory(image->columns, sizeof(*evaluate_pixel));
+        if (evaluate_pixel == (PixelChannels *) NULL)
+          {
+            status=MagickFalse;
+            continue;
+          }
         for (j=0; j < (ssize_t) image->columns; j++)
           for (i=0; i < MaxPixelChannels; i++)
             evaluate_pixel[j].channel[i]=0.0;
@@ -745,6 +773,8 @@ MagickExport Image *EvaluateImages(const Image *images,
         }
         if (SyncCacheViewAuthenticPixels(evaluate_view,exception) == MagickFalse)
           status=MagickFalse;
+        if (evaluate_pixel != (PixelChannels *) NULL)
+          evaluate_pixel=(PixelChannels *) RelinquishMagickMemory(evaluate_pixel);
         if (images->progress_monitor != (MagickProgressMonitor) NULL)
           {
             MagickBooleanType