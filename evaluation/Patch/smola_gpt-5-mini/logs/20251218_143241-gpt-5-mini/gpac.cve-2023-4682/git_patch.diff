diff --git a/src/filters/dmx_avi.c b/src/filters/dmx_avi.c
index 866a793..1aa35e4 100644
--- a/src/filters/dmx_avi.c
+++ b/src/filters/dmx_avi.c
@@ -519,10 +519,44 @@ GF_Err avidmx_process(GF_Filter *filter)
 			cts = ctx->nb_frame_sent * ctx->fps.den;
 
 			if (size > 4) {
-				GF_FilterPacket *dst_pck = gf_filter_pck_new_alloc(ctx->v_opid, size, &pck_data);
-				if (!dst_pck) return GF_OUT_OF_MEM;
-				AVI_read_frame(ctx->avi, pck_data, &key);
-				gf_filter_pck_set_byte_offset(dst_pck, file_offset);
+				u32 _pck_sz = 0;
+			GF_FilterPacket *dst_pck = gf_filter_pck_new_alloc(ctx->v_opid, size, &pck_data);
+			if (!dst_pck) return GF_OUT_OF_MEM;
+			/* Allocate a fresh buffer and attach it using public helper to avoid touching internal fields */
+			{
+				u8 *tmpbuf = (u8*)gf_malloc((u32)size);
+				if (!tmpbuf) { gf_filter_pck_discard(dst_pck); return GF_OUT_OF_MEM; }
+				gf_filter_pck_check_realloc(dst_pck, tmpbuf, (u32)size);
+			}
+			pck_data = (u8*)gf_filter_pck_get_data(dst_pck, &_pck_sz);
+			/* Guard: ensure we never ask the reader to write more bytes than
+			   the packet buffer actually holds. If the index reports a larger
+			   frame size than the allocated buffer, clamp the read size to
+			   the buffer size to avoid heap overflows. This may result in
+			   truncated frames but prevents unsafe writes. */
+			if ((u32)size > _pck_sz) {
+				size = (s32)_pck_sz;
+			}
+
+			{
+				/* Read directly into the packet buffer but cap the read to the
+				   allocated buffer size to avoid heap overflows. Use the
+				   pre-computed file_offset. */
+				u32 idx_len = (u32) ctx->avi->video_index[ctx->cur_frame].len;
+				u32 toread = idx_len;
+				if (toread > _pck_sz) toread = _pck_sz;
+				if (gf_fseek(ctx->avi->fdes, file_offset, SEEK_SET) == (u64)-1) {
+					AVI_errno = AVI_ERR_READ;
+				} else {
+					u32 nb = (u32) gf_fread(pck_data, (size_t)toread, ctx->avi->fdes);
+					if (nb != toread) {
+						/* partial read -> mark error but continue with what we have */
+						AVI_errno = AVI_ERR_READ;
+					}
+				}
+				key = (ctx->avi->video_index[ctx->cur_frame].key==0x10)?1:0;
+			}
+			gf_filter_pck_set_byte_offset(dst_pck, file_offset);
 				gf_filter_pck_set_cts(dst_pck, cts);
 				gf_filter_pck_set_duration(dst_pck, ctx->fps.den);
 				gf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);