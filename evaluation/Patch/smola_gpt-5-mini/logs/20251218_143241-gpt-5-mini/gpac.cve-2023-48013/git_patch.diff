diff --git a/src/filter_core/filter_pck.c b/src/filter_core/filter_pck.c
index b093e8a..2666b06 100644
--- a/src/filter_core/filter_pck.c
+++ b/src/filter_core/filter_pck.c
@@ -24,6 +24,7 @@
  */
 
 #include "filter_session.h"
+#include <string.h>
 
 static void gf_filter_pck_reset_props(GF_FilterPacket *pck, GF_FilterPid *pid)
 {
@@ -1843,7 +1844,18 @@ GF_Err gf_filter_pck_expand(GF_FilterPacket *pck, u32 nb_bytes_to_add, u8 **data
 
 	if (pck->data_length + nb_bytes_to_add > pck->alloc_size) {
 		pck->alloc_size = pck->data_length + nb_bytes_to_add;
-		pck->data = gf_realloc(pck->data, pck->alloc_size);
+		/* Avoid using realloc on packet data to prevent freeing buffers that may be shared
+		   with other packet objects in reservoirs. Allocate a new buffer and copy the
+		   existing data. This prevents double-free when other packets still reference
+		   the old buffer. */
+		{
+			char *new_data = (char*)gf_malloc(pck->alloc_size);
+			if (!new_data) return GF_OUT_OF_MEM;
+			if (pck->data && pck->data_length) memcpy(new_data, pck->data, pck->data_length);
+			/* Do not free the old buffer here as it may be referenced by other packets. */
+			pck->data = new_data;
+		}
+
 #ifdef GPAC_MEMORY_TRACKING
 		pck->pid->filter->session->nb_realloc_pck++;
 #endif
diff --git a/src/isomedia/media.c b/src/isomedia/media.c
index 2a2d614..0336e0e 100644
--- a/src/isomedia/media.c
+++ b/src/isomedia/media.c
@@ -616,10 +616,21 @@ GF_Err Media_GetSample(GF_MediaBox *mdia, u32 sampleNumber, GF_ISOSample **samp,
 		/*and finally get the data, include padding if needed*/
 		if ((*samp)->alloc_size) {
 			if ((*samp)->alloc_size < data_size + mdia->mediaTrack->padding_bytes) {
-				(*samp)->data = (char *) gf_realloc((*samp)->data, sizeof(char) * ( data_size + mdia->mediaTrack->padding_bytes) );
-				if (! (*samp)->data) return GF_OUT_OF_MEM;
-
+				{
+				/* Allocate a new buffer instead of using realloc to avoid freeing memory
+				   that might be shared with other packet objects. Copy existing content
+				   into the newly allocated buffer. This prevents potential double-free
+				   when other owners still reference the old buffer. */
+				char *new_buf = (char *)gf_malloc(sizeof(char) * (data_size + mdia->mediaTrack->padding_bytes));
+				if (!new_buf) return GF_OUT_OF_MEM;
+				if ((*samp)->data && (*samp)->alloc_size) {
+					/* copy existing valid data_length bytes */
+					memcpy(new_buf, (*samp)->data, (*samp)->dataLength);
+				}
+				/* do not free old buffer here as it may be referenced elsewhere */
+				(*samp)->data = new_buf;
 				(*samp)->alloc_size = data_size + mdia->mediaTrack->padding_bytes;
+}
 			}
 		} else {
 			if (ext_realloc) {