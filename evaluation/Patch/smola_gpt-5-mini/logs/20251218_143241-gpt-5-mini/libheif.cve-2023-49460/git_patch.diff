diff --git a/libheif/uncompressed_image.cc b/libheif/uncompressed_image.cc
index 5218165..72a4aaa 100644
--- a/libheif/uncompressed_image.cc
+++ b/libheif/uncompressed_image.cc
@@ -664,13 +664,37 @@ Error UncompressedImageCodec::decode_uncompressed_image(const std::shared_ptr<co
     return error;
   }
 
-  img = std::make_shared<HeifPixelImage>();
   heif_chroma chroma;
   heif_colorspace colourspace;
   error = get_heif_chroma_uncompressed(uncC, cmpd, &chroma, &colourspace);
   if (error) {
     return error;
   }
+
+  // Sanity-check that the provided uncompressed data is large enough to hold the image.
+  uint64_t bytes_per_pixel_full = (uint64_t)get_bytes_per_pixel(uncC);
+  uint64_t total_pixels = (uint64_t)width * (uint64_t)height;
+  uint32_t numTileColumns = uncC->get_number_of_tile_columns();
+  uint32_t numTileRows = uncC->get_number_of_tile_rows();
+  uint32_t tile_width = width / numTileColumns;
+  uint32_t tile_height = height / numTileRows;
+  uint64_t content_bytes_per_tile = (uint64_t)tile_width * (uint64_t)tile_height * bytes_per_pixel_full;
+  uint32_t tile_align_size = uncC->get_tile_align_size();
+  uint64_t tile_padding = 0;
+  if (tile_align_size > 0) {
+    tile_padding = tile_align_size - (content_bytes_per_tile % tile_align_size);
+  }
+  uint64_t bytes_per_tile = content_bytes_per_tile + tile_padding;
+  uint64_t numTiles = (uint64_t)numTileColumns * (uint64_t)numTileRows;
+  uint64_t required_by_tiles = bytes_per_tile * numTiles;
+  uint64_t required_by_pixels = total_pixels * bytes_per_pixel_full;
+  uint64_t required = std::max(required_by_tiles, required_by_pixels);
+  if (uncompressed_data.size() < required) {
+    return Error(heif_error_Invalid_input, heif_suberror_Invalid_parameter_value, "Insufficient uncompressed data");
+  }
+
+  img = std::make_shared<HeifPixelImage>();
+  struct ImgGuard { std::shared_ptr<HeifPixelImage>& img; bool armed; ImgGuard(std::shared_ptr<HeifPixelImage>& i): img(i), armed(true) {} void disarm(){armed=false;} ~ImgGuard(){ if(armed) img.reset(); } } guard(img);
   img->create(width, height,
               colourspace,
               chroma);
@@ -725,10 +749,6 @@ Error UncompressedImageCodec::decode_uncompressed_image(const std::shared_ptr<co
 
   // TODO: properly interpret uncompressed_data per uncC config, subsampling etc.
   uint32_t bytes_per_channel = width * height;
-  uint32_t numTileColumns = uncC->get_number_of_tile_columns();
-  uint32_t numTileRows = uncC->get_number_of_tile_rows();
-  uint32_t tile_width = width / numTileColumns;
-  uint32_t tile_height = height / numTileRows;
   if (uncC->get_interleave_type() == interleave_type_component) {
     // Source is planar
     // TODO: assumes 8 bits
@@ -743,7 +763,17 @@ Error UncompressedImageCodec::decode_uncompressed_image(const std::shared_ptr<co
       int stride;
       uint8_t* dst = img->get_plane(channels[c], &stride);
       if ((numTileRows == 1) && (numTileColumns == 1) && (((uint32_t) stride) == width)) {
-        memcpy(dst, uncompressed_data.data() + c * bytes_per_channel, bytes_per_channel);
+        {
+              size_t src_size = uncompressed_data.size();
+              size_t need = (size_t)bytes_per_channel;
+              size_t src_base = (size_t)c * (size_t)bytes_per_channel;
+              size_t dst_size = (size_t)stride * (size_t)height;
+              if (src_base + need <= src_size && need <= dst_size) {
+                memcpy(dst, uncompressed_data.data() + src_base, need);
+              } else {
+                return Error(heif_error_Invalid_input, heif_suberror_Invalid_parameter_value, "Insufficient uncompressed data");
+              }
+            }
       }
       else {
         int pixel_offset = channel_to_pixelOffset[channels[c]];
@@ -755,7 +785,16 @@ Error UncompressedImageCodec::decode_uncompressed_image(const std::shared_ptr<co
             long unsigned int tile_base_offset = tile_idx * bytes_per_tile;
             long unsigned int src_offset = tile_base_offset + pixel_offset * tile_width * tile_height;
             long unsigned int dst_offset = row * stride + col;
-            memcpy(dst + dst_offset, uncompressed_data.data() + src_offset /** + row * tile_width **/, tile_width);   // TODO: ** is a hack
+            {
+              size_t src_size = uncompressed_data.size();
+              size_t dst_size = (size_t)stride * (size_t)height;
+              size_t need = (size_t)tile_width;
+              if (src_offset + need <= src_size && (size_t)dst_offset + need <= dst_size) {
+                memcpy(dst + dst_offset, uncompressed_data.data() + src_offset, need);   // TODO: ** is a hack
+              } else {
+                return Error(heif_error_Invalid_input, heif_suberror_Invalid_parameter_value, "Insufficient uncompressed data");
+              }
+            }   // TODO: ** is a hack
           }
         }
       }
@@ -781,7 +820,15 @@ Error UncompressedImageCodec::decode_uncompressed_image(const std::shared_ptr<co
           size_t tile_offset = tile_row_offset + tile_col * pixel_stride + pixel_offset;
           size_t src_offset = tile_base_offset + tile_offset;
           uint32_t dstPixelIndex = row * stride + col;
-          dst[dstPixelIndex] = src[src_offset];
+          {
+          size_t src_size = uncompressed_data.size();
+          size_t dst_size = (size_t)stride * (size_t)height;
+          if (src_offset < src_size && dstPixelIndex < dst_size) {
+            dst[dstPixelIndex] = src[src_offset];
+          } else {
+            return Error(heif_error_Invalid_input, heif_suberror_Invalid_parameter_value, "Insufficient uncompressed data");
+          }
+        }
         }
         for (; col < (uint32_t) stride; col++) {
           uint32_t dstPixelIndex = row * stride + col;
@@ -808,7 +855,16 @@ Error UncompressedImageCodec::decode_uncompressed_image(const std::shared_ptr<co
           size_t tile_offset = tile_row_offset + tile_col;
           size_t src_offset = tile_base_offset + tile_offset;
           uint32_t dst_offset = row * stride + col;
-          memcpy(dst + dst_offset, uncompressed_data.data() + src_offset, tile_width);
+          {
+          size_t src_size = uncompressed_data.size();
+          size_t dst_size = (size_t)stride * (size_t)height;
+          size_t need = (size_t)tile_width;
+          if (src_offset + need <= src_size && dst_offset + need <= dst_size) {
+            memcpy(dst + dst_offset, uncompressed_data.data() + src_offset, need);
+          } else {
+            return Error(heif_error_Invalid_input, heif_suberror_Invalid_parameter_value, "Insufficient uncompressed data");
+          }
+        }
         }
         for (; col < (uint32_t) stride; col++) {
           uint32_t dstPixelIndex = row * stride + col;
@@ -817,6 +873,7 @@ Error UncompressedImageCodec::decode_uncompressed_image(const std::shared_ptr<co
       }
     }
   }
+  guard.disarm();
   return Error::Ok;
 }