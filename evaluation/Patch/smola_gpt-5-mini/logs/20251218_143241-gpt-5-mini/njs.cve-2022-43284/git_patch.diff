diff --git a/src/njs_scope.h b/src/njs_scope.h
index e7bfa7c..526e65f 100644
--- a/src/njs_scope.h
+++ b/src/njs_scope.h
@@ -48,18 +48,19 @@ njs_scope_index(njs_scope_t scope, njs_index_t index, njs_level_type_t type,
 njs_inline njs_variable_type_t
 njs_scope_index_var(njs_index_t index)
 {
-    return (njs_variable_type_t) (index & ~NJS_SCOPE_TYPE_MASK);
+    /* lower NJS_SCOPE_VAR_SIZE bits hold the variable type */
+    return (njs_variable_type_t) (index & ((1ULL << NJS_SCOPE_VAR_SIZE) - 1));
 }
 
-
 njs_inline njs_level_type_t
 njs_scope_index_type(njs_index_t index)
 {
+    /* extract type bits placed after the variable type bits */
     return (njs_level_type_t) ((index >> NJS_SCOPE_VAR_SIZE)
-                               & ~NJS_SCOPE_TYPE_MASK);
+                               & ((1U << (NJS_SCOPE_TYPE_OFFSET
+                                        - NJS_SCOPE_VAR_SIZE)) - 1));
 }
 
-
 njs_inline uint32_t
 njs_scope_index_value(njs_index_t index)
 {
@@ -70,8 +71,34 @@ njs_scope_index_value(njs_index_t index)
 njs_inline njs_value_t *
 njs_scope_value(njs_vm_t *vm, njs_index_t index)
 {
-    return vm->levels[njs_scope_index_type(index)]
-                     [njs_scope_index_value(index)];
+    njs_level_type_t  type;
+    uint32_t          value_index;
+
+    type = njs_scope_index_type(index);
+
+    /* Ensure the level array exists.  If it doesn't, lazily allocate
+     * a small array large enough to hold the requested index.  This
+     * prevents NULL dereference when bytecode references a scope level
+     * that hasn't been initialized yet. */
+    if (type >= NJS_LEVEL_MAX) {
+        return NULL;
+    }
+
+    value_index = njs_scope_index_value(index);
+
+    if (vm->levels[type] == NULL) {
+        njs_value_t **refs;
+
+        /* Allocate (value_index + 1) entries. */
+        refs = njs_scope_make(vm, value_index + 1);
+        if (njs_slow_path(refs == NULL)) {
+            return NULL;
+        }
+
+        vm->levels[type] = refs;
+    }
+
+    return vm->levels[type][value_index];
 }
 
 
@@ -82,6 +109,14 @@ njs_scope_valid_value(njs_vm_t *vm, njs_index_t index)
 
     value = njs_scope_value(vm, index);
 
+    /* njs_scope_value can return NULL if the corresponding level is
+     * not set or the index is out of range.  Propagate the error to the
+     * caller instead of dereferencing NULL. */
+    if (njs_slow_path(value == NULL)) {
+        njs_reference_error(vm, "invalid variable access");
+        return NULL;
+    }
+
     if (!njs_is_valid(value)) {
         if (njs_scope_index_var(index) <= NJS_VARIABLE_LET) {
             njs_reference_error(vm, "cannot access variable "
@@ -99,10 +134,29 @@ njs_scope_valid_value(njs_vm_t *vm, njs_index_t index)
 njs_inline void
 njs_scope_value_set(njs_vm_t *vm, njs_index_t index, njs_value_t *value)
 {
-    vm->levels[njs_scope_index_type(index)]
-              [njs_scope_index_value(index)] = value;
-}
+    njs_level_type_t  type;
+    uint32_t          value_index;
+
+    type = njs_scope_index_type(index);
+    value_index = njs_scope_index_value(index);
+
+    if (type >= NJS_LEVEL_MAX) {
+        return;
+    }
 
+    if (vm->levels[type] == NULL) {
+        njs_value_t **refs;
+
+        refs = njs_scope_make(vm, value_index + 1);
+        if (njs_slow_path(refs == NULL)) {
+            return;
+        }
+
+        vm->levels[type] = refs;
+    }
+
+    vm->levels[type][value_index] = value;
+}
 
 njs_inline njs_value_t *
 njs_scope_value_clone(njs_vm_t *vm, njs_index_t index, njs_value_t *value)
diff --git a/src/njs_vmcode.c b/src/njs_vmcode.c
index 3039642..21b1e4e 100644
--- a/src/njs_vmcode.c
+++ b/src/njs_vmcode.c
@@ -1222,6 +1222,10 @@ njs_vmcode_function_copy(njs_vm_t *vm, njs_value_t *value, njs_index_t retidx)
 
     retval = njs_scope_valid_value(vm, retidx);
 
+    if (njs_slow_path(retval == NULL)) {
+        return NJS_ERROR;
+    }
+
     if (njs_is_undefined(retval)) {
         *retval = *value;