diff --git a/build/src/bin/common/opj_apps_config.h b/build/src/bin/common/opj_apps_config.h
new file mode 100644
index 0000000..43c63ca
--- /dev/null
+++ b/build/src/bin/common/opj_apps_config.h
@@ -0,0 +1,15 @@
+#include "opj_config_private.h"
+
+/* create opj_apps_config.h for CMake */
+
+/* #undef OPJ_HAVE_LIBPNG */
+/* #undef OPJ_HAVE_PNG_H */
+/* #undef OPJ_HAVE_LIBTIFF */
+/* #undef OPJ_HAVE_TIFF_H */
+
+/* #undef OPJ_HAVE_LIBLCMS1 */
+/* #undef OPJ_HAVE_LIBLCMS2 */
+/* #undef OPJ_HAVE_LCMS1_H */
+/* #undef OPJ_HAVE_LCMS2_H */
+
+
diff --git a/build/src/lib/openjp2/opj_config.h b/build/src/lib/openjp2/opj_config.h
new file mode 100644
index 0000000..016ceab
--- /dev/null
+++ b/build/src/lib/openjp2/opj_config.h
@@ -0,0 +1,10 @@
+/* create opj_config.h for CMake */
+#define OPJ_HAVE_STDINT_H 		1
+
+/*--------------------------------------------------------------------------*/
+/* OpenJPEG Versioning                                                      */
+
+/* Version number. */
+#define OPJ_VERSION_MAJOR 2
+#define OPJ_VERSION_MINOR 4
+#define OPJ_VERSION_BUILD 0
diff --git a/build/src/lib/openjp2/opj_config_private.h b/build/src/lib/openjp2/opj_config_private.h
new file mode 100644
index 0000000..5d2a15b
--- /dev/null
+++ b/build/src/lib/openjp2/opj_config_private.h
@@ -0,0 +1,49 @@
+/* create opj_config_private.h for CMake */
+#define OPJ_HAVE_INTTYPES_H 	1
+
+#define OPJ_PACKAGE_VERSION "2.4.0"
+
+/* Not used by openjp2*/
+/*#define HAVE_MEMORY_H 1*/
+/*#define HAVE_STDLIB_H 1*/
+/*#define HAVE_STRINGS_H 1*/
+/*#define HAVE_STRING_H 1*/
+/*#define HAVE_SYS_STAT_H 1*/
+/*#define HAVE_SYS_TYPES_H 1 */
+/*#define HAVE_UNISTD_H 1*/
+
+/* #undef _LARGEFILE_SOURCE */
+/* #undef _LARGE_FILES */
+/* #undef _FILE_OFFSET_BITS */
+#define OPJ_HAVE_FSEEKO ON
+
+/* find whether or not have <malloc.h> */
+#define OPJ_HAVE_MALLOC_H
+/* check if function `aligned_alloc` exists */
+/* #undef OPJ_HAVE_ALIGNED_ALLOC */
+/* check if function `_aligned_malloc` exists */
+/* #undef OPJ_HAVE__ALIGNED_MALLOC */
+/* check if function `memalign` exists */
+#define OPJ_HAVE_MEMALIGN
+/* check if function `posix_memalign` exists */
+#define OPJ_HAVE_POSIX_MEMALIGN
+
+#if !defined(_POSIX_C_SOURCE)
+#if defined(OPJ_HAVE_FSEEKO) || defined(OPJ_HAVE_POSIX_MEMALIGN)
+/* Get declarations of fseeko, ftello, posix_memalign. */
+#define _POSIX_C_SOURCE 200112L
+#endif
+#endif
+
+/* Byte order.  */
+/* All compilers that support Mac OS X define either __BIG_ENDIAN__ or
+__LITTLE_ENDIAN__ to match the endianness of the architecture being
+compiled for. This is not necessarily the same as the architecture of the
+machine doing the building. In order to support Universal Binaries on
+Mac OS X, we prefer those defines to decide the endianness.
+On other platforms we use the result of the TRY_RUN. */
+#if !defined(__APPLE__)
+/* #undef OPJ_BIG_ENDIAN */
+#elif defined(__BIG_ENDIAN__)
+# define OPJ_BIG_ENDIAN
+#endif
diff --git a/src/bin/common/color.c b/src/bin/common/color.c
index 27f15f1..af949ed 100644
--- a/src/bin/common/color.c
+++ b/src/bin/common/color.c
@@ -277,6 +277,11 @@ static void sycc420_to_rgb(opj_image_t *img)
     offy = img->y0 & 1U;
     loopmaxh = maxh - offy;
 
+    /* compute cb/cr sample buffer size using actual chroma component dimensions */
+    size_t cbw = (size_t)img->comps[1].w;
+    size_t cbh = (size_t)img->comps[1].h;
+    size_t cb_size = cbw * cbh;
+
     if (offy > 0U) {
         size_t j;
 
@@ -297,58 +302,49 @@ static void sycc420_to_rgb(opj_image_t *img)
         ng = g + maxw;
         nb = b + maxw;
 
+        size_t cb_row = (offy + i) >> 1; /* chroma row index */
+
         if (offx > 0U) {
+            /* first column: top uses 0, bottom uses current cb/cr if available */
             sycc_to_rgb(offset, upb, *y, 0, 0, r, g, b);
-            ++y;
-            ++r;
-            ++g;
-            ++b;
-            sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);
-            ++ny;
-            ++nr;
-            ++ng;
-            ++nb;
+            ++y; ++r; ++g; ++b;
+
+            size_t cb_col = (offx) >> 1;
+            size_t idx = cb_row * cbw + cb_col;
+            int cb_val = (idx < cb_size) ? cb[idx] : 0;
+            int cr_val = (idx < cb_size) ? cr[idx] : 0;
+
+            sycc_to_rgb(offset, upb, *ny, cb_val, cr_val, nr, ng, nb);
+            ++ny; ++nr; ++ng; ++nb;
         }
 
         for (j = 0; j < (loopmaxw & ~(size_t)1U); j += 2U) {
-            sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
-            ++y;
-            ++r;
-            ++g;
-            ++b;
-            sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
-            ++y;
-            ++r;
-            ++g;
-            ++b;
-
-            sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);
-            ++ny;
-            ++nr;
-            ++ng;
-            ++nb;
-            sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);
-            ++ny;
-            ++nr;
-            ++ng;
-            ++nb;
-            ++cb;
-            ++cr;
+            size_t cb_col = (offx + j) >> 1;
+            size_t idx = cb_row * cbw + cb_col;
+            int cb_val = (idx < cb_size) ? cb[idx] : 0;
+            int cr_val = (idx < cb_size) ? cr[idx] : 0;
+
+            sycc_to_rgb(offset, upb, *y, cb_val, cr_val, r, g, b);
+            ++y; ++r; ++g; ++b;
+            sycc_to_rgb(offset, upb, *y, cb_val, cr_val, r, g, b);
+            ++y; ++r; ++g; ++b;
+
+            sycc_to_rgb(offset, upb, *ny, cb_val, cr_val, nr, ng, nb);
+            ++ny; ++nr; ++ng; ++nb;
+            sycc_to_rgb(offset, upb, *ny, cb_val, cr_val, nr, ng, nb);
+            ++ny; ++nr; ++ng; ++nb;
         }
         if (j < loopmaxw) {
-            sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
-            ++y;
-            ++r;
-            ++g;
-            ++b;
+            size_t cb_col = (offx + j) >> 1;
+            size_t idx = cb_row * cbw + cb_col;
+            int cb_val = (idx < cb_size) ? cb[idx] : 0;
+            int cr_val = (idx < cb_size) ? cr[idx] : 0;
 
-            sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);
-            ++ny;
-            ++nr;
-            ++ng;
-            ++nb;
-            ++cb;
-            ++cr;
+            sycc_to_rgb(offset, upb, *y, cb_val, cr_val, r, g, b);
+            ++y; ++r; ++g; ++b;
+
+            sycc_to_rgb(offset, upb, *ny, cb_val, cr_val, nr, ng, nb);
+            ++ny; ++nr; ++ng; ++nb;
         }
         y += maxw;
         r += maxw;
@@ -357,26 +353,28 @@ static void sycc420_to_rgb(opj_image_t *img)
     }
     if (i < loopmaxh) {
         size_t j;
+        size_t cb_row = (offy + i) >> 1;
 
         for (j = 0U; j < (maxw & ~(size_t)1U); j += 2U) {
-            sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
+            size_t cb_col = (offx + j) >> 1;
+            size_t idx = cb_row * cbw + cb_col;
+            int cb_val = (idx < cb_size) ? cb[idx] : 0;
+            int cr_val = (idx < cb_size) ? cr[idx] : 0;
 
-            ++y;
-            ++r;
-            ++g;
-            ++b;
+            sycc_to_rgb(offset, upb, *y, cb_val, cr_val, r, g, b);
 
-            sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
+            ++y; ++r; ++g; ++b;
 
-            ++y;
-            ++r;
-            ++g;
-            ++b;
-            ++cb;
-            ++cr;
+            sycc_to_rgb(offset, upb, *y, cb_val, cr_val, r, g, b);
+
+            ++y; ++r; ++g; ++b;
         }
         if (j < maxw) {
-            sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
+            size_t cb_col = (offx + j) >> 1;
+            size_t idx = cb_row * cbw + cb_col;
+            int cb_val = (idx < cb_size) ? cb[idx] : 0;
+            int cr_val = (idx < cb_size) ? cr[idx] : 0;
+            sycc_to_rgb(offset, upb, *y, cb_val, cr_val, r, g, b);
         }
     }