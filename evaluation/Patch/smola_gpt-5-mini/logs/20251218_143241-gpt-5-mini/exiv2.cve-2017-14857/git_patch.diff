diff --git a/src/futils.cpp b/src/futils.cpp
index d142718..be78a68 100644
--- a/src/futils.cpp
+++ b/src/futils.cpp
@@ -52,6 +52,8 @@ EXIV2_RCSID("@(#) $Id$")
 #if defined EXV_HAVE_STRERROR_R && !defined EXV_HAVE_DECL_STRERROR_R
 # ifdef EXV_STRERROR_R_CHAR_P
 extern char *strerror_r(int errnum, char *buf, size_t n);
+# elif defined(_GNU_SOURCE)
+extern char *strerror_r(int errnum, char *buf, size_t n);
 # else
 extern int strerror_r(int errnum, char *buf, size_t n);
 # endif
@@ -241,8 +243,8 @@ namespace Exiv2 {
     Protocol fileProtocol(const std::string& path) {
         Protocol result = pFile ;
         struct {
-        	std::string name ;
-        	Protocol    prot ;
+                std::string name ;
+                Protocol    prot ;
         } prots[] =
         { { "http://"   ,pHttp     }
         , { "https://"  ,pHttps    }
@@ -254,8 +256,8 @@ namespace Exiv2 {
         , { "-"         ,pStdin    }
         };
         for ( size_t i = 0 ; result == pFile && i < sizeof(prots)/sizeof(prots[0]) ; i ++ )
-        	if ( path.find(prots[i].name) == 0 )
-        		result = prots[i].prot;
+                if ( path.find(prots[i].name) == 0 )
+                        result = prots[i].prot;
 
         return result;
     } // fileProtocol
@@ -263,8 +265,8 @@ namespace Exiv2 {
     Protocol fileProtocol(const std::wstring& wpath) {
         Protocol result = pFile ;
         struct {
-        	std::wstring wname ;
-        	Protocol      prot ;
+                std::wstring wname ;
+                Protocol      prot ;
         } prots[] =
         { { L"http://"   ,pHttp     }
         , { L"https://"  ,pHttps    }
@@ -276,21 +278,21 @@ namespace Exiv2 {
         , { L"-"         ,pStdin    }
         };
         for ( size_t i = 0 ; result == pFile && i < sizeof(prots)/sizeof(prots[0]) ; i ++ )
-        	if ( wpath.find(prots[i].wname) == 0 )
-        		result = prots[i].prot;
+                if ( wpath.find(prots[i].wname) == 0 )
+                        result = prots[i].prot;
 
         return result;
     } // fileProtocol
 #endif
     bool fileExists(const std::string& path, bool ct)
     {
-		// special case: accept "-" (means stdin)
+                // special case: accept "-" (means stdin)
         if (path.compare("-") == 0 || fileProtocol(path)) {
-			return true;
+                        return true;
         }
 
         struct stat buf;
-		int ret = ::stat(path.c_str(), &buf);
+                int ret = ::stat(path.c_str(), &buf);
         if (0 != ret)                    return false;
         if (ct && !S_ISREG(buf.st_mode)) return false;
         return true;
@@ -299,9 +301,9 @@ namespace Exiv2 {
 #ifdef EXV_UNICODE_PATH
     bool fileExists(const std::wstring& wpath, bool ct)
     {
-		// special case: accept "-" (means stdin)
+                // special case: accept "-" (means stdin)
         if (wpath.compare(L"-") == 0 || fileProtocol(wpath)) {
-			return true;
+                        return true;
         }
 
         struct _stat buf;
diff --git a/src/image.cpp b/src/image.cpp
index c19fb98..52693eb 100644
--- a/src/image.cpp
+++ b/src/image.cpp
@@ -402,11 +402,22 @@ namespace Exiv2 {
                 // if ( offset > io.size() ) offset = 0; // Denial of service?
 
                 // #55 memory allocation crash test/data/POC8
-                long long allocate = (long long) (size*count + pad+20);
-                if ( allocate > (long long) io.size() ) {
+                // Compute required allocation using 64-bit arithmetic to avoid
+                // 32-bit overflow when size*count is large. Also validate the
+                // resulting size against the IO size to prevent excessive
+                // allocations / reads.
+                long long required = (long long)size * (long long)count + (long long)pad + 20LL;
+                if (required < 0) { // sanity
                     throw Error(57);
                 }
-                DataBuf  buf((long)allocate);  // allocate a buffer
+                if ( required > (long long) io.size() ) {
+                    throw Error(57);
+                }
+                // Ensure required fits into a long for DataBuf constructor
+                if ( required > (long long) std::numeric_limits<long>::max() ) {
+                    throw Error(57);
+                }
+                DataBuf  buf((long)required);  // allocate a buffer
                 std::memcpy(buf.pData_,dir.pData_+8,4);  // copy dir[8:11] into buffer (short strings)
                 const bool bOffsetIsPointer = count*size > 4;
 
@@ -741,23 +752,31 @@ namespace Exiv2 {
 
     const std::string& Image::tagName(uint16_t tag)
     {
-        if ( init_ ) {
+        // Use a process-wide static cache for tag names rather than
+        // storing them per-instance. This avoids issues during
+        // destruction of Image instances where the per-instance map
+        // could contain strings that lead to invalid frees.
+        static std::map<int,std::string> staticTags;
+        static bool initialized = false;
+        if (!initialized) {
+            initialized = true;
+            const TagInfo* ti;
             int idx;
-            const TagInfo* ti ;
-            for (ti = Internal::  mnTagList(), idx = 0; ti[idx].tag_ != 0xffff; ++idx) tags_[ti[idx].tag_] = ti[idx].name_;
-            for (ti = Internal:: iopTagList(), idx = 0; ti[idx].tag_ != 0xffff; ++idx) tags_[ti[idx].tag_] = ti[idx].name_;
-            for (ti = Internal:: gpsTagList(), idx = 0; ti[idx].tag_ != 0xffff; ++idx) tags_[ti[idx].tag_] = ti[idx].name_;
-            for (ti = Internal:: ifdTagList(), idx = 0; ti[idx].tag_ != 0xffff; ++idx) tags_[ti[idx].tag_] = ti[idx].name_;
-            for (ti = Internal::exifTagList(), idx = 0; ti[idx].tag_ != 0xffff; ++idx) tags_[ti[idx].tag_] = ti[idx].name_;
-            for (ti = Internal:: mpfTagList(), idx = 0; ti[idx].tag_ != 0xffff; ++idx) tags_[ti[idx].tag_] = ti[idx].name_;
+            for (ti = Internal::mnTagList(), idx = 0; ti[idx].tag_ != 0xffff; ++idx) staticTags[ti[idx].tag_] = ti[idx].name_;
+            for (ti = Internal::iopTagList(), idx = 0; ti[idx].tag_ != 0xffff; ++idx) staticTags[ti[idx].tag_] = ti[idx].name_;
+            for (ti = Internal::gpsTagList(), idx = 0; ti[idx].tag_ != 0xffff; ++idx) staticTags[ti[idx].tag_] = ti[idx].name_;
+            for (ti = Internal::ifdTagList(), idx = 0; ti[idx].tag_ != 0xffff; ++idx) staticTags[ti[idx].tag_] = ti[idx].name_;
+            for (ti = Internal::exifTagList(), idx = 0; ti[idx].tag_ != 0xffff; ++idx) staticTags[ti[idx].tag_] = ti[idx].name_;
+            for (ti = Internal::mpfTagList(), idx = 0; ti[idx].tag_ != 0xffff; ++idx) staticTags[ti[idx].tag_] = ti[idx].name_;
             for (ti = Internal::Nikon1MakerNote::tagList(), idx = 0
-                                                    ; ti[idx].tag_ != 0xffff; ++idx) tags_[ti[idx].tag_] = ti[idx].name_;
+                                                    ; ti[idx].tag_ != 0xffff; ++idx) staticTags[ti[idx].tag_] = ti[idx].name_;
         }
-        init_ = false;
-
-        return tags_[tag] ;
+        // Return reference to static map entry. Operator[] will create an
+        // empty string if not present, which is fine.
+        return staticTags[tag];
     }
 
+
     AccessMode ImageFactory::checkMode(int type, MetadataId metadataId)
     {
         const Registry* r = find(registry, type);