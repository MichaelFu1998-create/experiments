diff --git a/src/spss/readstat_por.c b/src/spss/readstat_por.c
index e922358..0aa2f9d 100644
--- a/src/spss/readstat_por.c
+++ b/src/spss/readstat_por.c
@@ -1,5 +1,7 @@
 #include <stdlib.h>
 #include <iconv.h>
+#include <wchar.h>
+#include <string.h>
 
 #include "../readstat.h"
 #include "../CKHashTable.h"
@@ -144,28 +146,42 @@ ssize_t por_utf8_decode(
         const char *input, size_t input_len,
         char *output, size_t output_len,
         uint8_t *lookup, size_t lookup_len) {
+    /*
+     * Decode a UTF-8 input buffer of known length into single-byte
+     * values using the provided lookup table. The previous
+     * implementation relied on sscanf and a NUL-terminated input,
+     * which could read past the provided input_len and trigger
+     * buffer-overreads. Use mbrtowc with explicit bounds to avoid
+     * reading beyond input_len.
+     */
     int offset = 0;
-    wchar_t codepoint = 0;
-    while (1) {
-        int char_len = 0;
-        if (offset + 1 > output_len)
+    size_t in_pos = 0;
+    mbstate_t state;
+    memset(&state, 0, sizeof(state));
+
+    while (in_pos < input_len) {
+        if (offset + 1 > (int)output_len)
             return offset;
 
-        unsigned char val = *input;
+        unsigned char val = (unsigned char)input[in_pos];
 
         if (val >= 0x20 && val < 0x7F) {
             if (!lookup[val])
                 return -1;
             output[offset++] = lookup[val];
-            input++;
+            in_pos++;
         } else {
-            int conversions = sscanf(input, "%lc%n", &codepoint, &char_len);
-
-            if (conversions == 0 || codepoint >= lookup_len || lookup[codepoint] == 0) {
+            wchar_t codepoint = 0;
+            size_t rc = mbrtowc(&codepoint, input + in_pos, input_len - in_pos, &state);
+            if (rc == (size_t)-1 || rc == (size_t)-2 || rc == 0) {
+                /* invalid or incomplete multibyte sequence */
+                return -1;
+            }
+            if ((size_t)codepoint >= lookup_len || lookup[(size_t)codepoint] == 0) {
                 return -1;
             }
-            output[offset++] = lookup[codepoint];
-            input += char_len;
+            output[offset++] = lookup[(size_t)codepoint];
+            in_pos += rc;
         }
     }
     return offset;
diff --git a/src/stata/readstat_dta_parse_timestamp.c b/src/stata/readstat_dta_parse_timestamp.c
index 9593743..c472da7 100644
--- a/src/stata/readstat_dta_parse_timestamp.c
+++ b/src/stata/readstat_dta_parse_timestamp.c
@@ -317,7 +317,7 @@ _again:
 
     if (cs < 40|| p != pe) {
         if (ctx->error_handler) {
-            snprintf(ctx->error_buf, sizeof(ctx->error_buf), "Invalid timestamp string (length=%d): %*s", (int)len, (int)-len, data);
+            snprintf(ctx->error_buf, sizeof(ctx->error_buf), "Invalid timestamp string (length=%d): %.*s", (int)len, (int)len, data);
             ctx->error_handler(ctx->error_buf, ctx->user_ctx);
         }
         retval = READSTAT_ERROR_BAD_TIMESTAMP;