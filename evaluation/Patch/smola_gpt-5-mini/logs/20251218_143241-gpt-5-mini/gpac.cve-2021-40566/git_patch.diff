diff --git a/src/filters/reframe_mpgvid.c b/src/filters/reframe_mpgvid.c
index 308546f..2bff519 100644
--- a/src/filters/reframe_mpgvid.c
+++ b/src/filters/reframe_mpgvid.c
@@ -520,7 +520,7 @@ GF_Err mpgviddmx_process(GF_Filter *filter)
 	s64 vosh_start = -1;
 	s64 vosh_end = -1;
 	GF_Err e;
-	char *data;
+	char *data; char *orig_data; u32 orig_pck_size;
 	u8 *start;
 	u32 pck_size;
 	s32 remain;
@@ -543,6 +543,9 @@ GF_Err mpgviddmx_process(GF_Filter *filter)
 	}
 
 	data = (char *) gf_filter_pck_get_data(pck, &pck_size);
+		/* keep original packet buffer pointer for safe copies */
+		orig_data = data;
+		orig_pck_size = (u32)pck_size;
 	byte_offset = gf_filter_pck_get_byte_offset(pck);
 
 	start = data;
@@ -583,7 +586,7 @@ GF_Err mpgviddmx_process(GF_Filter *filter)
 			ctx->hdr_store_alloc = ctx->hdr_store_size + pck_size;
 			ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);
 		}
-		memcpy(ctx->hdr_store + ctx->hdr_store_size, data, sizeof(char)*pck_size);
+		memcpy(ctx->hdr_store + ctx->hdr_store_size, orig_data, sizeof(char)*pck_size);
 		if (byte_offset != GF_FILTER_NO_BO) {
 			if (byte_offset >= ctx->hdr_store_size)
 				byte_offset -= ctx->hdr_store_size;
@@ -713,7 +716,22 @@ GF_Err mpgviddmx_process(GF_Filter *filter)
 					ctx->bytes_in_header = 3;
 				}
 
-				dst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data);
+				{
+			/* Safety: ensure size does not exceed available data to avoid
+'
+			   reading past the packet/hdr_store buffers in malformed inputs.
+'
+			   available = bytes_from_store + remain (if bytes_from_store used)
+'
+			   or remain otherwise. Clamp size to available before allocation. */
+			u64 available = (u64) remain;
+			if (bytes_from_store) available += (u64) bytes_from_store;
+			if (size > available) {
+				GF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, ("[MPGVid] frame size (%llu) larger than available (%llu), clamping\n", (unsigned long long)size, (unsigned long long)available));
+				size = available;
+			}
+			dst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data);
+		}
 				if (!dst_pck) return GF_OUT_OF_MEM;
 
 				if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
@@ -805,12 +823,12 @@ GF_Err mpgviddmx_process(GF_Filter *filter)
 				//not enough data, accumulate until we can parse the full header
 				if (e==GF_EOS) {
 					if (vosh_start<0) vosh_start = 0;
-					if (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {
+					if (ctx->hdr_store_alloc < ctx->hdr_store_size + orig_pck_size - vosh_start) {
 						ctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - vosh_start);
 						ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);
 					}
-					memcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );
-					ctx->hdr_store_size += pck_size - (u32) vosh_start;
+					memcpy(ctx->hdr_store + ctx->hdr_store_size, orig_data + vosh_start, (size_t) (orig_pck_size - vosh_start) );
+					ctx->hdr_store_size += orig_pck_size - (u32) vosh_start;
 					gf_filter_pid_drop_packet(ctx->ipid);
 					return GF_OK;
 				} else if (e != GF_OK) {
@@ -844,12 +862,12 @@ GF_Err mpgviddmx_process(GF_Filter *filter)
 				//not enough data, accumulate until we can parse the full header
 				if (e==GF_EOS) {
 					if (vosh_start<0) vosh_start = 0;
-					if (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {
+					if (ctx->hdr_store_alloc < ctx->hdr_store_size + orig_pck_size - vosh_start) {
 						ctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - (u32) vosh_start);
 						ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);
 					}
-					memcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );
-					ctx->hdr_store_size += pck_size - (u32) vosh_start;
+					memcpy(ctx->hdr_store + ctx->hdr_store_size, orig_data + vosh_start, (size_t) (orig_pck_size - vosh_start) );
+					ctx->hdr_store_size += orig_pck_size - (u32) vosh_start;
 					gf_filter_pid_drop_packet(ctx->ipid);
 					return GF_OK;
 				} else if (e != GF_OK) {
@@ -981,7 +999,22 @@ GF_Err mpgviddmx_process(GF_Filter *filter)
 		}
 		ctx->nb_frames++;
 
-		dst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data);
+		{
+			/* Safety: ensure size does not exceed available data to avoid
+'
+			   reading past the packet/hdr_store buffers in malformed inputs.
+'
+			   available = bytes_from_store + remain (if bytes_from_store used)
+'
+			   or remain otherwise. Clamp size to available before allocation. */
+			u64 available = (u64) remain;
+			if (bytes_from_store) available += (u64) bytes_from_store;
+			if (size > available) {
+				GF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, ("[MPGVid] frame size (%llu) larger than available (%llu), clamping\n", (unsigned long long)size, (unsigned long long)available));
+				size = available;
+			}
+			dst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data);
+		}
 		if (!dst_pck) return GF_OUT_OF_MEM;
 
 		if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);