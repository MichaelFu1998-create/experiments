diff --git a/src/p_lx_elf.cpp b/src/p_lx_elf.cpp
index 822a765..399150d 100644
--- a/src/p_lx_elf.cpp
+++ b/src/p_lx_elf.cpp
@@ -1395,23 +1395,43 @@ PackLinuxElf64arm::buildLoader(const Filter *ft)
 Elf32_Phdr const *
 PackLinuxElf32::elf_find_ptype(unsigned type, Elf32_Phdr const *phdr, unsigned phnum)
 {
-    for (unsigned j = 0; j < phnum; ++j, ++phdr) {
-        if (type == get_te32(&phdr->p_type)) {
-            return phdr;
+    if (phdr == NULL || phnum == 0)
+        return NULL;
+    unsigned max_phnum = 0;
+    if (sz_phdrs >= (unsigned)sizeof(*phdr))
+        max_phnum = sz_phdrs / (unsigned)sizeof(*phdr);
+    if (max_phnum == 0)
+        return NULL;
+    if (phnum > max_phnum)
+        phnum = max_phnum;
+    for (unsigned j = 0; j < phnum; ++j) {
+        Elf32_Phdr const *cur = phdr + j;
+        if (type == get_te32(&cur->p_type)) {
+            return cur;
         }
     }
-    return 0;
+    return NULL;
 }
 
 Elf64_Phdr const *
 PackLinuxElf64::elf_find_ptype(unsigned type, Elf64_Phdr const *phdr, unsigned phnum)
 {
-    for (unsigned j = 0; j < phnum; ++j, ++phdr) {
-        if (type == get_te32(&phdr->p_type)) {
-            return phdr;
+    if (phdr == NULL || phnum == 0)
+        return NULL;
+    unsigned max_phnum = 0;
+    if (sz_phdrs >= (unsigned)sizeof(*phdr))
+        max_phnum = sz_phdrs / (unsigned)sizeof(*phdr);
+    if (max_phnum == 0)
+        return NULL;
+    if (phnum > max_phnum)
+        phnum = max_phnum;
+    for (unsigned j = 0; j < phnum; ++j) {
+        Elf64_Phdr const *cur = phdr + j;
+        if (type == get_te32(&cur->p_type)) {
+            return cur;
         }
     }
-    return 0;
+    return NULL;
 }
 
 Elf32_Shdr const *PackLinuxElf32::elf_find_section_name(
@@ -3824,6 +3844,28 @@ void PackLinuxElf64::unpack(OutputFile *fo)
     fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);
 
     unsigned const u_phnum = get_te16(&ehdr->e_phnum);
+    /* Temporarily point phdri at the decompressed program headers
+     * in `u` to prevent dereferencing pointers into the original
+     * input image when processing phdr entries. Save and restore
+     * the original phdri. */
+    Elf64_Phdr *saved_phdri = phdri;
+    phdri = (Elf64_Phdr *)(u.buf + sizeof(*ehdr));
+
+    /* Validate decompressed program header count fits into temporary buffer `u` */
+    /* Point phdri to the decompressed program headers in `u` to avoid
+     * dereferencing pointers into the original file image during unpack.
+     */
+    /* Point phdri to the decompressed program headers in  to avoid
+     * dereferencing pointers into the original file image during unpack.
+     * For 64-bit unpack use Elf64_Phdr.
+     * For 32-bit unpack a separate assignment exists in its own function.
+     */
+    unsigned u_max = 0;
+    if (sizeof(u) > sizeof(Elf64_Ehdr))
+        u_max = (sizeof(u) - sizeof(Elf64_Ehdr)) / sizeof(Elf64_Phdr);
+    if (u_phnum == 0 || u_phnum > u_max)
+        throwCantUnpack("ElfXX_Ehdr corrupted");
+
     unsigned total_in = 0;
     unsigned total_out = 0;
     unsigned c_adler = upx_adler32(NULL, 0);
@@ -3831,7 +3873,23 @@ void PackLinuxElf64::unpack(OutputFile *fo)
 
     // Packed ET_EXE has no PT_DYNAMIC.
     // Packed ET_DYN has original PT_DYNAMIC for info needed by rtld.
-    bool const is_shlib = !!elf_find_ptype(Elf64_Phdr::PT_DYNAMIC, phdri, c_phnum);
+    bool is_shlib_local = false;
+    Elf64_Phdr const *local_phdr = (Elf64_Phdr const *)((unsigned char*)ehdr + sizeof(Elf64_Ehdr));
+    if (u_phnum > 0) {
+        unsigned u_max_local = 0;
+        if (sizeof(u) > sizeof(Elf64_Ehdr))
+            u_max_local = (sizeof(u) - sizeof(Elf64_Ehdr)) / sizeof(Elf64_Phdr);
+    if (u_phnum <= u_max_local) {
+        for (unsigned j = 0; j < u_phnum; ++j) {
+            if (Elf64_Phdr::PT_DYNAMIC == get_te32(&local_phdr[j].p_type)) {
+                is_shlib_local = true;
+                break;
+            }
+        }
+        }
+    }
+    bool const is_shlib = is_shlib_local;
+
     if (is_shlib) {
         // Unpack and output the Ehdr and Phdrs for real.
         // This depends on position within input file fi.
@@ -3896,11 +3954,16 @@ void PackLinuxElf64::unpack(OutputFile *fo)
     }
     phdr = phdri;
     load_va = 0;
-    for (unsigned j=0; j < c_phnum; ++j) {
-        if (PT_LOAD64==get_te32(&phdr->p_type)) {
-            load_va = get_te64(&phdr->p_vaddr);
-            break;
+    if (phdri != NULL && c_phnum > 0 && sz_phdrs >= c_phnum * (unsigned)sizeof(*phdri)) {
+        for (unsigned j=0; j < c_phnum; ++j) {
+            if (PT_LOAD64==get_te32(&phdr->p_type)) {
+                load_va = get_te64(&phdr->p_vaddr);
+                break;
+            }
+            ++phdr;
         }
+    } else {
+        // phdri not available or corrupted; leave load_va at 0 to avoid deref
     }
     if (is_shlib
     ||  ((unsigned)(get_te64(&ehdri.e_entry) - load_va) + up4(lsize) +
@@ -4000,6 +4063,9 @@ void PackLinuxElf64::unpack(OutputFile *fo)
     // finally test the checksums
     if (ph.c_adler != c_adler || ph.u_adler != u_adler)
         throwChecksumError();
+
+    /* Restore original phdri */
+    phdri = saved_phdri;
 #undef MAX_ELF_HDR
 }
 
@@ -4445,6 +4511,17 @@ void PackLinuxElf32::unpack(OutputFile *fo)
     fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);
 
     unsigned const u_phnum = get_te16(&ehdr->e_phnum);
+    /* Temporarily point phdri at the decompressed program headers in `u`. */
+    Elf32_Phdr *saved_phdri = phdri;
+    phdri = (Elf32_Phdr *)(u.buf + sizeof(*ehdr));
+
+    /* Validate decompressed program header count fits into temporary buffer `u` */
+    unsigned u_max = 0;
+    if (sizeof(u) > sizeof(Elf32_Ehdr))
+        u_max = (sizeof(u) - sizeof(Elf32_Ehdr)) / sizeof(Elf32_Phdr);
+    if (u_phnum == 0 || u_phnum > u_max)
+        throwCantUnpack("ElfXX_Ehdr corrupted");
+
     unsigned total_in = 0;
     unsigned total_out = 0;
     unsigned c_adler = upx_adler32(NULL, 0);
@@ -4452,7 +4529,20 @@ void PackLinuxElf32::unpack(OutputFile *fo)
 
     // Packed ET_EXE has no PT_DYNAMIC.
     // Packed ET_DYN has original PT_DYNAMIC for info needed by rtld.
-    bool const is_shlib = !!elf_find_ptype(Elf32_Phdr::PT_DYNAMIC, phdri, c_phnum);
+    bool is_shlib_local = false;
+    Elf32_Phdr const *local_phdr = (Elf32_Phdr const *)((unsigned char*)ehdr + sizeof(Elf32_Ehdr));
+    unsigned u_max32 = 0;
+    if (sizeof(u) > sizeof(Elf32_Ehdr))
+        u_max32 = (sizeof(u) - sizeof(Elf32_Ehdr)) / sizeof(Elf32_Phdr);
+    if (u_phnum > 0 && u_phnum <= u_max32) {
+        for (unsigned j = 0; j < u_phnum; ++j) {
+            if (Elf32_Phdr::PT_DYNAMIC == get_te32(&local_phdr[j].p_type)) {
+                is_shlib_local = true;
+                break;
+            }
+        }
+    }
+    bool const is_shlib = is_shlib_local;
     if (is_shlib) {
         // Unpack and output the Ehdr and Phdrs for real.
         // This depends on position within input file fi.
@@ -4517,11 +4607,16 @@ void PackLinuxElf32::unpack(OutputFile *fo)
     }
     phdr = phdri;
     load_va = 0;
-    for (unsigned j=0; j < c_phnum; ++j) {
-        if (PT_LOAD32==get_te32(&phdr->p_type)) {
-            load_va = get_te32(&phdr->p_vaddr);
-            break;
+    if (phdri != NULL && c_phnum > 0 && sz_phdrs >= c_phnum * (unsigned)sizeof(*phdri)) {
+        for (unsigned j=0; j < c_phnum; ++j) {
+            if (PT_LOAD32==get_te32(&phdr->p_type)) {
+                load_va = get_te32(&phdr->p_vaddr);
+                break;
+            }
+            ++phdr;
         }
+    } else {
+        // phdri not available or corrupted; leave load_va at 0 to avoid deref
     }
     if (is_shlib
     ||  ((unsigned)(get_te32(&ehdri.e_entry) - load_va) + up4(lsize) +