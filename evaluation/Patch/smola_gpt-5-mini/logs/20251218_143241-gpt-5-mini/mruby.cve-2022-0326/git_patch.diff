diff --git a/src/variable.c b/src/variable.c
index 53b760d..8652f02 100644
--- a/src/variable.c
+++ b/src/variable.c
@@ -1,3 +1,4 @@
+#include <stdint.h>
 /*
 ** variable.c - mruby variables
 **
@@ -11,6 +12,7 @@
 #include <mruby/string.h>
 #include <mruby/variable.h>
 #include <mruby/presym.h>
+#include <stdint.h>
 
 /* Instance variable table structure */
 typedef struct iv_tbl {
@@ -229,7 +231,13 @@ iv_copy(mrb_state *mrb, iv_tbl *t)
 static void
 iv_free(mrb_state *mrb, iv_tbl *t)
 {
-  mrb_free(mrb, t->ptr);
+  /* Defensive checks: t may be NULL or corrupted. Avoid dereferencing or
+   * freeing invalid pointers (such as low addresses). */
+  if (!t) return;
+  if ((uintptr_t)t < 0x1000) return;
+  if (t->ptr && (uintptr_t)t->ptr >= 0x1000) {
+    mrb_free(mrb, t->ptr);
+  }
   mrb_free(mrb, t);
 }
 
@@ -249,34 +257,44 @@ mark_tbl(mrb_state *mrb, iv_tbl *t)
 void
 mrb_gc_mark_gv(mrb_state *mrb)
 {
+  /* Be defensive: globals may be NULL or corrupted. */
+  if (!mrb->globals) return;
+  if ((uintptr_t)mrb->globals < 0x1000) return;
   mark_tbl(mrb, mrb->globals);
 }
 
 void
 mrb_gc_free_gv(mrb_state *mrb)
 {
-  if (mrb->globals)
-    iv_free(mrb, mrb->globals);
+  if (!mrb->globals) return;
+  if ((uintptr_t)mrb->globals < 0x1000) { mrb->globals = NULL; return; }
+  iv_free(mrb, mrb->globals);
+  mrb->globals = NULL;
 }
 
 void
 mrb_gc_mark_iv(mrb_state *mrb, struct RObject *obj)
 {
+  if (!obj || !obj->iv) return;
+  if ((uintptr_t)obj->iv < 0x1000) return;
   mark_tbl(mrb, obj->iv);
 }
 
 size_t
 mrb_gc_mark_iv_size(mrb_state *mrb, struct RObject *obj)
 {
+  if (!obj || !obj->iv) return 0;
+  if ((uintptr_t)obj->iv < 0x1000) return 0;
   return iv_size(mrb, obj->iv);
 }
 
 void
 mrb_gc_free_iv(mrb_state *mrb, struct RObject *obj)
 {
-  if (obj->iv) {
-    iv_free(mrb, obj->iv);
-  }
+  if (!obj || !obj->iv) return;
+  if ((uintptr_t)obj->iv < 0x1000) { obj->iv = NULL; return; }
+  iv_free(mrb, obj->iv);
+  obj->iv = NULL;
 }
 
 mrb_value