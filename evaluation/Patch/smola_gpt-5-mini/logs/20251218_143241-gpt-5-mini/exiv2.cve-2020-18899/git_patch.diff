diff --git a/src/jp2image.cpp b/src/jp2image.cpp
index 07afef0..68e3d86 100644
--- a/src/jp2image.cpp
+++ b/src/jp2image.cpp
@@ -507,8 +507,13 @@ namespace Exiv2
                             if (subBox.length > io_->size() - io_->tell()) {
                                 throw Error(kerCorruptedMetadata);
                             }
-                            DataBuf data(subBox.length-sizeof(box));
-                            io_->read(data.pData_,data.size_);
+                            // Ensure the sub-box length is at least the header size to avoid unsigned underflow
+                            if (subBox.length < sizeof(subBox)) {
+                                throw Error(kerCorruptedMetadata);
+                            }
+                            long dataLen = static_cast<long>(subBox.length) - static_cast<long>(sizeof(subBox));
+                            DataBuf data(dataLen);
+                            io_->read(data.pData_, data.size_);
                             if ( bPrint ) {
                                 out << Internal::stringFormat("%8ld | %8ld |  sub:",(size_t)address,(size_t)subBox.length)
                                     << toAscii(subBox.type)
diff --git a/src/types.cpp b/src/types.cpp
index 17ab051..82f7fc2 100644
--- a/src/types.cpp
+++ b/src/types.cpp
@@ -138,8 +138,17 @@ namespace Exiv2 {
     DataBuf::DataBuf() : pData_(0), size_(0)
     {}
 
-    DataBuf::DataBuf(long size) : pData_(new byte[size]()), size_(size)
-    {}
+    DataBuf::DataBuf(long size) : pData_(0), size_(0)
+{
+    // Guard against non-positive or excessively large allocations.
+    // A negative or zero size indicates no allocation.
+    if (size > 0) {
+        // Perform the allocation. If this throws std::bad_alloc it will
+        // be propagated to the caller.
+        pData_ = new byte[size]();
+        size_ = size;
+    }
+}
 
     DataBuf::DataBuf(const byte* pData, long size)
         : pData_(0), size_(0)