diff --git a/src/scenegraph/vrml_proto.c b/src/scenegraph/vrml_proto.c
index df30ed0..22a32cf 100644
--- a/src/scenegraph/vrml_proto.c
+++ b/src/scenegraph/vrml_proto.c
@@ -1273,12 +1273,18 @@ u32 gf_sg_proto_get_root_tag(GF_Proto *proto)
 }
 
 GF_EXPORT
-Bool gf_sg_proto_field_is_sftime_offset(GF_Node *node, GF_FieldInfo *field)
+Bool gf_sg_proto_field_is_sftime_offset(GF_Node *node, GF_FieldInfo *field);
+
+/* internal recursive helper with depth limit to avoid infinite recursion on cyclic PROTO IS graphs */
+static Bool gf_sg_proto_field_is_sftime_offset_r(GF_Node *node, GF_FieldInfo *field, int depth)
 {
 	u32 i;
 	GF_Route *r;
 	GF_ProtoInstance *inst;
 	GF_FieldInfo inf;
+	/* safety checks */
+	if (!node || !field) return 0;
+	if (depth > 128) return 0; /* prevent stack overflow in pathological cyclic IS graphs */
 	if (node->sgprivate->tag != TAG_ProtoNode) return 0;
 	if (field->fieldType != GF_SG_VRML_SFTIME) return 0;
 
@@ -1292,13 +1298,24 @@ Bool gf_sg_proto_field_is_sftime_offset(GF_Node *node, GF_FieldInfo *field)
 
 		gf_node_get_field(r->ToNode, r->ToField.fieldIndex, &inf);
 		/*IS to another proto*/
-		if (r->ToNode->sgprivate->tag == TAG_ProtoNode) return gf_sg_proto_field_is_sftime_offset(r->ToNode, &inf);
+		if (r->ToNode->sgprivate->tag == TAG_ProtoNode) {
+			/* prevent recursion on cycles by limiting depth */
+			if (r->ToNode == node) return 0; /* direct self-loop -> treat as not offset */
+			if (gf_sg_proto_field_is_sftime_offset_r(r->ToNode, &inf, depth+1)) return 1;
+		}
 		/*IS to a startTime/stopTime field*/
 		if (!stricmp(inf.name, "startTime") || !stricmp(inf.name, "stopTime")) return 1;
 	}
 	return 0;
 }
 
+GF_EXPORT
+Bool gf_sg_proto_field_is_sftime_offset(GF_Node *node, GF_FieldInfo *field)
+{
+	return gf_sg_proto_field_is_sftime_offset_r(node, field, 0);
+}
+
+
 GF_EXPORT
 GF_Err gf_node_proto_set_grouping(GF_Node *node)
 {