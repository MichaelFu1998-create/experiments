diff --git a/src/dynapi.c b/src/dynapi.c
index 082d178..62b0164 100644
--- a/src/dynapi.c
+++ b/src/dynapi.c
@@ -7760,6 +7760,13 @@ dwg_dynapi_entity_value (void *restrict _obj, const char *restrict name,
   if (!_obj || !name || !fieldname || !out)
     return false;
 #endif
+  /* Reject NULL object pointers to avoid dereferencing or reading from
+     invalid memory locations. */
+  if (!_obj)
+    {
+      fprintf (stderr, "%s: NULL object pointer\n", __FUNCTION__);
+      return false;
+    }
   {
     int error;
     const Dwg_Object* obj = dwg_obj_generic_to_object (_obj, &error);
@@ -7784,7 +7791,27 @@ dwg_dynapi_entity_value (void *restrict _obj, const char *restrict name,
         }
       if (fp)
         memcpy (fp, f, sizeof (Dwg_DYNAPI_field));
-      memcpy (out, &((char *)_obj)[f->offset], f->size);
+      {
+      /* Compute source pointer and validate addresses to avoid reading
+         from NULL or low memory (heap-buffer or null-deref). */
+      char *src = (char *)_obj + f->offset;
+      size_t fsize = (size_t) f->size;
+      uintptr_t srcaddr = (uintptr_t) src;
+      /* Basic sanity limits: reject absurd sizes or offsets and pointers
+         into the NULL page. These limits are conservative and only used
+         to avoid reading invalid memory from corrupted inputs. */
+      if (fsize == 0 || fsize > 0x100000
+          || srcaddr < 0x1000
+          || srcaddr + fsize < srcaddr
+          || srcaddr + fsize > (uintptr_t) -1 - 0x1000)
+        {
+          fprintf (stderr, "%s: suspicious field access %s.%s (offset=%lu size=%lu)\n",
+                     __FUNCTION__, name, fieldname, (unsigned long)f->offset,
+                     (unsigned long)f->size);
+          return false;
+        }
+      memcpy (out, src, fsize);
+    }
       return true;
     }
   }