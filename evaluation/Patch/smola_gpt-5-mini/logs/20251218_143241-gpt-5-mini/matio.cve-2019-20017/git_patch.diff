diff --git a/src/inflate.c b/src/inflate.c
index 5fd205a..175970b 100644
--- a/src/inflate.c
+++ b/src/inflate.c
@@ -349,7 +349,7 @@ InflateRankDims(mat_t *mat, matvar_t *matvar, void *buf, size_t nbytes, mat_uint
 {
     mat_uint8_t comp_buf[32];
     mat_int32_t tag[2];
-    int    err, rank, i;
+    int    err;
     size_t bytesread = 0, readresult = 1;
 
     if ( buf == NULL )
@@ -388,12 +388,18 @@ InflateRankDims(mat_t *mat, matvar_t *matvar, void *buf, size_t nbytes, mat_uint
         Mat_Critical("InflateRankDims: Reading dimensions expected type MAT_T_INT32");
         return bytesread;
     }
-    rank = tag[1];
-    if ( rank % 8 != 0 )
-        i = 8-(rank %8);
-    else
-        i = 0;
-    rank+=i;
+
+    /* tag[1] contains the number of bytes for the dimensions */
+    if ( tag[1] < 0 ) {
+        Mat_Critical("InflateRankDims: Invalid dimensions size");
+        return bytesread;
+    }
+    /* number of bytes for the dimensions */
+    int dims_nbytes = tag[1];
+    /* pad to 8-byte boundary as stored in MAT file */
+    int padded_nbytes = dims_nbytes;
+    if ( padded_nbytes % 8 != 0 )
+        padded_nbytes += 8 - (padded_nbytes % 8);
 
     if ( !matvar->internal->z->avail_in ) {
         matvar->internal->z->avail_in = 1;
@@ -401,16 +407,21 @@ InflateRankDims(mat_t *mat, matvar_t *matvar, void *buf, size_t nbytes, mat_uint
         bytesread += fread(comp_buf,1,1,(FILE*)mat->fp);
     }
 
-    matvar->internal->z->avail_out = rank;
-    if ( sizeof(mat_uint32_t)*(rank + 2) <= nbytes ) {
-        matvar->internal->z->next_out = (Bytef*)((mat_int32_t *)buf+2);
+    matvar->internal->z->avail_out = padded_nbytes;
+    /* Check if the provided buf (nbytes) can hold the dims (accounting for the initial 8 bytes)
+     * buf size is nbytes bytes; first 8 bytes are already in buf, so remaining is nbytes-8
+     */
+    if ( (size_t)padded_nbytes <= (nbytes > 8 ? nbytes - 8 : 0) ) {
+        matvar->internal->z->next_out = (Bytef*)((mat_uint32_t *)buf+2);
     } else {
-        /* Cannot use too small buf, but can allocate output buffer dims */
-        *dims = (mat_uint32_t*)calloc(rank, sizeof(mat_uint32_t));
+        /* Allocate buffer for padded number of uint32 elements */
+        size_t nelems = (size_t)padded_nbytes / sizeof(mat_uint32_t);
+        *dims = (mat_uint32_t*)calloc(nelems, sizeof(mat_uint32_t));
         if ( NULL != *dims ) {
             matvar->internal->z->next_out = (Bytef*)*dims;
         } else {
-            *((mat_int32_t *)buf+1) = 0;
+            /* Indicate error by zeroing rank (stored in buf+1) */
+            ((mat_int32_t *)buf)[1] = 0;
             Mat_Critical("Error allocating memory for dims");
             return bytesread;
         }
diff --git a/src/mat5.c b/src/mat5.c
index abdb351..4699220 100644
--- a/src/mat5.c
+++ b/src/mat5.c
@@ -908,7 +908,12 @@ ReadNextCell( mat_t *mat, matvar_t *matvar )
 
     if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {
 #if defined(HAVE_ZLIB)
-        mat_uint32_t uncomp_buf[16] = {0,};
+        mat_uint32_t *uncomp_buf = (mat_uint32_t*)calloc(1024, sizeof(mat_uint32_t));
+            size_t uncomp_buf_elems = 512;
+            if ( NULL == uncomp_buf ) {
+                Mat_Critical("Couldn't allocate memory for uncomp_buf");
+                return bytesread;
+            }
         int nbytes;
         mat_uint32_t array_flags;
 
@@ -923,6 +928,20 @@ ReadNextCell( mat_t *mat, matvar_t *matvar )
             uncomp_buf[0] = 0;
             uncomp_buf[1] = 0;
             bytesread += InflateVarTag(mat,matvar,uncomp_buf);
+            if ( (int)uncomp_buf[1] > 0 ) {
+                int ub_nbytes = (int)uncomp_buf[1];
+                int padded = ub_nbytes;
+                if ( padded % 8 != 0 ) padded += 8 - (padded % 8);
+                size_t needed = 2 + (size_t)(padded/sizeof(mat_uint32_t)) + 8; /* extra margin */
+                if ( needed > uncomp_buf_elems ) {
+                    mat_uint32_t *tmp = (mat_uint32_t*)realloc(uncomp_buf, needed*sizeof(mat_uint32_t));
+                    if ( tmp != NULL ) {
+                        uncomp_buf = tmp;
+                        uncomp_buf_elems = needed;
+                    }
+                }
+            }
+
             if ( mat->byteswap ) {
                 (void)Mat_uint32Swap(uncomp_buf);
                 (void)Mat_uint32Swap(uncomp_buf+1);
@@ -967,7 +986,7 @@ ReadNextCell( mat_t *mat, matvar_t *matvar )
             if ( cells[i]->class_type != MAT_C_OPAQUE ) {
                 mat_uint32_t* dims = NULL;
                 int do_clean = 0;
-                bytesread += InflateRankDims(mat,matvar,uncomp_buf,sizeof(uncomp_buf),&dims);
+                bytesread += InflateRankDims(mat,matvar,uncomp_buf,0,&dims);
                 if ( NULL == dims )
                     dims = uncomp_buf + 2;
                 else
@@ -980,10 +999,36 @@ ReadNextCell( mat_t *mat, matvar_t *matvar )
                 /* Rank and Dimension */
                 if ( uncomp_buf[0] == MAT_T_INT32 ) {
                     int j;
-                    cells[i]->rank = uncomp_buf[1];
-                    nbytes -= cells[i]->rank;
-                    cells[i]->rank /= 4;
-                    cells[i]->dims = (size_t*)malloc(cells[i]->rank*sizeof(*cells[i]->dims));
+                    mat_uint32_t dim_bytes = uncomp_buf[1];
+                    if ( dim_bytes % 4 != 0 ) {
+                        Mat_Critical("Invalid dimension bytes");
+                    }
+                    size_t cells_rank = (size_t)(dim_bytes / 4);
+                    size_t alloc_size = 0;
+                    if ( SafeMul(&alloc_size, cells_rank, sizeof(*cells[i]->dims)) ) {
+                        Mat_Critical("Integer multiplication overflow for dims");
+                        cells[i]->rank = 0;
+                    } else {
+                        cells[i]->rank = cells_rank;
+                        nbytes -= (int)dim_bytes;
+                        cells[i]->dims = (size_t*)malloc(alloc_size);
+                        if ( cells[i]->dims != NULL ) {
+                            if ( mat->byteswap ) {
+                                int j;
+                                for ( j = 0; j < cells[i]->rank; j++ )
+                                    cells[i]->dims[j] = Mat_uint32Swap(dims + j);
+                            } else {
+                                int j;
+                                for ( j = 0; j < cells[i]->rank; j++ )
+                                    cells[i]->dims[j] = dims[j];
+                            }
+                            if ( cells[i]->rank % 2 != 0 )
+                                nbytes -= 4;
+                        } else {
+                            Mat_Critical("Error allocating memory for dims");
+                            cells[i]->rank = 0;
+                        }
+                    }
                     if ( mat->byteswap ) {
                         for ( j = 0; j < cells[i]->rank; j++ )
                             cells[i]->dims[j] = Mat_uint32Swap(dims + j);
@@ -1071,6 +1116,8 @@ ReadNextCell( mat_t *mat, matvar_t *matvar )
         }
 #else
         Mat_Critical("Not compiled with zlib support");
+            free(uncomp_buf);
+
 #endif
 
     } else {
@@ -1199,12 +1246,31 @@ ReadNextStructField( mat_t *mat, matvar_t *matvar )
     }
     if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {
 #if defined(HAVE_ZLIB)
-        mat_uint32_t uncomp_buf[16] = {0,};
+        mat_uint32_t *uncomp_buf = (mat_uint32_t*)calloc(1024, sizeof(mat_uint32_t));
+            size_t uncomp_buf_elems = 512;
+            if ( NULL == uncomp_buf ) {
+                Mat_Critical("Couldn't allocate memory for uncomp_buf");
+                return bytesread;
+            }
         int nbytes;
         mat_uint32_t array_flags, len;
 
         /* Field name length */
         bytesread += InflateVarTag(mat,matvar,uncomp_buf);
+            if ( (int)uncomp_buf[1] > 0 ) {
+                int ub_nbytes = (int)uncomp_buf[1];
+                int padded = ub_nbytes;
+                if ( padded % 8 != 0 ) padded += 8 - (padded % 8);
+                size_t needed = 2 + (size_t)(padded/sizeof(mat_uint32_t)) + 8; /* extra margin */
+                if ( needed > uncomp_buf_elems ) {
+                    mat_uint32_t *tmp = (mat_uint32_t*)realloc(uncomp_buf, needed*sizeof(mat_uint32_t));
+                    if ( tmp != NULL ) {
+                        uncomp_buf = tmp;
+                        uncomp_buf_elems = needed;
+                    }
+                }
+            }
+
         if ( mat->byteswap ) {
             (void)Mat_uint32Swap(uncomp_buf);
             (void)Mat_uint32Swap(uncomp_buf+1);
@@ -1343,7 +1409,7 @@ ReadNextStructField( mat_t *mat, matvar_t *matvar )
             if ( fields[i]->class_type != MAT_C_OPAQUE ) {
                 mat_uint32_t* dims = NULL;
                 int do_clean = 0;
-                bytesread += InflateRankDims(mat,matvar,uncomp_buf,sizeof(uncomp_buf),&dims);
+                bytesread += InflateRankDims(mat,matvar,uncomp_buf,0,&dims);
                 if ( NULL == dims )
                     dims = uncomp_buf + 2;
                 else
@@ -1417,6 +1483,8 @@ ReadNextStructField( mat_t *mat, matvar_t *matvar )
         }
 #else
         Mat_Critical("Not compiled with zlib support");
+            free(uncomp_buf);
+
 #endif
     } else {
         mat_uint32_t buf[6];
@@ -4777,7 +4845,8 @@ Mat_VarReadNextInfo5( mat_t *mat )
         case MAT_T_COMPRESSED:
         {
 #if defined(HAVE_ZLIB)
-            mat_uint32_t uncomp_buf[16] = {0,};
+            mat_uint32_t *uncomp_buf = (mat_uint32_t*)calloc(1024, sizeof(mat_uint32_t));
+            size_t uncomp_buf_elems = 512;
             int      nbytes;
             long     bytesread = 0;
 
@@ -4799,6 +4868,20 @@ Mat_VarReadNextInfo5( mat_t *mat )
 
             /* Read variable tag */
             bytesread += InflateVarTag(mat,matvar,uncomp_buf);
+            if ( (int)uncomp_buf[1] > 0 ) {
+                int ub_nbytes = (int)uncomp_buf[1];
+                int padded = ub_nbytes;
+                if ( padded % 8 != 0 ) padded += 8 - (padded % 8);
+                size_t needed = 2 + (size_t)(padded/sizeof(mat_uint32_t)) + 8; /* extra margin */
+                if ( needed > uncomp_buf_elems ) {
+                    mat_uint32_t *tmp = (mat_uint32_t*)realloc(uncomp_buf, needed*sizeof(mat_uint32_t));
+                    if ( tmp != NULL ) {
+                        uncomp_buf = tmp;
+                        uncomp_buf_elems = needed;
+                    }
+                }
+            }
+
             if ( mat->byteswap ) {
                 (void)Mat_uint32Swap(uncomp_buf);
                 (void)Mat_uint32Swap(uncomp_buf+1);
@@ -4833,7 +4916,7 @@ Mat_VarReadNextInfo5( mat_t *mat )
             if ( matvar->class_type != MAT_C_OPAQUE ) {
                 mat_uint32_t* dims = NULL;
                 int do_clean = 0;
-                bytesread += InflateRankDims(mat,matvar,uncomp_buf,sizeof(uncomp_buf),&dims);
+                bytesread += InflateRankDims(mat,matvar,uncomp_buf,0,&dims);
                 if ( NULL == dims )
                     dims = uncomp_buf + 2;
                 else
@@ -4846,8 +4929,39 @@ Mat_VarReadNextInfo5( mat_t *mat )
                 if ( uncomp_buf[0] == MAT_T_INT32 ) {
                     int j;
                     nbytes = uncomp_buf[1];
-                    matvar->rank = nbytes / 4;
-                    matvar->dims = (size_t*)malloc(matvar->rank*sizeof(*matvar->dims));
+                    mat_uint32_t dim_bytes = nbytes; /* nbytes already set to uncomp_buf[1] earlier */
+                    if ( dim_bytes % 4 != 0 ) {
+                        Mat_Critical("Invalid dimension bytes");
+                    }
+                    size_t mv_rank = (size_t)(dim_bytes / 4);
+                    size_t alloc_size = 0;
+                    if ( SafeMul(&alloc_size, mv_rank, sizeof(*matvar->dims)) ) {
+                        Mat_Critical("Integer multiplication overflow for dims");
+                        Mat_VarFree(matvar);
+                        matvar = NULL;
+                        (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);
+                        break;
+                    } else {
+                        matvar->rank = mv_rank;
+                        matvar->dims = (size_t*)malloc(alloc_size);
+                        if ( matvar->dims != NULL ) {
+                            if ( mat->byteswap ) {
+                                int j;
+                                for ( j = 0; j < matvar->rank; j++ )
+                                    matvar->dims[j] = Mat_uint32Swap(dims + j);
+                            } else {
+                                int j;
+                                for ( j = 0; j < matvar->rank; j++ )
+                                    matvar->dims[j] = dims[j];
+                            }
+                        } else {
+                            Mat_Critical("Error allocating memory for dims");
+                            Mat_VarFree(matvar);
+                            matvar = NULL;
+                            (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);
+                            break;
+                        }
+                    }
                     if ( mat->byteswap ) {
                         for ( j = 0; j < matvar->rank; j++ )
                             matvar->dims[j] = Mat_uint32Swap(dims + j);
@@ -4902,6 +5016,7 @@ Mat_VarReadNextInfo5( mat_t *mat )
                 }
             }
             (void)fseek((FILE*)mat->fp,nBytes+8+fpos,SEEK_SET);
+            free(uncomp_buf);
             break;
 #else
             Mat_Critical("Compressed variable found in \"%s\", but matio was "