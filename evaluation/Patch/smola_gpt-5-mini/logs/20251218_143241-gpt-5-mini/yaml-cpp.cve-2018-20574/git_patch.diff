diff --git a/src/singledocparser.cpp b/src/singledocparser.cpp
index a27c1c3..1f4c0b7 100644
--- a/src/singledocparser.cpp
+++ b/src/singledocparser.cpp
@@ -18,7 +18,8 @@ SingleDocParser::SingleDocParser(Scanner& scanner, const Directives& directives)
     : m_scanner(scanner),
       m_directives(directives),
       m_pCollectionStack(new CollectionStack),
-      m_curAnchor(0) {}
+      m_curAnchor(0),
+      m_recursionDepth(0) {}
 
 SingleDocParser::~SingleDocParser() {}
 
@@ -46,6 +47,11 @@ void SingleDocParser::HandleDocument(EventHandler& eventHandler) {
 }
 
 void SingleDocParser::HandleNode(EventHandler& eventHandler) {
+  struct RecursionGuard {
+    SingleDocParser* p;
+    RecursionGuard(SingleDocParser* p_) : p(p_) { if (++p->m_recursionDepth > 1024) throw ParserException(p->m_scanner.peek().mark, ErrorMsg::END_OF_MAP_FLOW); }
+    ~RecursionGuard() { --p->m_recursionDepth; }
+  } recursionGuard(this);
   // an empty node *is* a possibility
   if (m_scanner.empty()) {
     eventHandler.OnNull(m_scanner.mark(), NullAnchor);
@@ -273,6 +279,11 @@ void SingleDocParser::HandleBlockMap(EventHandler& eventHandler) {
 }
 
 void SingleDocParser::HandleFlowMap(EventHandler& eventHandler) {
+  struct FlowRecursionGuard {
+    SingleDocParser* p;
+    FlowRecursionGuard(SingleDocParser* p_) : p(p_) { if (++p->m_recursionDepth > 1024) throw ParserException(p->m_scanner.peek().mark, ErrorMsg::END_OF_MAP_FLOW); }
+    ~FlowRecursionGuard() { --p->m_recursionDepth; }
+  } flowGuard(this);
   // eat start token
   m_scanner.pop();
   m_pCollectionStack->PushCollectionType(CollectionType::FlowMap);
@@ -292,7 +303,19 @@ void SingleDocParser::HandleFlowMap(EventHandler& eventHandler) {
     // grab key (if non-null)
     if (token.type == Token::KEY) {
       m_scanner.pop();
-      HandleNode(eventHandler);
+      // If after popping KEY there is another KEY (or entry/end) then the key is null
+      // and we should not recurse into HandleNode which may not consume tokens,
+      // causing unbounded recursion. Treat as null in that case.
+      if (!m_scanner.empty()) {
+        Token::TYPE nt = m_scanner.peek().type;
+        if (nt != Token::KEY && nt != Token::FLOW_MAP_END && nt != Token::FLOW_ENTRY) {
+          HandleNode(eventHandler);
+        } else {
+          eventHandler.OnNull(mark, NullAnchor);
+        }
+      } else {
+        eventHandler.OnNull(mark, NullAnchor);
+      }
     } else {
       eventHandler.OnNull(mark, NullAnchor);
     }
@@ -300,7 +323,18 @@ void SingleDocParser::HandleFlowMap(EventHandler& eventHandler) {
     // now grab value (optional)
     if (!m_scanner.empty() && m_scanner.peek().type == Token::VALUE) {
       m_scanner.pop();
-      HandleNode(eventHandler);
+      // Similar guard for value: if next token would be a KEY or map end without a real node,
+      // treat the value as null to avoid potential recursive non-consumption.
+      if (!m_scanner.empty()) {
+        Token::TYPE vt = m_scanner.peek().type;
+        if (vt != Token::KEY && vt != Token::FLOW_MAP_END && vt != Token::FLOW_ENTRY) {
+          HandleNode(eventHandler);
+        } else {
+          eventHandler.OnNull(mark, NullAnchor);
+        }
+      } else {
+        eventHandler.OnNull(mark, NullAnchor);
+      }
     } else {
       eventHandler.OnNull(mark, NullAnchor);
     }
diff --git a/src/singledocparser.h b/src/singledocparser.h
index 2b92067..dd2e9d0 100644
--- a/src/singledocparser.h
+++ b/src/singledocparser.h
@@ -59,6 +59,7 @@ class SingleDocParser : private noncopyable {
   Anchors m_anchors;
 
   anchor_t m_curAnchor;
+  std::size_t m_recursionDepth;
 };
 }