diff --git a/src/media_tools/avilib.c b/src/media_tools/avilib.c
index 7cdca7d..ce26da9 100644
--- a/src/media_tools/avilib.c
+++ b/src/media_tools/avilib.c
@@ -2074,25 +2074,24 @@ int avi_parse_input_file(avi_t *AVI, int getIndex)
 					i += 8;
 					if(lasttag == 1)
 					{
-						alBITMAPINFOHEADER bih;
-
-						memcpy(&bih, hdrl_data + i, sizeof(alBITMAPINFOHEADER));
-						AVI->bitmap_info_header = (alBITMAPINFOHEADER *)
-						                          gf_malloc(str2ulong((unsigned char *)&bih.bi_size));
-						if (AVI->bitmap_info_header != NULL)
-							memcpy(AVI->bitmap_info_header, hdrl_data + i,
-							       str2ulong((unsigned char *)&bih.bi_size));
-
-						AVI->width  = str2ulong(hdrl_data+i+4);
-						AVI->height = str2ulong(hdrl_data+i+8);
-						vids_strf_seen = 1;
-						//ThOe
-						AVI->v_codecf_off = header_offset + i+16;
-
-						memcpy(AVI->compressor2, hdrl_data+i+16, 4);
-						AVI->compressor2[4] = 0;
 
-						if (n>40) {
+				alBITMAPINFOHEADER bih;
+
+				/* Ensure there's enough data for a BITMAPINFOHEADER */
+				if ((hdrl_len - i) < (int)sizeof(alBITMAPINFOHEADER)) ERR_EXIT(AVI_ERR_READ)
+				memcpy(&bih, hdrl_data + i, sizeof(alBITMAPINFOHEADER));
+				/* Read bi_size from the header and cap it to available data to avoid OOB reads */
+				u32 bih_size = str2ulong((unsigned char *)&bih.bi_size);
+				int avail = hdrl_len - i;
+				if (bih_size > (u32)avail) {
+					/* malformed header: limit to available to avoid overflow */
+					bih_size = (u32)avail;
+				}
+				AVI->bitmap_info_header = (alBITMAPINFOHEADER *)
+					gf_malloc(bih_size);
+				if (AVI->bitmap_info_header != NULL)
+					memcpy(AVI->bitmap_info_header, hdrl_data + i, bih_size);
+if (n>40) {
 							if (n>0xFFFFFFFF) ERR_EXIT(AVI_ERR_READ)
 							AVI->extradata_size = (u32) (n - 40);
 							AVI->extradata = gf_malloc(sizeof(u8)* AVI->extradata_size);