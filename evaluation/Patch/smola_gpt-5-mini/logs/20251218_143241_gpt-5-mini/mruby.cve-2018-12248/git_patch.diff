diff --git a/mrbgems/mruby-fiber/src/fiber.c b/mrbgems/mruby-fiber/src/fiber.c
index 83153a9..5283101 100644
--- a/mrbgems/mruby-fiber/src/fiber.c
+++ b/mrbgems/mruby-fiber/src/fiber.c
@@ -5,7 +5,7 @@
 
 #define fiber_ptr(o) ((struct RFiber*)mrb_ptr(o))
 
-#define FIBER_STACK_INIT_SIZE 64
+#define FIBER_STACK_INIT_SIZE 4096
 #define FIBER_CI_INIT_SIZE 8
 #define CI_ACC_RESUMED -3
 
@@ -218,6 +218,21 @@ fiber_switch(mrb_state *mrb, mrb_value self, mrb_int len, const mrb_value *a, mr
   fiber_switch_context(mrb, c);
 
   if (vmexec) {
+    /* Ensure VM stack has enough space for executing the fiber.
+       Some procs may expect more register space than the number of
+       arguments passed to the fiber (OP_ENTER may access up to
+       len+2 slots). Grow the current fiber stack to accommodate the
+       larger of the irep->nregs, irep->nlocals and (len+2). */
+    if (c->ci && c->ci[-1].proc && c->ci[-1].proc->body.irep) {
+      mrb_irep *__fib_irep = c->ci[-1].proc->body.irep;
+      int need = (int)__fib_irep->nregs;
+      if ((int)__fib_irep->nlocals > need) need = (int)__fib_irep->nlocals;
+      /* ensure space for arguments and block slot */
+      if (len + 2 > need) need = (int)(len + 2);
+      if (need > 0) {
+        mrb_stack_extend(mrb, need);
+      }
+    }
     c->vmexec = TRUE;
     value = mrb_vm_exec(mrb, c->ci[-1].proc, c->ci->pc);
     mrb->c = old_c;