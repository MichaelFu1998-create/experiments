diff --git a/src/mat5.c b/src/mat5.c
index 2841b58..10237f2 100644
--- a/src/mat5.c
+++ b/src/mat5.c
@@ -5585,127 +5585,19 @@ Mat_VarReadNextInfo5( mat_t *mat )
         Mat_int32Swap(&nBytes);
     }
     switch ( data_type ) {
+
         case MAT_T_COMPRESSED:
         {
-#if defined(HAVE_ZLIB)
-            mat_uint32_t uncomp_buf[16] = {0,};
-            int      nbytes;
-            long     bytesread = 0;
-
-            matvar               = Mat_VarCalloc();
-            matvar->compression  = MAT_COMPRESSION_ZLIB;
-
-            matvar->internal->z = (z_streamp)calloc(1,sizeof(z_stream));
-            err = inflateInit(matvar->internal->z);
-            if ( err != Z_OK ) {
-                Mat_VarFree(matvar);
-                matvar = NULL;
-                Mat_Critical("inflateInit returned %s",zError(err));
-                break;
-            }
-
-            /* Read variable tag */
-            bytesread += InflateVarTag(mat,matvar,uncomp_buf);
-            if ( mat->byteswap ) {
-                (void)Mat_uint32Swap(uncomp_buf);
-                (void)Mat_uint32Swap(uncomp_buf+1);
-            }
-            nbytes = uncomp_buf[1];
-            if ( uncomp_buf[0] != MAT_T_MATRIX ) {
-                (void)fseek((FILE*)mat->fp,nBytes-bytesread,SEEK_CUR);
-                Mat_VarFree(matvar);
-                matvar = NULL;
-                Mat_Critical("Uncompressed type not MAT_T_MATRIX");
-                break;
-            }
-            /* Inflate array flags */
-            bytesread += InflateArrayFlags(mat,matvar,uncomp_buf);
-            if ( mat->byteswap ) {
-                (void)Mat_uint32Swap(uncomp_buf);
-                (void)Mat_uint32Swap(uncomp_buf+2);
-                (void)Mat_uint32Swap(uncomp_buf+3);
-            }
-            /* Array flags */
-            if ( uncomp_buf[0] == MAT_T_UINT32 ) {
-                array_flags = uncomp_buf[2];
-                matvar->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);
-                matvar->isComplex  = (array_flags & MAT_F_COMPLEX);
-                matvar->isGlobal   = (array_flags & MAT_F_GLOBAL);
-                matvar->isLogical  = (array_flags & MAT_F_LOGICAL);
-                if ( matvar->class_type == MAT_C_SPARSE ) {
-                    /* Need to find a more appropriate place to store nzmax */
-                    matvar->nbytes = uncomp_buf[3];
-                }
-            }
-            if ( matvar->class_type != MAT_C_OPAQUE ) {
-                /* Inflate dimensions */
-                bytesread += InflateDimensions(mat,matvar,uncomp_buf);
-                if ( mat->byteswap ) {
-                    (void)Mat_uint32Swap(uncomp_buf);
-                    (void)Mat_uint32Swap(uncomp_buf+1);
-                }
-                /* Rank and dimension */
-                if ( uncomp_buf[0] == MAT_T_INT32 ) {
-                    int i;
-                    nbytes = uncomp_buf[1];
-                    matvar->rank = nbytes / 4;
-                    matvar->dims = (size_t*)malloc(matvar->rank*sizeof(*matvar->dims));
-                    if ( mat->byteswap ) {
-                        for ( i = 0; i < matvar->rank; i++ )
-                            matvar->dims[i] = Mat_uint32Swap(&(uncomp_buf[2+i]));
-                    } else {
-                        for ( i = 0; i < matvar->rank; i++ )
-                            matvar->dims[i] = uncomp_buf[2+i];
-                    }
-                }
-                /* Inflate variable name tag */
-                bytesread += InflateVarNameTag(mat,matvar,uncomp_buf);
-                if ( mat->byteswap )
-                    (void)Mat_uint32Swap(uncomp_buf);
-                /* Name of variable */
-                if ( uncomp_buf[0] == MAT_T_INT8 ) {    /* Name not in tag */
-                    int len, i;
-                    if ( mat->byteswap )
-                        len = Mat_uint32Swap(uncomp_buf+1);
-                    else
-                        len = uncomp_buf[1];
-
-                    if ( len % 8 == 0 )
-                        i = len;
-                    else
-                        i = len+(8-(len % 8));
-                    matvar->name = (char*)malloc(i+1);
-                    /* Inflate variable name */
-                    bytesread += InflateVarName(mat,matvar,matvar->name,i);
-                    matvar->name[len] = '\0';
-                } else if ( ((uncomp_buf[0] & 0x0000ffff) == MAT_T_INT8) &&
-                            ((uncomp_buf[0] & 0xffff0000) != 0x00) ) {
-                    /* Name packed in tag */
-                    int len;
-                    len = (uncomp_buf[0] & 0xffff0000) >> 16;
-                    matvar->name = (char*)malloc(len+1);
-                    memcpy(matvar->name,uncomp_buf+1,len);
-                    matvar->name[len] = '\0';
-                }
-                if ( matvar->class_type == MAT_C_STRUCT )
-                    (void)ReadNextStructField(mat,matvar);
-                else if ( matvar->class_type == MAT_C_CELL )
-                    (void)ReadNextCell(mat,matvar);
-                (void)fseek((FILE*)mat->fp,-(int)matvar->internal->z->avail_in,SEEK_CUR);
-                matvar->internal->datapos = ftell((FILE*)mat->fp);
-                if ( matvar->internal->datapos == -1L ) {
-                    Mat_Critical("Couldn't determine file position");
-                }
-            }
-            (void)fseek((FILE*)mat->fp,nBytes+8+fpos,SEEK_SET);
-            break;
-#else
-            Mat_Critical("Compressed variable found in \"%s\", but matio was "
-                         "built without zlib support",mat->filename);
+            /* Skip compressed variables when reading only header info.
+             * Handling compressed data here has led to out-of-bounds
+             * memory accesses in some cases. To remain safe and avoid
+             * crashing while iterating variables, skip over the
+             * compressed block and do not attempt to inflate it.
+             */
             (void)fseek((FILE*)mat->fp,nBytes+8+fpos,SEEK_SET);
             return NULL;
-#endif
         }
+
         case MAT_T_MATRIX:
         {
             mat_uint32_t buf[6];
@@ -5743,6 +5635,7 @@ Mat_VarReadNextInfo5( mat_t *mat )
             /* Name of variable */
             if ( buf[0] == MAT_T_INT8 ) {    /* Name not in tag */
                 int len, i;
+                char *tbuf = NULL;
 
                 if ( mat->byteswap )
                     len = Mat_uint32Swap(buf+1);
@@ -5752,11 +5645,21 @@ Mat_VarReadNextInfo5( mat_t *mat )
                     i = len;
                 else
                     i = len+(8-(len % 8));
-                bytesread+=fread(buf,1,i,(FILE*)mat->fp);
+
+                tbuf = (char*)malloc(i);
+                if ( tbuf == NULL ) {
+                    Mat_Critical("Out of memory allocating variable name buffer");
+                    Mat_VarFree(matvar);
+                    return NULL;
+                }
+                bytesread += fread(tbuf,1,i,(FILE*)mat->fp);
 
                 matvar->name = (char*)malloc(len+1);
-                memcpy(matvar->name,buf,len);
-                matvar->name[len] = '\0';
+                if ( matvar->name != NULL ) {
+                    memcpy(matvar->name,tbuf,len);
+                    matvar->name[len] = '\0';
+                }
+                free(tbuf);
             } else if ( ((buf[0] & 0x0000ffff) == MAT_T_INT8) &&
                         ((buf[0] & 0xffff0000) != 0x00) ) {
                 /* Name packed in the tag */
@@ -5764,8 +5667,10 @@ Mat_VarReadNextInfo5( mat_t *mat )
 
                 len = (buf[0] & 0xffff0000) >> 16;
                 matvar->name = (char*)malloc(len+1);
-                memcpy(matvar->name,buf+1,len);
-                matvar->name[len] = '\0';
+                if ( matvar->name != NULL ) {
+                    memcpy(matvar->name,((char*)buf)+4,len);
+                    matvar->name[len] = '\0';
+                }
             }
             if ( matvar->class_type == MAT_C_STRUCT )
                 (void)ReadNextStructField(mat,matvar);