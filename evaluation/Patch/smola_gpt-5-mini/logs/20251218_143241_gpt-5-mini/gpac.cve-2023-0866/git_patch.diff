diff --git a/src/filters/reframe_adts.c b/src/filters/reframe_adts.c
index 80c98e5..a6553bd 100644
--- a/src/filters/reframe_adts.c
+++ b/src/filters/reframe_adts.c
@@ -828,19 +828,29 @@ GF_Err adts_dmx_process(GF_Filter *filter)
 			if (!dst_pck) return GF_OUT_OF_MEM;
 			if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
 
-			memcpy(output, sync + offset, size);
-
-			gf_filter_pck_set_dts(dst_pck, ctx->cts);
-			gf_filter_pck_set_cts(dst_pck, ctx->cts);
-			gf_filter_pck_set_duration(dst_pck, ctx->dts_inc);
-			gf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);
-			gf_filter_pck_set_sap(dst_pck, GF_FILTER_SAP_1);
-
-			if (ctx->byte_offset != GF_FILTER_NO_BO) {
-				gf_filter_pck_set_byte_offset(dst_pck, ctx->byte_offset + ctx->hdr.hdr_size);
-			}
-
-			gf_filter_pck_send(dst_pck);
+/* Ensure we do not read beyond the available source buffer */
+{
+    u32 available_src = (u32)((start + remain) - (sync + offset));
+    if (available_src < size) {
+        GF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, ("[ADTSDmx] truncated ADTS frame %u bytes but only %u available, truncating\n", size, available_src));
+        size = available_src;
+    }
+    if (!size) {
+        /* Nothing to copy - free allocated packet */
+        gf_filter_pck_unref(dst_pck);
+    } else {
+        memcpy(output, sync + offset, size);
+        gf_filter_pck_set_dts(dst_pck, ctx->cts);
+        gf_filter_pck_set_cts(dst_pck, ctx->cts);
+        gf_filter_pck_set_duration(dst_pck, ctx->dts_inc);
+        gf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);
+        gf_filter_pck_set_sap(dst_pck, GF_FILTER_SAP_1);
+        if (ctx->byte_offset != GF_FILTER_NO_BO) {
+            gf_filter_pck_set_byte_offset(dst_pck, ctx->byte_offset + ctx->hdr.hdr_size);
+        }
+        gf_filter_pck_send(dst_pck);
+    }
+}
 		}
 		adts_dmx_update_cts(ctx);