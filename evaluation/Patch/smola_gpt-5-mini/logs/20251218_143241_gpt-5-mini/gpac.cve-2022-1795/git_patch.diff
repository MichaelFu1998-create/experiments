diff --git a/src/scenegraph/base_scenegraph.c b/src/scenegraph/base_scenegraph.c
index 305e7ed..65b6688 100644
--- a/src/scenegraph/base_scenegraph.c
+++ b/src/scenegraph/base_scenegraph.c
@@ -662,11 +662,20 @@ void remove_node_id(GF_SceneGraph *sg, GF_Node *node)
 
 GF_Err gf_node_try_destroy(GF_SceneGraph *sg, GF_Node *pNode, GF_Node *parentNode)
 {
+	GF_Err e;
 	if (!sg) return GF_BAD_PARAM;
-	/*if node has been destroyed, don't even look at it*/
-	if (gf_list_find(sg->exported_nodes, pNode)>=0) return GF_OK;
-	if (!pNode || !pNode->sgprivate->num_instances) return GF_OK;
-	return gf_node_unregister(pNode, parentNode);
+	if (!pNode) return GF_OK;
+	/* if node has been marked exported/destroyed, don't touch it */
+	if (gf_list_find(sg->exported_nodes, pNode) >= 0) return GF_OK;
+	/* if no instances, nothing to do */
+	if (!pNode->sgprivate->num_instances) return GF_OK;
+
+	/* mark node as in-destruction to avoid re-entrant/double destroys */
+	gf_list_add(sg->exported_nodes, pNode);
+	e = gf_node_unregister(pNode, parentNode);
+	/* remove temporary marker if still present */
+	gf_list_del_item(sg->exported_nodes, pNode);
+	return e;
 }
 
 GF_EXPORT
diff --git a/src/scenegraph/commands.c b/src/scenegraph/commands.c
index 505719d..bfe4de7 100644
--- a/src/scenegraph/commands.c
+++ b/src/scenegraph/commands.c
@@ -61,7 +61,11 @@ void gf_sg_command_del(GF_Command *com)
 
 			switch (inf->fieldType) {
 			case GF_SG_VRML_SFNODE:
-				if (inf->new_node) gf_node_try_destroy(com->in_scene, inf->new_node, NULL);
+				if (inf->new_node) {
+				gf_node_try_destroy(com->in_scene, inf->new_node, NULL);
+				/* clear reference to avoid potential double-destroy/use-after-free */
+				inf->new_node = NULL;
+			}
 				break;
 			case GF_SG_VRML_MFNODE:
 				if (inf->field_ptr) {
@@ -70,6 +74,8 @@ void gf_sg_command_del(GF_Command *com)
 					while (child) {
 						GF_ChildNodeItem *cur = child;
 						gf_node_try_destroy(com->in_scene, child->node, NULL);
+						/* clear reference in the child item to avoid later use-after-free */
+						child->node = NULL;
 						child = child->next;
 						gf_free(cur);
 					}
@@ -88,14 +94,19 @@ void gf_sg_command_del(GF_Command *com)
 			GF_CommandField *inf = (GF_CommandField *)gf_list_get(com->command_fields, 0);
 			gf_list_rem(com->command_fields, 0);
 
-			if (inf->new_node)
+			if (inf->new_node) {
 				gf_node_try_destroy(com->in_scene, inf->new_node, NULL);
+				/* clear reference to avoid potential double-destroy/use-after-free */
+				inf->new_node = NULL;
+			}
 			else if (inf->node_list) {
 				GF_ChildNodeItem *child;
 				child = inf->node_list;
 				while (child) {
 					GF_ChildNodeItem *cur = child;
 					gf_node_try_destroy(com->in_scene, child->node, NULL);
+					/* clear reference in the child item to avoid later use-after-free */
+					child->node = NULL;
 					child = child->next;
 					gf_free(cur);
 				}
@@ -118,6 +129,8 @@ void gf_sg_command_del(GF_Command *com)
 
 	if (com->node) {
 		gf_node_try_destroy(com->in_scene, com->node, NULL);
+		/* clear command node reference after attempted destroy to avoid reuse */
+		com->node = NULL;
 	}
 
 	if (com->del_proto_list) gf_free(com->del_proto_list);