diff --git a/src/mat.c b/src/mat.c
index 4227c9c..d94b4ec 100644
--- a/src/mat.c
+++ b/src/mat.c
@@ -163,8 +163,12 @@ ComplexMalloc(size_t nbytes)
 void
 ComplexFree(mat_complex_split_t* complex_data)
 {
-    free(complex_data->Re);
-    free(complex_data->Im);
+    if ( complex_data == NULL )
+        return;
+    if ( complex_data->Re != NULL )
+        free(complex_data->Re);
+    if ( complex_data->Im != NULL )
+        free(complex_data->Im);
     free(complex_data);
 }
 
@@ -804,7 +808,7 @@ Mat_VarCalloc(void)
 {
     matvar_t *matvar;
 
-    matvar = (matvar_t*)malloc(sizeof(*matvar));
+    matvar = (matvar_t*)calloc(1, sizeof(*matvar));
 
     if ( NULL != matvar ) {
         matvar->nbytes       = 0;
@@ -820,7 +824,7 @@ Mat_VarCalloc(void)
         matvar->data         = NULL;
         matvar->mem_conserve = 0;
         matvar->compression  = MAT_COMPRESSION_NONE;
-        matvar->internal     = (struct matvar_internal*)malloc(sizeof(*matvar->internal));
+        matvar->internal     = (struct matvar_internal*)calloc(1, sizeof(*matvar->internal));
         if ( NULL == matvar->internal ) {
             free(matvar);
             matvar = NULL;
@@ -1027,8 +1031,11 @@ Mat_VarCreate(const char *name,enum matio_classes class_type,
         mat_sparse_t *sparse_data, *sparse_data_in;
 
         sparse_data_in = (mat_sparse_t*)data;
-        sparse_data    = (mat_sparse_t*)malloc(sizeof(mat_sparse_t));
+        sparse_data    = (mat_sparse_t*)calloc(1,sizeof(mat_sparse_t));
         if ( NULL != sparse_data ) {
+                    sparse_data->ir = NULL;
+                    sparse_data->jc = NULL;
+                    sparse_data->data = NULL;
             sparse_data->nzmax = sparse_data_in->nzmax;
             sparse_data->nir   = sparse_data_in->nir;
             sparse_data->njc   = sparse_data_in->njc;
@@ -1351,9 +1358,12 @@ Mat_VarDuplicate(const matvar_t *in, int opt)
             inflateCopy(out->internal->z,in->internal->z);
         if ( in->internal->data != NULL ) {
             if ( in->class_type == MAT_C_SPARSE ) {
-                out->internal->data = malloc(sizeof(mat_sparse_t));
+                out->internal->data = calloc(1,sizeof(mat_sparse_t));
                 if ( out->internal->data != NULL ) {
                     mat_sparse_t *out_sparse = (mat_sparse_t*)out->internal->data;
+                    out_sparse->ir = NULL;
+                    out_sparse->jc = NULL;
+                    out_sparse->data = NULL;
                     mat_sparse_t *in_sparse  = (mat_sparse_t*)in->internal->data;
                     out_sparse->nzmax = in_sparse->nzmax;
                     out_sparse->nir = in_sparse->nir;
@@ -1433,9 +1443,12 @@ Mat_VarDuplicate(const matvar_t *in, int opt)
             }
         }
     } else if ( (in->data != NULL) && (in->class_type == MAT_C_SPARSE) ) {
-        out->data = malloc(sizeof(mat_sparse_t));
+        out->data = calloc(1,sizeof(mat_sparse_t));
         if ( out->data != NULL ) {
             mat_sparse_t *out_sparse = (mat_sparse_t*)out->data;
+            out_sparse->ir = NULL;
+            out_sparse->jc = NULL;
+            out_sparse->data = NULL;
             mat_sparse_t *in_sparse  = (mat_sparse_t*)in->data;
             out_sparse->nzmax = in_sparse->nzmax;
             out_sparse->nir = in_sparse->nir;
@@ -1514,10 +1527,18 @@ Mat_VarFree(matvar_t *matvar)
             case MAT_C_STRUCT:
                 if ( !matvar->mem_conserve ) {
                     matvar_t **fields = (matvar_t**)matvar->data;
-                    size_t nelems_x_nfields, i;
-                    SafeMul(&nelems_x_nfields, nelems, matvar->internal->num_fields);
-                    for ( i = 0; i < nelems_x_nfields; i++ )
-                        Mat_VarFree(fields[i]);
+                    /* Only attempt to free individual fields if internal info
+                     * is available (num_fields).  If internal is NULL then
+                     * we cannot determine the number of fields safely and
+                     * should avoid dereferencing it to prevent use of
+                     * uninitialized memory.
+                     */
+                    if ( matvar->internal != NULL ) {
+                        size_t nelems_x_nfields, i;
+                        SafeMul(&nelems_x_nfields, nelems, matvar->internal->num_fields);
+                        for ( i = 0; i < nelems_x_nfields; i++ )
+                            Mat_VarFree(fields[i]);
+                    }
 
                     free(matvar->data);
                 }
diff --git a/src/mat4.c b/src/mat4.c
index 28a1bcf..7f5c4f3 100644
--- a/src/mat4.c
+++ b/src/mat4.c
@@ -216,6 +216,10 @@ Mat_VarWrite4(mat_t *mat,matvar_t *matvar)
 #endif
 
             sparse = (mat_sparse_t*)matvar->data;
+			/* Initialize pointers to avoid freeing uninitialized memory */
+			sparse->ir = NULL;
+			sparse->jc = NULL;
+			sparse->data = NULL;
             x.type += 2;
             x.mrows = sparse->njc > 0 ? sparse->jc[sparse->njc - 1] + 1 : 1;
             x.ncols = matvar->isComplex ? 4 : 3;
@@ -386,6 +390,10 @@ Mat_VarRead4(mat_t *mat,matvar_t *matvar)
                     return 1;
                 }
                 sparse = (mat_sparse_t*)matvar->data;
+			/* Initialize pointers to avoid freeing uninitialized memory */
+			sparse->ir = NULL;
+			sparse->jc = NULL;
+			sparse->data = NULL;
                 sparse->nir = matvar->dims[0] - 1;
                 sparse->nzmax = sparse->nir;
                 err = SafeMul(&readcount, sparse->nir, sizeof(mat_uint32_t));
diff --git a/src/mat5.c b/src/mat5.c
index 82508e7..e05be7c 100644
--- a/src/mat5.c
+++ b/src/mat5.c
@@ -3020,14 +3020,18 @@ Mat_VarRead5(mat_t *mat, matvar_t *matvar)
             mat_sparse_t *sparse;
 
             matvar->data_size = sizeof(mat_sparse_t);
-            matvar->data      = malloc(matvar->data_size);
+            matvar->data      = calloc(1,matvar->data_size);
             if ( matvar->data == NULL ) {
                 Mat_Critical("Mat_VarRead5: Allocation of data pointer failed");
                 err = 1;
                 break;
             }
             sparse = (mat_sparse_t*)matvar->data;
-            sparse->nzmax  = matvar->nbytes;
+            /* Initialize pointers to avoid freeing uninitialized memory */
+		sparse->ir = NULL;
+		sparse->jc = NULL;
+		sparse->data = NULL;
+	sparse->nzmax  = matvar->nbytes;
             (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
             /*  Read ir    */
             bytesread += ReadSparse(mat, matvar, &sparse->nir, &sparse->ir);