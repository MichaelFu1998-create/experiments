diff --git a/src/isomedia/isom_read.c b/src/isomedia/isom_read.c
index ba474c3..595e79e 100644
--- a/src/isomedia/isom_read.c
+++ b/src/isomedia/isom_read.c
@@ -25,6 +25,9 @@
 
 
 #include <gpac/internal/isomedia_dev.h>
+
+/* Prototype for SGPD writer to avoid traversing box sizes when comparing SGPD boxes */
+extern GF_Err sgpd_box_write(GF_Box *s, GF_BitStream *bs);
 #include <gpac/constants.h>
 
 #ifndef GPAC_DISABLE_ISOM
@@ -5851,19 +5854,28 @@ Bool gf_isom_is_identical_sgpd(void *ptr1, void *ptr2, u32 grouping_type)
 {
 	Bool res = GF_FALSE;
 #ifndef GPAC_DISABLE_ISOM_WRITE
-	GF_BitStream *bs1, *bs2;
-	u8 *buf1, *buf2;
-	u32 len1, len2;
+	GF_BitStream *bs1 = NULL, *bs2 = NULL;
+	u8 *buf1 = NULL, *buf2 = NULL;
+	u32 len1 = 0, len2 = 0;
 
 	if (!ptr1 || !ptr2)
 		return GF_FALSE;
+	/* avoid serializing full boxes (grouping_type==0) which may traverse malformed structures */
+	if (!grouping_type) return GF_FALSE;
 
 	bs1 = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
 	if (grouping_type) {
 		sgpd_write_entry(grouping_type, ptr1, bs1);
 	} else {
-		gf_isom_box_size((GF_Box *)ptr1);
-		gf_isom_box_write((GF_Box *)ptr1, bs1);
+		/* If this is an SGPD box, use its dedicated writer to avoid
+		   computing box sizes which may traverse child structures and
+		   trigger out-of-bounds accesses on malformed inputs. */
+		GF_Box *box1 = (GF_Box *)ptr1;
+		if (box1 && box1->type == GF_ISOM_BOX_TYPE_SGPD) {
+			sgpd_box_write(box1, bs1);
+		} else {
+			gf_isom_box_write(box1, bs1);
+		}
 	}
 	gf_bs_get_content(bs1, &buf1, &len1);
 	gf_bs_del(bs1);
@@ -5872,21 +5884,26 @@ Bool gf_isom_is_identical_sgpd(void *ptr1, void *ptr2, u32 grouping_type)
 	if (grouping_type) {
 		sgpd_write_entry(grouping_type, ptr2, bs2);
 	} else {
-		gf_isom_box_write((GF_Box *)ptr2, bs2);
+		GF_Box *box2 = (GF_Box *)ptr2;
+		if (box2 && box2->type == GF_ISOM_BOX_TYPE_SGPD) {
+			sgpd_box_write(box2, bs2);
+		} else {
+			gf_isom_box_write(box2, bs2);
+		}
 	}
 	gf_bs_get_content(bs2, &buf2, &len2);
 	gf_bs_del(bs2);
 
-
 	if ((len1==len2) && !memcmp(buf1, buf2, len1))
 		res = GF_TRUE;
 
-	gf_free(buf1);
-	gf_free(buf2);
+	if (buf1) gf_free(buf1);
+	if (buf2) gf_free(buf2);
 #endif
 	return res;
 }
 
+
 GF_EXPORT
 u64 gf_isom_get_track_magic(GF_ISOFile *movie, u32 trackNumber)
 {