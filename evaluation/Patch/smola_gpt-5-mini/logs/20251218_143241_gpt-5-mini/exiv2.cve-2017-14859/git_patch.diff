diff --git a/src/futils.cpp b/src/futils.cpp
index d142718..7c8343e 100644
--- a/src/futils.cpp
+++ b/src/futils.cpp
@@ -53,7 +53,7 @@ EXIV2_RCSID("@(#) $Id$")
 # ifdef EXV_STRERROR_R_CHAR_P
 extern char *strerror_r(int errnum, char *buf, size_t n);
 # else
-extern int strerror_r(int errnum, char *buf, size_t n);
+extern char *strerror_r(int errnum, char *buf, size_t n);
 # endif
 #endif
 
@@ -241,8 +241,8 @@ namespace Exiv2 {
     Protocol fileProtocol(const std::string& path) {
         Protocol result = pFile ;
         struct {
-        	std::string name ;
-        	Protocol    prot ;
+                std::string name ;
+                Protocol    prot ;
         } prots[] =
         { { "http://"   ,pHttp     }
         , { "https://"  ,pHttps    }
@@ -254,8 +254,8 @@ namespace Exiv2 {
         , { "-"         ,pStdin    }
         };
         for ( size_t i = 0 ; result == pFile && i < sizeof(prots)/sizeof(prots[0]) ; i ++ )
-        	if ( path.find(prots[i].name) == 0 )
-        		result = prots[i].prot;
+                if ( path.find(prots[i].name) == 0 )
+                        result = prots[i].prot;
 
         return result;
     } // fileProtocol
@@ -263,8 +263,8 @@ namespace Exiv2 {
     Protocol fileProtocol(const std::wstring& wpath) {
         Protocol result = pFile ;
         struct {
-        	std::wstring wname ;
-        	Protocol      prot ;
+                std::wstring wname ;
+                Protocol      prot ;
         } prots[] =
         { { L"http://"   ,pHttp     }
         , { L"https://"  ,pHttps    }
@@ -276,21 +276,21 @@ namespace Exiv2 {
         , { L"-"         ,pStdin    }
         };
         for ( size_t i = 0 ; result == pFile && i < sizeof(prots)/sizeof(prots[0]) ; i ++ )
-        	if ( wpath.find(prots[i].wname) == 0 )
-        		result = prots[i].prot;
+                if ( wpath.find(prots[i].wname) == 0 )
+                        result = prots[i].prot;
 
         return result;
     } // fileProtocol
 #endif
     bool fileExists(const std::string& path, bool ct)
     {
-		// special case: accept "-" (means stdin)
+                // special case: accept "-" (means stdin)
         if (path.compare("-") == 0 || fileProtocol(path)) {
-			return true;
+                        return true;
         }
 
         struct stat buf;
-		int ret = ::stat(path.c_str(), &buf);
+                int ret = ::stat(path.c_str(), &buf);
         if (0 != ret)                    return false;
         if (ct && !S_ISREG(buf.st_mode)) return false;
         return true;
@@ -299,9 +299,9 @@ namespace Exiv2 {
 #ifdef EXV_UNICODE_PATH
     bool fileExists(const std::wstring& wpath, bool ct)
     {
-		// special case: accept "-" (means stdin)
+                // special case: accept "-" (means stdin)
         if (wpath.compare(L"-") == 0 || fileProtocol(wpath)) {
-			return true;
+                        return true;
         }
 
         struct _stat buf;
diff --git a/src/tiffvisitor.cpp b/src/tiffvisitor.cpp
index 4ab733d..4e5dc00 100644
--- a/src/tiffvisitor.cpp
+++ b/src/tiffvisitor.cpp
@@ -1538,8 +1538,20 @@ namespace Exiv2 {
         }
         Value::AutoPtr v = Value::create(typeId);
         assert(v.get());
+        // Validate pData/size to prevent reading invalid memory
+        if (size > 0) {
+            if (pData < pData_ || pData > pLast_ || static_cast<uint32_t>(pLast_ - pData) < size) {
+#ifndef SUPPRESS_WARNINGS
+                EXV_ERROR << "Entry in directory " << groupName(object->group())
+                          << ", entry 0x" << std::setw(4)
+                          << std::setfill('0') << std::hex << object->tag()
+                          << " has invalid data pointer/size; skipping read.\n";
+#endif
+                size = 0;
+            }
+        }
         if ( !isize ) {
-        	v->read(pData, size, byteOrder());
+            v->read(pData, size, byteOrder());
         } else {
         	// #1143 Write a "hollow" buffer for the preview image
         	//       Sadly: we don't know the exact location of the image in the source (it's near offset)
diff --git a/src/value.cpp b/src/value.cpp
index d518926..3718858 100644
--- a/src/value.cpp
+++ b/src/value.cpp
@@ -292,17 +292,70 @@ namespace Exiv2 {
 
     int StringValueBase::read(const std::string& buf)
     {
-        value_ = buf;
-        return 0;
+        // Protect against excessively large inputs to avoid huge allocations
+        // or potential integer overflows when converting sizes.
+        const std::string::size_type max_allowed = 16 * 1024 * 1024; // 16 MB
+        try {
+            if (buf.size() == 0) {
+                value_.clear();
+                return 0;
+            }
+            if (buf.size() > value_.max_size()) {
+                // Too large to represent
+                value_.clear();
+                return 1;
+            }
+            if (buf.size() > max_allowed) {
+                // Truncate overly large inputs to a reasonable size
+                value_.assign(buf.data(), max_allowed);
+                return 0;
+            }
+            // Normal case: copy the content. Wrap in try/catch to handle any
+            // allocation or other exceptions safely.
+            value_ = buf;
+            return 0;
+        } catch (...) {
+            value_.clear();
+            return 1;
+        }
     }
 
     int StringValueBase::read(const byte* buf, long len, ByteOrder /*byteOrder*/)
     {
         // byteOrder not needed
-        if (buf) value_ = std::string(reinterpret_cast<const char*>(buf), len);
+        // Protect against negative lengths (which would convert to a huge size_t
+        // and cause std::string to attempt to read out-of-bounds memory) and
+        // excessively large lengths that exceed string::max_size().
+        if (!buf) {
+            value_.clear();
+            return 0;
+        }
+        if (len < 0) {
+            // Invalid length
+            value_.clear();
+            return 1;
+        }
+        const std::string::size_type ulen = static_cast<std::string::size_type>(len);
+        if (ulen == 0) {
+            value_.clear();
+            return 0;
+        }
+        // Cap the maximum amount we will copy from an external buffer to avoid
+        // attempting to read unreasonable amounts of memory if the length is
+        // corrupted. This prevents large allocations and excessive reads.
+        const std::string::size_type max_allowed = static_cast<std::string::size_type>(16 * 1024 * 1024); // 16 MB
+        std::string::size_type copy_len = (ulen > max_allowed) ? max_allowed : ulen;
+        if (copy_len > value_.max_size()) {
+            // Too large to represent
+            value_.clear();
+            return 1;
+        }
+        // Use assign to construct from a pointer/length safely
+        value_.assign(reinterpret_cast<const char*>(buf), copy_len);
         return 0;
     }
 
+
     long StringValueBase::copy(byte* buf, ByteOrder /*byteOrder*/) const
     {
         if (value_.size() == 0) return 0;