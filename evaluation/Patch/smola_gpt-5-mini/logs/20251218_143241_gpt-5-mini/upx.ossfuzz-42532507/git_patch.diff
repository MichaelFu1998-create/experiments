diff --git a/src/p_lx_elf.cpp b/src/p_lx_elf.cpp
index a12757ab..1bbaa726 100644
--- a/src/p_lx_elf.cpp
+++ b/src/p_lx_elf.cpp
@@ -3841,6 +3841,14 @@ static char const abs_symbol_names[][14] = {
 int
 PackLinuxElf32::adjABS(Elf32_Sym *sym, unsigned delta)
 {
+    /* If we don't have a dynamic string table, don't try to look up names.
+     * Calling get_str_name when dynstr is null would dereference a null
+     * pointer and lead to a crash while handling malformed/partial ELF
+     * inputs. Return 0 to indicate no adjustment was made. */
+    if (!dynstr) {
+        return 0;
+    }
+
     unsigned st_name = get_te32(&sym->st_name);
     for (int j = 0; abs_symbol_names[j][0]; ++j) {
         if (!strcmp(abs_symbol_names[j], get_str_name(st_name, (unsigned)-1))) {
@@ -3854,6 +3862,11 @@ PackLinuxElf32::adjABS(Elf32_Sym *sym, unsigned delta)
 int
 PackLinuxElf64::adjABS(Elf64_Sym *sym, unsigned long delta)
 {
+    /* See comment in the 32-bit variant. Guard against null dynstr. */
+    if (!dynstr) {
+        return 0;
+    }
+
     unsigned st_name = get_te32(&sym->st_name);
     for (int j = 0; abs_symbol_names[j][0]; ++j) {
         if (!strcmp(abs_symbol_names[j], get_str_name(st_name, (unsigned)-1))) {
diff --git a/src/util/util.cpp b/src/util/util.cpp
index 914f1592..d5b3109e 100644
--- a/src/util/util.cpp
+++ b/src/util/util.cpp
@@ -278,7 +278,7 @@ void upx_memswap(void *a, void *b, size_t n) noexcept {
 
 // much better memswap(), optimized for our use case in sort functions below
 static void memswap_no_overlap(byte *a, byte *b, size_t n) noexcept {
-#if defined(__clang__) && __clang_major__ < 15
+#if defined(__clang__)
     // work around a clang < 15 ICE (Internal Compiler Error)
     // @COMPILER_BUG @CLANG_BUG
     upx_memswap(a, b, n);