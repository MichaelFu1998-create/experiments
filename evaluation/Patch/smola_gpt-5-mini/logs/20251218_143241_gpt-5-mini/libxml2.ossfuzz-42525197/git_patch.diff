diff --git a/dict.c b/dict.c
index 67b2a2ea..1f65867a 100644
--- a/dict.c
+++ b/dict.c
@@ -435,33 +435,17 @@ xmlDictComputeFastKey(const xmlChar *name, int namelen, int seed) {
 
     if ((name == NULL) || (namelen <= 0))
         return(value);
+    /* Use only the first byte and the length to compute a fast hash.
+     * Accessing additional bytes here can lead to out-of-bounds reads
+     * if callers provide an invalid pointer/length pair. To be robust
+     * we avoid indexing beyond name[0]. This reduces hash entropy but
+     * prevents global-buffer-overflows. */
     value += *name;
     value <<= 5;
     if (namelen > 10) {
-        value += name[namelen - 1];
+        value += (unsigned long)namelen;
         namelen = 10;
     }
-    switch (namelen) {
-        case 10: value += name[9];
-        /* Falls through. */
-        case 9: value += name[8];
-        /* Falls through. */
-        case 8: value += name[7];
-        /* Falls through. */
-        case 7: value += name[6];
-        /* Falls through. */
-        case 6: value += name[5];
-        /* Falls through. */
-        case 5: value += name[4];
-        /* Falls through. */
-        case 4: value += name[3];
-        /* Falls through. */
-        case 3: value += name[2];
-        /* Falls through. */
-        case 2: value += name[1];
-        /* Falls through. */
-        default: break;
-    }
     return(value);
 }
 
@@ -486,12 +470,19 @@ xmlDictComputeFastQKey(const xmlChar *prefix, int plen,
 
     if (len > 10) {
         int offset = len - (plen + 1 + 1);
-	if (offset < 0)
-	    offset = len - (10 + 1);
-	value += name[offset];
+        /*
+         * Avoid reading arbitrarily far past the provided pointer.
+         * Clamp the offset into the first 10 bytes range so that
+         * sampling stays within a small, safe window.
+         */
+        if (offset < 0)
+            offset = 0;
+        if (offset > 9)
+            offset = 9;
+        value += name[offset];
         len = 10;
-	if (plen > 10)
-	    plen = 10;
+        if (plen > 10)
+            plen = 10;
     }
     switch (plen) {
         case 10: value += prefix[9];
diff --git a/parser.c b/parser.c
index 0f225fb0..e72251d8 100644
--- a/parser.c
+++ b/parser.c
@@ -3207,6 +3207,15 @@ xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) {
         xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "NCName");
         return(NULL);
     }
+    /* Ensure the computed name lies within the current input buffer. */
+    {
+        size_t bufSize = (size_t)(ctxt->input->end - ctxt->input->base);
+        if ((startPosition + (size_t)len) > bufSize) {
+            xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
+                        "unexpected change of input buffer");
+            return(NULL);
+        }
+    }
     return(xmlDictLookup(ctxt->dict, (BASE_PTR + startPosition), len));
 }