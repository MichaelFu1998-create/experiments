diff --git a/src/filters/reframe_mpgvid.c b/src/filters/reframe_mpgvid.c
index 8e092f9..b38ea82 100644
--- a/src/filters/reframe_mpgvid.c
+++ b/src/filters/reframe_mpgvid.c
@@ -1157,6 +1157,16 @@ GF_Err mpgviddmx_process(GF_Filter *filter)
 		if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
 		//bytes come from both our store and the data packet
 		if (bytes_from_store) {
+			/* ensure we don't read beyond available input */
+			u32 from_remain = (remain>0) ? (u32)remain : 0;
+			u32 total_avail = bytes_from_store + from_remain;
+			if ((u32)size > total_avail) {
+				GF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, ("[MPGVid] Truncating frame: declared size %u > available %u", (u32)size, from_remain));
+				/* clamp size to available bytes */
+				size = total_avail;
+				/* mark frame as not full */
+				full_frame = GF_FALSE;
+			}
 			memcpy(pck_data, ctx->hdr_store+current, bytes_from_store);
 			assert(size >= bytes_from_store);
 			size -= bytes_from_store;
@@ -1165,6 +1175,13 @@ GF_Err mpgviddmx_process(GF_Filter *filter)
 			}
 			memcpy(pck_data + bytes_from_store, start, (size_t) size);
 		} else {
+			/* ensure we don't read beyond available input */
+			u32 from_remain = (remain>0) ? (u32)remain : 0;
+			if ((u32)size > from_remain) {
+				GF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, ("[MPGVid] Truncating frame: declared size %u > available %u", (u32)size, from_remain));
+				size = from_remain;
+				full_frame = GF_FALSE;
+			}
 			//bytes only come the data packet
 			memcpy(pck_data, start, (size_t) size);
 			if (byte_offset != GF_FILTER_NO_BO) {