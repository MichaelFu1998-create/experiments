diff --git a/mrbgems/mruby-bigint/core/bigint.c b/mrbgems/mruby-bigint/core/bigint.c
index b7892ef21..ef539b78c 100644
--- a/mrbgems/mruby-bigint/core/bigint.c
+++ b/mrbgems/mruby-bigint/core/bigint.c
@@ -406,116 +406,61 @@ ulshift(mrb_state *mrb, mpz_t *c1, mpz_t *a, size_t n)
 }
 
 /* internal routine to compute x/y and x%y ignoring signs */
+static mp_limb safe_hd(mpz_t *a, size_t i) {
+  size_t idx = (size_t)(i)/2;
+  if ((size_t)i >= 2*(a->sz)) return (mp_limb)0;
+  if (idx >= a->sz) return (mp_limb)0;
+  if ((i)%2) return HIGH(a->p[idx]);
+  return LOW(a->p[idx]);
+}
+
+static void mpz_mul_2exp(mrb_state *mrb, mpz_t *z, mpz_t *x, mrb_int e);
+
 static void
 udiv(mrb_state *mrb, mpz_t *qq, mpz_t *rr, mpz_t *xx, mpz_t *yy)
 {
-  mpz_t q, x, y, r;
-  int ns,f,ccc=0;
-  size_t xd,yd,i,j;
-  mp_limb zz,z,qhat,b,u,m;
-
-  if (uzero(yy))
-    return;
-  mpz_init(mrb,&q); mpz_init(mrb,&x);mpz_init(mrb,&y);mpz_init(mrb,&r);
-  mpz_realloc(mrb,&x,(size_t)((xx->sz)+1));
-  yd = digits(yy);
-  ns = lzb(yy->p[yd-1]);
-  ulshift(mrb,&x,xx,ns);
-  ulshift(mrb,&y,yy,ns);
-  xd = digits(&x);
-  mpz_realloc(mrb,&q,(size_t)xd);
-  xd*=2; yd*=2;
-  z = hd(&y,yd-1);
-  for (j=(xd-yd);;j--) {
-    if (z == LMAX)
-      qhat = hd(&x,j+yd);
-    else {
-      qhat = ((hd(&x,j+yd)<< HALFDIGITBITS) + hd(&x,j+yd-1)) / (z+1);
-    }
-    b = 0; zz=0;
-    if (qhat) {
-      for (i=0; i<yd; i++) {
-        zz = qhat * hd(&y,i);
-        u = hd(&x,i+j);
-        u-=b;
-        if (u<0) {
-          b=1; u+=HLMAX+1;
-        }
-        else
-          b=0;
-        u-=LOW(zz);
-        if (u < 0) {
-          b++;
-          u+=HLMAX+1;
-        }
-        b+=HIGH(zz);
-        if ((i+j)%2)
-          x.p[(i+j)/2] = LOW(x.p[(i+j)/2]) | (u << HALFDIGITBITS);
-        else
-          x.p[(i+j)/2] = (HIGH(x.p[(i+j)/2]) << HALFDIGITBITS) | u;
-      }
-      if (b) {
-        if ((j+i)%2)
-          x.p[(i+j)/2] -= b << HALFDIGITBITS;
-        else
-          x.p[(i+j)/2] -= b;
-      }
+  /* A simpler, safe division: binary long division using repeated doubling. */
+  mpz_t q, rem, t, one, tmp, dbl;
+
+  if (uzero(yy)) return;
+
+  mpz_init(mrb, &q); mpz_init(mrb, &rem); mpz_init(mrb, &t);
+  mpz_init_set_int(mrb, &one, 1); mpz_init(mrb, &tmp); mpz_init(mrb, &dbl);
+
+  mpz_set(mrb, &rem, xx);
+  zero(&q);
+
+  while (ucmp(&rem, yy) >= 0) {
+    /* set t = yy */
+    mpz_set(mrb, &t, yy);
+    /* double t until it would exceed rem */
+    size_t k = 0;
+    while (1) {
+      /* dbl = t << 1 */
+      mpz_set(mrb, &dbl, &t);
+      mpz_mul_2exp(mrb, &dbl, &dbl, 1);
+      if (ucmp(&dbl, &rem) > 0) break;
+      mpz_set(mrb, &t, &dbl);
+      k++;
+      /* safety: limit k to avoid infinite loops */
+      if (k > (size_t)((rem.sz + 8) * (DIGITBITS))) break;
     }
-    for (;;zz++) {
-      f=1;
-      if (!hd(&x,j+yd)) {
-        for (i=yd-1; ; i--) {
-          if (hd(&x,j+i) > hd(&y,i)) {
-            f=1;
-            break;
-          }
-          if (hd(&x,j+i) < hd(&y,i)) {
-            f=0;
-            break;
-          }
-          if (i == 0) break;
-        }
-      }
-      if (!f)
-        break;
-      qhat++;
-      ccc++;
-      b=0;
-      for (i=0;i<yd;i++) {
-        m = hd(&x,i+j)-hd(&y,i)-b;
-        if (m < 0) {
-          b = 1;
-          m = HLMAX + 1 + m;
-        }
-        else
-          b = 0;
-        if ((i+j)%2)
-          x.p[(i+j)/2] = LOW(x.p[(i+j)/2]) | (m << HALFDIGITBITS);
-        else
-          x.p[(i+j)/2] = (HIGH(x.p[(i+j)/2]) << HALFDIGITBITS) | m;
-      }
-      if (b) {
-        if ((j+i)%2)
-          x.p[(i+j)/2] -= b << HALFDIGITBITS;
-        else
-          x.p[(i+j)/2] -= b;
-      }
-    }
-    if (j%2)
-      q.p[j/2] |= qhat << HALFDIGITBITS;
-    else
-      q.p[j/2] |= qhat;
-    if (j == 0) break;
+    /* rem = rem - t */
+    mpz_sub(mrb, &tmp, &rem, &t);
+    mpz_set(mrb, &rem, &tmp);
+
+    /* add (1 << k) to q */
+    mpz_set(mrb, &tmp, &one);
+    mpz_mul_2exp(mrb, &tmp, &tmp, (mrb_int)k);
+    mpz_add(mrb, &q, &q, &tmp);
   }
-  mpz_realloc(mrb,&r,(size_t)(yy->sz));
-  zero(&r);
-  urshift(mrb,&r,&x,ns);
-  mpz_set(mrb,rr,&r);
-  mpz_set(mrb,qq,&q);
-  mpz_clear(mrb,&x); mpz_clear(mrb,&y);
-  mpz_clear(mrb,&q); mpz_clear(mrb,&r);
-}
 
+  mpz_set(mrb, qq, &q);
+  mpz_set(mrb, rr, &rem);
+
+  mpz_clear(mrb, &q); mpz_clear(mrb, &rem); mpz_clear(mrb, &t);
+  mpz_clear(mrb, &one); mpz_clear(mrb, &tmp); mpz_clear(mrb, &dbl);
+}
 static void
 mpz_mdiv(mrb_state *mrb, mpz_t *q, mpz_t *x, mpz_t *y)
 {