diff --git a/mrbgems/mruby-io/src/io.c b/mrbgems/mruby-io/src/io.c
index 58bcdd1..51eeea6 100644
--- a/mrbgems/mruby-io/src/io.c
+++ b/mrbgems/mruby-io/src/io.c
@@ -556,38 +556,57 @@ mrb_io_initialize_copy(mrb_state *mrb, mrb_value copy)
 {
   mrb_value orig;
   mrb_value buf;
-  struct mrb_io *fptr_copy;
+  struct mrb_io *fptr_copy = NULL;
   struct mrb_io *fptr_orig;
   mrb_bool failed = TRUE;
+  int newfd = -1;
+  int newfd2 = -1;
 
   mrb_get_args(mrb, "o", &orig);
-  fptr_copy = (struct mrb_io *)DATA_PTR(copy);
-  if (fptr_copy != NULL) {
+
+  /* free existing internal pointer if any */
+  if (DATA_PTR(copy) != NULL) {
+    fptr_copy = (struct mrb_io *)DATA_PTR(copy);
     fptr_finalize(mrb, fptr_copy, FALSE);
     mrb_free(mrb, fptr_copy);
+    DATA_PTR(copy) = NULL;
   }
-  fptr_copy = (struct mrb_io *)mrb_io_alloc(mrb);
-  fptr_orig = io_get_open_fptr(mrb, orig);
-
-  DATA_TYPE(copy) = &mrb_io_type;
-  DATA_PTR(copy) = fptr_copy;
 
-  buf = mrb_iv_get(mrb, orig, mrb_intern_cstr(mrb, "@buf"));
-  mrb_iv_set(mrb, copy, mrb_intern_cstr(mrb, "@buf"), buf);
+  /* ensure orig is a valid IO object before allocating */
+  fptr_orig = io_get_open_fptr(mrb, orig);
 
-  fptr_copy->fd = mrb_dup(mrb, fptr_orig->fd, &failed);
+  /* duplicate file descriptors before allocating fptr_copy to avoid leaks
+     if duplication fails and an exception is raised */
+  newfd = mrb_dup(mrb, fptr_orig->fd, &failed);
   if (failed) {
     mrb_sys_fail(mrb, 0);
   }
-  mrb_fd_cloexec(mrb, fptr_copy->fd);
 
   if (fptr_orig->fd2 != -1) {
-    fptr_copy->fd2 = mrb_dup(mrb, fptr_orig->fd2, &failed);
+    newfd2 = mrb_dup(mrb, fptr_orig->fd2, &failed);
     if (failed) {
-      close(fptr_copy->fd);
+      close(newfd);
       mrb_sys_fail(mrb, 0);
     }
+  }
+
+  /* now safe to allocate and assign */
+  fptr_copy = (struct mrb_io *)mrb_io_alloc(mrb);
+
+  DATA_TYPE(copy) = &mrb_io_type;
+  DATA_PTR(copy) = fptr_copy;
+
+  buf = mrb_iv_get(mrb, orig, mrb_intern_cstr(mrb, "@buf"));
+  mrb_iv_set(mrb, copy, mrb_intern_cstr(mrb, "@buf"), buf);
+
+  fptr_copy->fd = newfd;
+  mrb_fd_cloexec(mrb, fptr_copy->fd);
+
+  if (newfd2 != -1) {
+    fptr_copy->fd2 = newfd2;
     mrb_fd_cloexec(mrb, fptr_copy->fd2);
+  } else {
+    fptr_copy->fd2 = -1;
   }
 
   fptr_copy->pid = fptr_orig->pid;