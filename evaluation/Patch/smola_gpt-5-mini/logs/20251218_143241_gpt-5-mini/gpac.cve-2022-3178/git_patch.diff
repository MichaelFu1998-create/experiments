diff --git a/applications/mp4box/filedump.c b/applications/mp4box/filedump.c
index 5974fca..45394fe 100644
--- a/applications/mp4box/filedump.c
+++ b/applications/mp4box/filedump.c
@@ -3975,10 +3975,12 @@ void DumpMovieInfo(GF_ISOFile *file, Bool full_dump)
 		if (type) {
 			fprintf(stderr, "unknown type %d\n", type);
 		} else {
-			u16 *src_str = (u16 *) data;
-			u32 len = UTF8_MAX_BYTES_PER_CHAR * gf_utf8_wcslen(src_str);
+						u16 *src_str = (u16 *) data;
+			/* data may not be NUL-terminated: use data_len to bound conversion */
+			u32 src_len_chars = data_len / 2;
+			u32 len = UTF8_MAX_BYTES_PER_CHAR * src_len_chars;
 			char *utf8str = (char *)gf_malloc(len + 1);
-			u32 res_len = gf_utf8_wcstombs(utf8str, len, (const unsigned short **) &src_str);
+			u32 res_len = gf_utf8_wcstombs_len(utf8str, len, (const unsigned short **) &src_str, src_len_chars);
 			if (res_len != GF_UTF8_FAIL) {
 				utf8str[res_len] = 0;
 				fprintf(stderr, "%s\n", utf8str);
diff --git a/include/gpac/utf.h b/include/gpac/utf.h
index b44de3a..20ead5c 100644
--- a/include/gpac/utf.h
+++ b/include/gpac/utf.h
@@ -61,6 +61,9 @@ Converts a wide-char string to a multibyte string
 \return length (in byte) of the multibyte string or GF_UTF8_FAIL if error.
  */
 u32 gf_utf8_wcstombs(char* dst, size_t dst_len, const unsigned short** srcp);
+/* bounded version: src_len_chars is the number of UTF-16 characters available in *srcp */
+u32 gf_utf8_wcstombs_len(char* dst, size_t dst_len, const unsigned short** srcp, size_t src_len_chars);
+
 
 /*!
 \brief multibyte to wide-char conversion
diff --git a/src/filters/reframe_mp3.c b/src/filters/reframe_mp3.c
index 7661a1b..eb4e856 100644
--- a/src/filters/reframe_mp3.c
+++ b/src/filters/reframe_mp3.c
@@ -193,7 +193,7 @@ static void mp3_dmx_check_dur(GF_Filter *filter, GF_MP3DmxCtx *ctx)
 
 
 #include <gpac/utf.h>
-static void id3dmx_set_string(GF_FilterPid *apid, char *name, u8 *buf, Bool is_dyn)
+static void id3dmx_set_string(GF_FilterPid *apid, char *name, u8 *buf, u32 buf_size, Bool is_dyn)
 {
 	if ((buf[0]==0xFF) || (buf[0]==0xFE)) {
 		const u16 *sptr = (u16 *) (buf+2);
@@ -275,11 +275,11 @@ void id3dmx_flush(GF_Filter *filter, u8 *id3_buf, u32 id3_buf_size, GF_FilterPid
 			sep = memchr(buf, 0, fsize);
 			if (sep) {
 				if (!stricmp(buf+1, "comment")) {
-					id3dmx_set_string(audio_pid, "comment", sep+1, GF_FALSE);
+					id3dmx_set_string(audio_pid, "comment", sep+1, (u32)(fsize - ((sep+1)-buf)), GF_FALSE);
 				} else {
 					strcpy(szTag, "tag_");
 					strncat(szTag, buf+1, 1019);
-					id3dmx_set_string(audio_pid, szTag, sep+1, GF_TRUE);
+					id3dmx_set_string(audio_pid, szTag, sep+1, (u32)(fsize - ((sep+1)-buf)), GF_TRUE);
 				}
 			}
 		} else if (ftag == GF_ID3V2_FRAME_APIC) {
@@ -319,11 +319,11 @@ void id3dmx_flush(GF_Filter *filter, u8 *id3_buf, u32 id3_buf_size, GF_FilterPid
 			}
 		} else if (tag_idx>=0) {
 			const char *tag_name = gf_itags_get_name((u32) tag_idx);
-			id3dmx_set_string(audio_pid, (char *) tag_name, buf+1, GF_FALSE);
+			id3dmx_set_string(audio_pid, (char *) tag_name, buf+1, fsize - 1, GF_FALSE);
 		} else {
 			sprintf(szTag, "tag_%s", gf_4cc_to_str(ftag));
 			if ((ftag>>24) == 'T') {
-				id3dmx_set_string(audio_pid, szTag, buf+1, GF_TRUE);
+				id3dmx_set_string(audio_pid, szTag, buf+1, fsize - 1, GF_TRUE);
 			} else {
 				gf_filter_pid_set_property_dyn(audio_pid, szTag, &PROP_DATA(buf, fsize) );
 			}
diff --git a/src/isomedia/box_code_base.c b/src/isomedia/box_code_base.c
index 3cf6b3b..62ea6a0 100644
--- a/src/isomedia/box_code_base.c
+++ b/src/isomedia/box_code_base.c
@@ -12886,11 +12886,12 @@ GF_Err xtra_box_read(GF_Box *s, GF_BitStream *bs)
 			prop_type = gf_bs_read_u16(bs);
 			prop_size -= 6;
 			ISOM_DECREASE_SIZE_NO_ERR(ptr, prop_size)
-			//add 2 extra bytes for UTF16 case string dump
-			data2 = gf_malloc(sizeof(char) * (prop_size+2));
+			//add extra bytes for UTF16 case string dump to ensure safe 16-bit termination
+			data2 = gf_malloc(sizeof(char) * (prop_size+3));
 			gf_bs_read_data(bs, data2, prop_size);
 			data2[prop_size] = 0;
 			data2[prop_size+1] = 0;
+			data2[prop_size+2] = 0;
 			tag_size-=prop_size;
 		} else {
 			prop_size = 0;
diff --git a/src/utils/utf.c b/src/utils/utf.c
index cde2aae..2b54733 100644
--- a/src/utils/utf.c
+++ b/src/utils/utf.c
@@ -463,6 +463,26 @@ u32 gf_utf8_wcstombs(char* dest, size_t len, const unsigned short** srcp)
 		return (u32) strlen(dest);
 	}
 }
+GF_EXPORT
+u32 gf_utf8_wcstombs_len(char* dest, size_t len, const unsigned short** srcp, size_t src_len_chars)
+{
+    if (!srcp || !*srcp)
+        return 0;
+    else {
+        const UTF16** sourceStart = srcp;
+        const UTF16* sourceEnd = *sourceStart + (ptrdiff_t)src_len_chars;
+        UTF8* targetStart = (UTF8*) dest;
+        UTF8* targetEnd = (UTF8*) dest + len;
+        ConversionFlags flags = strictConversion;
+
+        ConversionResult res = ConvertUTF16toUTF8(sourceStart, sourceEnd, &targetStart, targetEnd, flags);
+        if (res != conversionOK) return GF_UTF8_FAIL;
+        if (targetStart < targetEnd) *targetStart = 0;
+        *srcp=NULL;
+        return (u32) strlen(dest);
+    }
+}
+
 
 GF_EXPORT
 u32 gf_utf8_mbstowcs(unsigned short* dest, size_t len, const char** srcp)