diff --git a/src/inflate.c b/src/inflate.c
index 5fd205a..4032d85 100644
--- a/src/inflate.c
+++ b/src/inflate.c
@@ -401,21 +401,36 @@ InflateRankDims(mat_t *mat, matvar_t *matvar, void *buf, size_t nbytes, mat_uint
         bytesread += fread(comp_buf,1,1,(FILE*)mat->fp);
     }
 
-    matvar->internal->z->avail_out = rank;
-    if ( sizeof(mat_uint32_t)*(rank + 2) <= nbytes ) {
-        matvar->internal->z->next_out = (Bytef*)((mat_int32_t *)buf+2);
+matvar->internal->z->avail_out = rank;
+    /*
+     * The variable `rank` holds the number of bytes of dimension data
+     * (tag[1]) possibly padded to an 8-byte boundary.  We need to ensure
+     * there is enough room in the provided `buf` (which is nbytes long)
+     * to hold the 8-byte tag plus `rank` bytes.  The previous check used
+     * sizeof(mat_uint32_t)*(rank + 2) which mixes units (bytes vs #elements)
+     * and can incorrectly decide to write inflated data into `buf` when
+     * there is not enough space, leading to a stack buffer overflow.  Fix
+     * by comparing byte sizes and allocate a separate dims buffer when
+     * necessary.  When allocating, allocate `rank/4` elements of
+     * mat_uint32_t (rank is in bytes).
+     */
+    if ( (size_t)rank + 8 <= nbytes ) {
+        /* safe to place the dims inside buf after the 8-byte tag */
+        matvar->internal->z->next_out = (Bytef*)(((mat_uint8_t*)buf) + 8);
     } else {
-        /* Cannot use too small buf, but can allocate output buffer dims */
-        *dims = (mat_uint32_t*)calloc(rank, sizeof(mat_uint32_t));
+        size_t nelems = (size_t)rank / sizeof(mat_uint32_t);
+        /* Cannot use too small buf, allocate output buffer dims */
+        *dims = (mat_uint32_t*)calloc(nelems, sizeof(mat_uint32_t));
         if ( NULL != *dims ) {
             matvar->internal->z->next_out = (Bytef*)*dims;
         } else {
+            /* indicate error by zeroing the rank in the tag */
             *((mat_int32_t *)buf+1) = 0;
             Mat_Critical("Error allocating memory for dims");
             return bytesread;
         }
     }
-    err = inflate(matvar->internal->z,Z_NO_FLUSH);
+err = inflate(matvar->internal->z,Z_NO_FLUSH);
     if ( err != Z_OK ) {
         Mat_Critical("InflateRankDims: inflate returned %s",zError(err == Z_NEED_DICT ? Z_DATA_ERROR : err));
         return bytesread;
diff --git a/src/mat5.c b/src/mat5.c
index abdb351..44ba303 100644
--- a/src/mat5.c
+++ b/src/mat5.c
@@ -908,7 +908,9 @@ ReadNextCell( mat_t *mat, matvar_t *matvar )
 
     if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {
 #if defined(HAVE_ZLIB)
-        mat_uint32_t uncomp_buf[16] = {0,};
+        mat_uint32_t *uncomp_buf = (mat_uint32_t*)calloc(512, sizeof(mat_uint32_t));
+        if ( NULL == uncomp_buf ) { Mat_Critical("Couldn't allocate memory"); return bytesread; }
+        memset(uncomp_buf,0,512*sizeof(mat_uint32_t));
         int nbytes;
         mat_uint32_t array_flags;
 
@@ -967,7 +969,7 @@ ReadNextCell( mat_t *mat, matvar_t *matvar )
             if ( cells[i]->class_type != MAT_C_OPAQUE ) {
                 mat_uint32_t* dims = NULL;
                 int do_clean = 0;
-                bytesread += InflateRankDims(mat,matvar,uncomp_buf,sizeof(uncomp_buf),&dims);
+                bytesread += InflateRankDims(mat,matvar,uncomp_buf,uncomp_buf_len,&dims);
                 if ( NULL == dims )
                     dims = uncomp_buf + 2;
                 else
@@ -980,16 +982,28 @@ ReadNextCell( mat_t *mat, matvar_t *matvar )
                 /* Rank and Dimension */
                 if ( uncomp_buf[0] == MAT_T_INT32 ) {
                     int j;
-                    cells[i]->rank = uncomp_buf[1];
+                    mat_uint32_t rank_bytes = uncomp_buf[1];
+                    if ( rank_bytes > (mat_uint32_t)nbytes ) {
+                        Mat_Critical("InflateRankDims: rank size larger than remaining bytes, truncating");
+                        rank_bytes = (mat_uint32_t)nbytes;
+                    }
+                    cells[i]->rank = rank_bytes;
                     nbytes -= cells[i]->rank;
                     cells[i]->rank /= 4;
-                    cells[i]->dims = (size_t*)malloc(cells[i]->rank*sizeof(*cells[i]->dims));
-                    if ( mat->byteswap ) {
-                        for ( j = 0; j < cells[i]->rank; j++ )
-                            cells[i]->dims[j] = Mat_uint32Swap(dims + j);
-                    } else {
-                        for ( j = 0; j < cells[i]->rank; j++ )
-                            cells[i]->dims[j] = dims[j];
+                    if ( cells[i]->rank > 0 ) {
+                        cells[i]->dims = (size_t*)malloc(cells[i]->rank*sizeof(*cells[i]->dims));
+                        if ( NULL != cells[i]->dims ) {
+                            if ( mat->byteswap ) {
+                                for ( j = 0; j < cells[i]->rank; j++ )
+                                    cells[i]->dims[j] = Mat_uint32Swap(dims + j);
+                            } else {
+                                for ( j = 0; j < cells[i]->rank; j++ )
+                                    cells[i]->dims[j] = dims[j];
+                            }
+                        } else {
+                            cells[i]->rank = 0;
+                            Mat_Critical("Error allocating memory for dims");
+                        }
                     }
                     if ( cells[i]->rank % 2 != 0 )
                         nbytes -= 4;
@@ -1069,6 +1083,7 @@ ReadNextCell( mat_t *mat, matvar_t *matvar )
             }
             bytesread+=InflateSkip(mat,matvar->internal->z,nbytes);
         }
+        free(uncomp_buf);
 #else
         Mat_Critical("Not compiled with zlib support");
 #endif
@@ -1199,7 +1214,9 @@ ReadNextStructField( mat_t *mat, matvar_t *matvar )
     }
     if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {
 #if defined(HAVE_ZLIB)
-        mat_uint32_t uncomp_buf[16] = {0,};
+        mat_uint32_t *uncomp_buf = (mat_uint32_t*)calloc(512, sizeof(mat_uint32_t));
+        if ( NULL == uncomp_buf ) { Mat_Critical("Couldn't allocate memory"); return bytesread; }
+        memset(uncomp_buf,0,512*sizeof(mat_uint32_t));
         int nbytes;
         mat_uint32_t array_flags, len;
 
@@ -1343,7 +1360,7 @@ ReadNextStructField( mat_t *mat, matvar_t *matvar )
             if ( fields[i]->class_type != MAT_C_OPAQUE ) {
                 mat_uint32_t* dims = NULL;
                 int do_clean = 0;
-                bytesread += InflateRankDims(mat,matvar,uncomp_buf,sizeof(uncomp_buf),&dims);
+                bytesread += InflateRankDims(mat,matvar,uncomp_buf,uncomp_buf_len,&dims);
                 if ( NULL == dims )
                     dims = uncomp_buf + 2;
                 else
@@ -1356,17 +1373,29 @@ ReadNextStructField( mat_t *mat, matvar_t *matvar )
                 /* Rank and dimension */
                 if ( uncomp_buf[0] == MAT_T_INT32 ) {
                     int j;
-                    fields[i]->rank = uncomp_buf[1];
+                    mat_uint32_t rank_bytes = uncomp_buf[1];
+                    if ( rank_bytes > (mat_uint32_t)nbytes ) {
+                        Mat_Critical("InflateRankDims: rank size larger than remaining bytes, truncating");
+                        rank_bytes = (mat_uint32_t)nbytes;
+                    }
+                    fields[i]->rank = rank_bytes;
                     nbytes -= fields[i]->rank;
                     fields[i]->rank /= 4;
-                    fields[i]->dims = (size_t*)malloc(fields[i]->rank*
-                                             sizeof(*fields[i]->dims));
-                    if ( mat->byteswap ) {
-                        for ( j = 0; j < fields[i]->rank; j++ )
-                            fields[i]->dims[j] = Mat_uint32Swap(dims+j);
-                    } else {
-                        for ( j = 0; j < fields[i]->rank; j++ )
-                            fields[i]->dims[j] = dims[j];
+                    if ( fields[i]->rank > 0 ) {
+                        fields[i]->dims = (size_t*)malloc(fields[i]->rank*
+                                                 sizeof(*fields[i]->dims));
+                        if ( NULL != fields[i]->dims ) {
+                            if ( mat->byteswap ) {
+                                for ( j = 0; j < fields[i]->rank; j++ )
+                                    fields[i]->dims[j] = Mat_uint32Swap(dims+j);
+                            } else {
+                                for ( j = 0; j < fields[i]->rank; j++ )
+                                    fields[i]->dims[j] = dims[j];
+                            }
+                        } else {
+                            fields[i]->rank = 0;
+                            Mat_Critical("Error allocating memory for dims");
+                        }
                     }
                     if ( fields[i]->rank % 2 != 0 )
                         nbytes -= 4;
@@ -1415,6 +1444,7 @@ ReadNextStructField( mat_t *mat, matvar_t *matvar )
             }
             bytesread+=InflateSkip(mat,matvar->internal->z,nbytes);
         }
+        free(uncomp_buf);
 #else
         Mat_Critical("Not compiled with zlib support");
 #endif
@@ -1974,7 +2004,9 @@ WriteCompressedTypeArrayFlags(mat_t *mat,matvar_t *matvar,z_streamp z)
     int nBytes, i, nzmax = 0;
 
     mat_uint32_t comp_buf[512];
-    mat_uint32_t uncomp_buf[512] = {0,};
+    mat_uint32_t *uncomp_buf = (mat_uint32_t*)calloc(512, sizeof(mat_uint32_t));
+        if ( NULL == uncomp_buf ) { Mat_Critical("Couldn't allocate memory"); return bytesread; }
+        memset(uncomp_buf,0,512*sizeof(mat_uint32_t));
     int buf_size = 512;
     size_t byteswritten = 0;
 
@@ -2055,7 +2087,9 @@ WriteCompressedType(mat_t *mat,matvar_t *matvar,z_streamp z)
 {
     int err;
     mat_uint32_t comp_buf[512];
-    mat_uint32_t uncomp_buf[512] = {0,};
+    mat_uint32_t *uncomp_buf = (mat_uint32_t*)calloc(512, sizeof(mat_uint32_t));
+        if ( NULL == uncomp_buf ) { Mat_Critical("Couldn't allocate memory"); return bytesread; }
+        memset(uncomp_buf,0,512*sizeof(mat_uint32_t));
     size_t byteswritten = 0, nelems = 1;
 
     if ( MAT_C_EMPTY == matvar->class_type ) {
@@ -2239,7 +2273,9 @@ static size_t
 WriteCompressedCellArrayField(mat_t *mat,matvar_t *matvar,z_streamp z)
 {
     mat_uint32_t comp_buf[512];
-    mat_uint32_t uncomp_buf[512] = {0,};
+    mat_uint32_t *uncomp_buf = (mat_uint32_t*)calloc(512, sizeof(mat_uint32_t));
+        if ( NULL == uncomp_buf ) { Mat_Critical("Couldn't allocate memory"); return bytesread; }
+        memset(uncomp_buf,0,512*sizeof(mat_uint32_t));
     int buf_size = 512;
     size_t byteswritten = 0, field_buf_size;
 
@@ -2365,7 +2401,9 @@ static size_t
 WriteCompressedStructField(mat_t *mat,matvar_t *matvar,z_streamp z)
 {
     mat_uint32_t comp_buf[512];
-    mat_uint32_t uncomp_buf[512] = {0,};
+    mat_uint32_t *uncomp_buf = (mat_uint32_t*)calloc(512, sizeof(mat_uint32_t));
+        if ( NULL == uncomp_buf ) { Mat_Critical("Couldn't allocate memory"); return bytesread; }
+        memset(uncomp_buf,0,512*sizeof(mat_uint32_t));
     int buf_size = 512;
     size_t byteswritten = 0, field_buf_size;
 
@@ -2492,7 +2530,9 @@ Mat_WriteCompressedEmptyVariable5(mat_t *mat,const char *name,int rank,
     size_t nBytes, empty_matrix_max_buf_size;
 
     mat_uint32_t comp_buf[512];
-    mat_uint32_t uncomp_buf[512] = {0,};
+    mat_uint32_t *uncomp_buf = (mat_uint32_t*)calloc(512, sizeof(mat_uint32_t));
+        if ( NULL == uncomp_buf ) { Mat_Critical("Couldn't allocate memory"); return bytesread; }
+        memset(uncomp_buf,0,512*sizeof(mat_uint32_t));
     int buf_size = 512;
     size_t byteswritten = 0, buf_size_bytes;
 
@@ -4587,7 +4627,9 @@ Mat_VarWrite5(mat_t *mat,matvar_t *matvar,int compress)
 #if defined(HAVE_ZLIB)
     } else if ( compress == MAT_COMPRESSION_ZLIB ) {
         mat_uint32_t comp_buf[512];
-        mat_uint32_t uncomp_buf[512] = {0,};
+        mat_uint32_t *uncomp_buf = (mat_uint32_t*)calloc(512, sizeof(mat_uint32_t));
+        if ( NULL == uncomp_buf ) { Mat_Critical("Couldn't allocate memory"); return bytesread; }
+        memset(uncomp_buf,0,512*sizeof(mat_uint32_t));
         int buf_size = 512, err;
         size_t byteswritten = 0, matrix_max_buf_size;
         z_streamp z;
@@ -4777,7 +4819,9 @@ Mat_VarReadNextInfo5( mat_t *mat )
         case MAT_T_COMPRESSED:
         {
 #if defined(HAVE_ZLIB)
-            mat_uint32_t uncomp_buf[16] = {0,};
+            mat_uint32_t *uncomp_buf = (mat_uint32_t*)calloc(512, sizeof(mat_uint32_t));
+        if ( NULL == uncomp_buf ) { Mat_Critical("Couldn't allocate memory"); return bytesread; }
+        memset(uncomp_buf,0,512*sizeof(mat_uint32_t));
             int      nbytes;
             long     bytesread = 0;
 
@@ -4833,7 +4877,7 @@ Mat_VarReadNextInfo5( mat_t *mat )
             if ( matvar->class_type != MAT_C_OPAQUE ) {
                 mat_uint32_t* dims = NULL;
                 int do_clean = 0;
-                bytesread += InflateRankDims(mat,matvar,uncomp_buf,sizeof(uncomp_buf),&dims);
+                bytesread += InflateRankDims(mat,matvar,uncomp_buf,uncomp_buf_len,&dims);
                 if ( NULL == dims )
                     dims = uncomp_buf + 2;
                 else