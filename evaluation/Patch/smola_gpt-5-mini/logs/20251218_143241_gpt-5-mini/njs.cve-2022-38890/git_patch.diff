diff --git a/src/njs_iterator.c b/src/njs_iterator.c
index 9309677..8c8d92d 100644
--- a/src/njs_iterator.c
+++ b/src/njs_iterator.c
@@ -569,7 +569,7 @@ njs_object_iterate_reverse(njs_vm_t *vm, njs_iterator_args_t *args,
             }
 
             while (i-- > to) {
-                pos = njs_utf8_prev(p);
+                pos = (p == string_prop.start) ? p : njs_utf8_prev(p);
 
                 /* This cannot fail. */
                 (void) njs_string_new(vm, &character, pos, p - pos , 1);
diff --git a/src/njs_string.c b/src/njs_string.c
index 83cede5..06d1e20 100644
--- a/src/njs_string.c
+++ b/src/njs_string.c
@@ -2306,13 +2306,21 @@ njs_string_prototype_last_index_of(njs_vm_t *vm, njs_value_t *args,
             goto done;
         }
 
-        p = njs_string_offset(string.start, end, index);
+        /* Iterate by codepoint index using njs_string_offset on each
+         * iteration. This avoids calling njs_utf8_prev and prevents
+         * potential out-of-bounds reads when pointers are near the
+         * string boundaries. */
+        for (;;) {
+            p = njs_string_offset(string.start, end, index);
 
-        for (; p >= string.start; p = njs_utf8_prev(p)) {
             if ((p + s.size) <= end && memcmp(p, s.start, s.size) == 0) {
                 goto done;
             }
 
+            if (index == 0) {
+                break;
+            }
+
             index--;
         }
 
@@ -2852,7 +2860,7 @@ njs_string_trim(const njs_value_t *value, njs_string_prop_t *string,
                     break;
                 }
 
-                prev = njs_utf8_prev(prev);
+                prev = (prev == start) ? start : njs_utf8_prev(prev);
                 p = prev;
                 cp = njs_utf8_decode(&ctx, &p, end);
 
diff --git a/src/njs_utf8.h b/src/njs_utf8.h
index 26c23db..5857a5d 100644
--- a/src/njs_utf8.h
+++ b/src/njs_utf8.h
@@ -1,4 +1,3 @@
-
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) NGINX, Inc.
@@ -49,6 +48,11 @@ njs_utf8_next(const u_char *p, const u_char *end)
 {
     u_char  c;
 
+/* If p is already at or past end, nothing to do. */
+    if (p >= end) {
+        return p;
+    }
+
     c = *p++;
 
     if ((c & 0x80) != 0) {