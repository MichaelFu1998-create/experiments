diff --git a/src/decode.c b/src/decode.c
index 205056a..8c37cb3 100644
--- a/src/decode.c
+++ b/src/decode.c
@@ -2050,8 +2050,13 @@ read_R2004_section_info (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,
       uint64_t sum_decomp = 0;
       uint64_t prev_address = 0;
 
-      if (ptr + 64 >= decomp_end)
-        {
+      /* Ensure we have enough decompressed data left for the full
+       * Dwg_Section_Info structure.  The code below reads 32+64 bytes
+       * (96) into 'info' via bfr_read(), so checking only for 64
+       * bytes was incorrect and could lead to a buffer over-read.
+       */
+      if (ptr + (32 + 64) > decomp_end)
+      {
           free (decomp);
           dwg->header.section_infohdr.num_desc = i;
           LOG_ERROR ("read_R2004_section_info out of range");
@@ -2073,8 +2078,14 @@ read_R2004_section_info (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,
                  info->encrypted)
       LOG_TRACE ("name:            %s\n\n", info->name)
 
-      if (ptr + (16 * info->num_sections) >= decomp_end)
-        {
+      /* Ensure there is enough room for the section page table.  We
+       * will read (16 * num_sections) bytes below, so reject the
+       * input if those bytes are not present.  Using '>' (not '>=')
+       * keeps the original semantics but matches the actual read
+       * size and prevents reading past decomp_end.
+       */
+      if (ptr + (16 * info->num_sections) > decomp_end)
+      {
           info->name[0] = '\0';
           info->num_sections = 0;
           info->sections = NULL;