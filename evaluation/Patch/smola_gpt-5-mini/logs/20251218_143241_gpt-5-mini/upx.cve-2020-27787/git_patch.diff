diff --git a/src/p_lx_elf.cpp b/src/p_lx_elf.cpp
index 96f5838..cf0dfe3 100644
--- a/src/p_lx_elf.cpp
+++ b/src/p_lx_elf.cpp
@@ -1575,16 +1575,28 @@ PackLinuxElf32::invert_pt_dynamic(Elf32_Dyn const *dynp)
     unsigned ndx = 1+ 0;
     if (dynp)
     for (; ; ++ndx, ++dynp) {
+        /* bounds check: ensure we do not read past the dynamic segment */
+        if (!dynseg) { throwCantPack("bad PT_DYNAMIC (null)"); }
+        { upx_uint64_t off = (upx_uint64_t)(uintptr_t)dynp - (upx_uint64_t)(uintptr_t)dynseg;
+          if (off + (upx_uint64_t)sizeof(*dynp) > sz_dynseg) {
+            throwCantPack("bad PT_DYNAMIC (truncated)");
+          }
+        }
         unsigned const d_tag = get_te32(&dynp->d_tag);
         if (d_tag < DT_NUM) {
             if (Elf32_Dyn::DT_NEEDED != d_tag
-            &&  dt_table[d_tag]
-            &&    get_te32(&dynp->d_val)
-               != get_te32(&dynp0[-1+ dt_table[d_tag]].d_val)) {
-                char msg[50]; snprintf(msg, sizeof(msg),
-                    "duplicate DT_%#x: [%#x] [%#x]",
-                    d_tag, -1+ dt_table[d_tag], -1+ ndx);
-                throwCantPack(msg);
+            &&  dt_table[d_tag]) {
+                unsigned idx = dt_table[d_tag];
+                const Elf32_Dyn *ref = &dynp0[-1 + idx];
+                if (!dynseg || (unsigned)((char const *)ref - (char const *)dynseg) + (unsigned)sizeof(*ref) > sz_dynseg) {
+                    throwCantPack("bad PT_DYNAMIC (bad index)");
+                }
+                if (get_te32(&dynp->d_val) != get_te32(&ref->d_val)) {
+                    char msg[50]; snprintf(msg, sizeof(msg),
+                        "duplicate DT_%#x: [%#x] [%#x]",
+                        d_tag, -1+ dt_table[d_tag], -1+ ndx);
+                    throwCantPack(msg);
+                }
             }
             dt_table[d_tag] = ndx;
         }
@@ -1599,7 +1611,7 @@ PackLinuxElf32::invert_pt_dynamic(Elf32_Dyn const *dynp)
 
     unsigned const z_str = dt_table[Elf32_Dyn::DT_STRSZ];
     if (z_str) {
-        strtab_end = get_te32(&dynp0[-1+ z_str].d_val);
+        strtab_end = ((dt_table[z_str] && (dynseg && ((((upx_uint64_t)(uintptr_t)(&dynp0[-1+z_str]) - (upx_uint64_t)(uintptr_t)dynseg) + (upx_uint64_t)sizeof(dynp0[-1]) ) <= sz_dynseg)) ) ? get_te32(&dynp0[-1+z_str].d_val) : (throwCantPack("bad PT_DYNAMIC (bad index)"),0) );
         if ((u32_t)file_size <= strtab_end) { // FIXME: weak
             char msg[50]; snprintf(msg, sizeof(msg),
                 "bad DT_STRSZ %#x", strtab_end);
@@ -1609,11 +1621,11 @@ PackLinuxElf32::invert_pt_dynamic(Elf32_Dyn const *dynp)
     unsigned const x_sym = dt_table[Elf32_Dyn::DT_SYMTAB];
     unsigned const x_str = dt_table[Elf32_Dyn::DT_STRTAB];
     if (x_sym && x_str) {
-        upx_uint32_t const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);
-        upx_uint32_t const v_str = get_te32(&dynp0[-1+ x_str].d_val);
+        upx_uint32_t const v_sym = ( (dt_table[x_sym] && (((upx_uint64_t)(uintptr_t)&dynp0[-1+ x_sym] - (upx_uint64_t)(uintptr_t)dynseg) < sz_dynseg)) ? ((dt_table[x_sym] && (dynseg && ((((upx_uint64_t)(uintptr_t)(&dynp0[-1+x_sym]) - (upx_uint64_t)(uintptr_t)dynseg) + (upx_uint64_t)sizeof(dynp0[-1]) ) <= sz_dynseg)) ) ? get_te32(&dynp0[-1+x_sym].d_val) : (throwCantPack("bad PT_DYNAMIC (bad index)"),0) ) : (throwCantPack("bad PT_DYNAMIC (bad index)"),0) );
+        upx_uint32_t const v_str = ((dt_table[x_str] && (dynseg && ((((upx_uint64_t)(uintptr_t)(&dynp0[-1+x_str]) - (upx_uint64_t)(uintptr_t)dynseg) + (upx_uint64_t)sizeof(dynp0[-1]) ) <= sz_dynseg)) ) ? get_te32(&dynp0[-1+x_str].d_val) : (throwCantPack("bad PT_DYNAMIC (bad index)"),0) );
         unsigned const  z_sym = dt_table[Elf32_Dyn::DT_SYMENT];
         unsigned const sz_sym = !z_sym ? sizeof(Elf32_Sym)
-            : get_te32(&dynp0[-1+ z_sym].d_val);
+            : ((dt_table[z_sym] && (dynseg && ((((upx_uint64_t)(uintptr_t)(&dynp0[-1+z_sym]) - (upx_uint64_t)(uintptr_t)dynseg) + (upx_uint64_t)sizeof(dynp0[-1]) ) <= sz_dynseg)) ) ? get_te32(&dynp0[-1+z_sym].d_val) : (throwCantPack("bad PT_DYNAMIC (bad index)"),0) );
         if (sz_sym < sizeof(Elf32_Sym)) {
             char msg[50]; snprintf(msg, sizeof(msg),
                 "bad DT_SYMENT %x", sz_sym);
@@ -1639,7 +1651,7 @@ PackLinuxElf32::invert_pt_dynamic(Elf32_Dyn const *dynp)
         unsigned const *const buckets = &hashtab[2];
         unsigned const *const chains = &buckets[nbucket]; (void)chains;
 
-        unsigned const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);
+        unsigned const v_sym = ( (dt_table[x_sym] && (((upx_uint64_t)(uintptr_t)&dynp0[-1+ x_sym] - (upx_uint64_t)(uintptr_t)dynseg) < sz_dynseg)) ? ((dt_table[x_sym] && (dynseg && ((((upx_uint64_t)(uintptr_t)(&dynp0[-1+x_sym]) - (upx_uint64_t)(uintptr_t)dynseg) + (upx_uint64_t)sizeof(dynp0[-1]) ) <= sz_dynseg)) ) ? get_te32(&dynp0[-1+x_sym].d_val) : (throwCantPack("bad PT_DYNAMIC (bad index)"),0) ) : (throwCantPack("bad PT_DYNAMIC (bad index)"),0) );
         if (!nbucket
         || (nbucket>>31) || (file_size/sizeof(unsigned)) <= (2*nbucket)  // FIXME: weak
         || ((v_hsh < v_sym) && (v_sym - v_hsh) < (sizeof(unsigned)*2  // headers
@@ -1670,7 +1682,7 @@ PackLinuxElf32::invert_pt_dynamic(Elf32_Dyn const *dynp)
         unsigned     const *const hasharr = &buckets[n_bucket]; (void)hasharr;
       //unsigned     const *const gashend = &hasharr[n_bucket];  // minimum
 
-        unsigned const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);
+        unsigned const v_sym = ( (dt_table[x_sym] && (((upx_uint64_t)(uintptr_t)&dynp0[-1+ x_sym] - (upx_uint64_t)(uintptr_t)dynseg) < sz_dynseg)) ? ((dt_table[x_sym] && (dynseg && ((((upx_uint64_t)(uintptr_t)(&dynp0[-1+x_sym]) - (upx_uint64_t)(uintptr_t)dynseg) + (upx_uint64_t)sizeof(dynp0[-1]) ) <= sz_dynseg)) ) ? get_te32(&dynp0[-1+x_sym].d_val) : (throwCantPack("bad PT_DYNAMIC (bad index)"),0) ) : (throwCantPack("bad PT_DYNAMIC (bad index)"),0) );
         if (!n_bucket || !n_bitmask
         || (-1+ n_bitmask) & n_bitmask  // not a power of 2
         || 8*sizeof(unsigned) <= gnu_shift  // shifted result always == 0
@@ -4953,7 +4965,8 @@ PackLinuxElf32::check_pt_dynamic(Elf32_Phdr const *const phdr)
             (unsigned)(phdr - phdri));
         throwCantPack(msg);
     }
-    sz_dynseg = memsz;
+    /* Use filesz (actual data available) instead of memsz to avoid reading past mapped file */
+    sz_dynseg = filesz;
     return t;
 }
 
@@ -4962,7 +4975,7 @@ PackLinuxElf32::elf_find_dynamic(unsigned int key) const
 {
     Elf32_Dyn const *dynp= dynseg;
     if (dynp)
-    for (; (unsigned)((char const *)dynp - (char const *)dynseg) < sz_dynseg
+    for (; ((upx_uint64_t)(uintptr_t)dynp - (upx_uint64_t)(uintptr_t)dynseg) < sz_dynseg
             && Elf32_Dyn::DT_NULL!=dynp->d_tag; ++dynp) if (get_te32(&dynp->d_tag)==key) {
         unsigned const t= elf_get_offset_from_address(get_te32(&dynp->d_val));
         if (t && t < (unsigned)file_size) {
@@ -4978,7 +4991,7 @@ PackLinuxElf32::elf_unsigned_dynamic(unsigned int key) const
 {
     Elf32_Dyn const *dynp= dynseg;
     if (dynp)
-    for (; (unsigned)((char const *)dynp - (char const *)dynseg) < sz_dynseg
+    for (; ((upx_uint64_t)(uintptr_t)dynp - (upx_uint64_t)(uintptr_t)dynseg) < sz_dynseg
             && Elf32_Dyn::DT_NULL!=dynp->d_tag; ++dynp) if (get_te32(&dynp->d_tag)==key) {
         return get_te32(&dynp->d_val);
     }
@@ -5054,7 +5067,8 @@ PackLinuxElf64::check_pt_dynamic(Elf64_Phdr const *const phdr)
             (unsigned)(phdr - phdri));
         throwCantPack(msg);
     }
-    sz_dynseg = memsz;
+    /* Use filesz (actual data available) instead of memsz to avoid reading past mapped file */
+    sz_dynseg = filesz;
     return t;
 }
 
@@ -5068,6 +5082,13 @@ PackLinuxElf64::invert_pt_dynamic(Elf64_Dyn const *dynp)
     unsigned ndx = 1+ 0;
     if (dynp)
     for (; ; ++ndx, ++dynp) {
+        /* bounds check: ensure we do not read past the dynamic segment */
+        if (!dynseg) { throwCantPack("bad PT_DYNAMIC (null)"); }
+        { upx_uint64_t off = (upx_uint64_t)(uintptr_t)dynp - (upx_uint64_t)(uintptr_t)dynseg;
+          if (off + (upx_uint64_t)sizeof(*dynp) > sz_dynseg) {
+            throwCantPack("bad PT_DYNAMIC (truncated)");
+          }
+        }
         upx_uint64_t const d_tag = get_te64(&dynp->d_tag);
         if (d_tag>>32) { // outrageous
             char msg[50]; snprintf(msg, sizeof(msg),
@@ -5076,13 +5097,19 @@ PackLinuxElf64::invert_pt_dynamic(Elf64_Dyn const *dynp)
         }
         if (d_tag < DT_NUM) {
             if (Elf64_Dyn::DT_NEEDED != d_tag
-            &&  dt_table[d_tag]
-            &&    get_te64(&dynp->d_val)
-               != get_te64(&dynp0[-1+ dt_table[d_tag]].d_val)) {
-                char msg[50]; snprintf(msg, sizeof(msg),
-                    "duplicate DT_%#x: [%#x] [%#x]",
-                    (unsigned)d_tag, -1+ dt_table[d_tag], -1+ ndx);
-                throwCantPack(msg);
+            &&  dt_table[d_tag]) {
+                /* ensure the referenced previous entry is within dynseg */
+                upx_uint64_t idx = dt_table[d_tag];
+                const Elf64_Dyn *ref = &dynp0[-1 + idx];
+                if (!dynseg || (upx_uint64_t)((char const *)ref - (char const *)dynseg) + (upx_uint64_t)sizeof(*ref) > sz_dynseg) {
+                    throwCantPack("bad PT_DYNAMIC (bad index)");
+                }
+                if (get_te64(&dynp->d_val) != get_te64(&ref->d_val)) {
+                    char msg[50]; snprintf(msg, sizeof(msg),
+                        "duplicate DT_%#x: [%#x] [%#x]",
+                        (unsigned)d_tag, -1+ dt_table[d_tag], -1+ ndx);
+                    throwCantPack(msg);
+                }
             }
             dt_table[d_tag] = ndx;
         }
@@ -5097,7 +5124,7 @@ PackLinuxElf64::invert_pt_dynamic(Elf64_Dyn const *dynp)
 
     unsigned const z_str = dt_table[Elf64_Dyn::DT_STRSZ];
     if (z_str) {
-        strtab_end = get_te64(&dynp0[-1+ z_str].d_val);
+        strtab_end = ((dt_table[z_str] && (dynseg && ((((upx_uint64_t)(uintptr_t)(&dynp0[-1+z_str]) - (upx_uint64_t)(uintptr_t)dynseg) + (upx_uint64_t)sizeof(dynp0[-1]) ) <= sz_dynseg)) ) ? get_te64(&dynp0[-1+z_str].d_val) : (throwCantPack("bad PT_DYNAMIC (bad index)"),0) );
         if ((u64_t)file_size <= strtab_end) { // FIXME: weak
             char msg[50]; snprintf(msg, sizeof(msg),
                 "bad DT_STRSZ %#x", strtab_end);
@@ -5109,11 +5136,11 @@ PackLinuxElf64::invert_pt_dynamic(Elf64_Dyn const *dynp)
     unsigned const x_sym = dt_table[Elf64_Dyn::DT_SYMTAB];
     unsigned const x_str = dt_table[Elf64_Dyn::DT_STRTAB];
     if (x_sym && x_str) {
-        upx_uint64_t const v_sym = get_te64(&dynp0[-1+ x_sym].d_val);
-        upx_uint64_t const v_str = get_te64(&dynp0[-1+ x_str].d_val);
+        upx_uint64_t const v_sym = ( (dt_table[x_sym] && (((upx_uint64_t)(uintptr_t)&dynp0[-1+ x_sym] - (upx_uint64_t)(uintptr_t)dynseg) < sz_dynseg)) ? ((dt_table[x_sym] && (dynseg && ((((upx_uint64_t)(uintptr_t)(&dynp0[-1+x_sym]) - (upx_uint64_t)(uintptr_t)dynseg) + (upx_uint64_t)sizeof(dynp0[-1]) ) <= sz_dynseg)) ) ? get_te64(&dynp0[-1+x_sym].d_val) : (throwCantPack("bad PT_DYNAMIC (bad index)"),0) ) : (throwCantPack("bad PT_DYNAMIC (bad index)"),0) );
+        upx_uint64_t const v_str = ((dt_table[x_str] && (dynseg && ((((upx_uint64_t)(uintptr_t)(&dynp0[-1+x_str]) - (upx_uint64_t)(uintptr_t)dynseg) + (upx_uint64_t)sizeof(dynp0[-1]) ) <= sz_dynseg)) ) ? get_te64(&dynp0[-1+x_str].d_val) : (throwCantPack("bad PT_DYNAMIC (bad index)"),0) );
         unsigned const  z_sym = dt_table[Elf64_Dyn::DT_SYMENT];
         unsigned const sz_sym = !z_sym ? sizeof(Elf64_Sym)
-            : get_te64(&dynp0[-1+ z_sym].d_val);
+            : ((dt_table[z_sym] && (dynseg && ((((upx_uint64_t)(uintptr_t)(&dynp0[-1+z_sym]) - (upx_uint64_t)(uintptr_t)dynseg) + (upx_uint64_t)sizeof(dynp0[-1]) ) <= sz_dynseg)) ) ? get_te64(&dynp0[-1+z_sym].d_val) : (throwCantPack("bad PT_DYNAMIC (bad index)"),0) );
         if (sz_sym < sizeof(Elf64_Sym)) {
             char msg[50]; snprintf(msg, sizeof(msg),
                 "bad DT_SYMENT %x", sz_sym);
@@ -5139,7 +5166,7 @@ PackLinuxElf64::invert_pt_dynamic(Elf64_Dyn const *dynp)
         unsigned const *const buckets = &hashtab[2];
         unsigned const *const chains = &buckets[nbucket]; (void)chains;
 
-        unsigned const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);
+        unsigned const v_sym = ( (dt_table[x_sym] && (((upx_uint64_t)(uintptr_t)&dynp0[-1+ x_sym] - (upx_uint64_t)(uintptr_t)dynseg) < sz_dynseg)) ? ((dt_table[x_sym] && (dynseg && ((((upx_uint64_t)(uintptr_t)(&dynp0[-1+x_sym]) - (upx_uint64_t)(uintptr_t)dynseg) + (upx_uint64_t)sizeof(dynp0[-1]) ) <= sz_dynseg)) ) ? get_te32(&dynp0[-1+x_sym].d_val) : (throwCantPack("bad PT_DYNAMIC (bad index)"),0) ) : (throwCantPack("bad PT_DYNAMIC (bad index)"),0) );
         if (!nbucket
         || (nbucket>>31) || (file_size/sizeof(unsigned)) <= (2*nbucket)  // FIXME: weak
         || ((v_hsh < v_sym) && (v_sym - v_hsh) < (sizeof(unsigned)*2  // headers
@@ -5170,7 +5197,7 @@ PackLinuxElf64::invert_pt_dynamic(Elf64_Dyn const *dynp)
         unsigned     const *const hasharr = &buckets[n_bucket]; (void)hasharr;
       //unsigned     const *const gashend = &hasharr[n_bucket];  // minimum
 
-        upx_uint64_t const v_sym = get_te64(&dynp0[-1+ x_sym].d_val);
+        upx_uint64_t const v_sym = ( (dt_table[x_sym] && (((upx_uint64_t)(uintptr_t)&dynp0[-1+ x_sym] - (upx_uint64_t)(uintptr_t)dynseg) < sz_dynseg)) ? ((dt_table[x_sym] && (dynseg && ((((upx_uint64_t)(uintptr_t)(&dynp0[-1+x_sym]) - (upx_uint64_t)(uintptr_t)dynseg) + (upx_uint64_t)sizeof(dynp0[-1]) ) <= sz_dynseg)) ) ? get_te64(&dynp0[-1+x_sym].d_val) : (throwCantPack("bad PT_DYNAMIC (bad index)"),0) ) : (throwCantPack("bad PT_DYNAMIC (bad index)"),0) );
         if (!n_bucket || !n_bitmask
         || (-1+ n_bitmask) & n_bitmask  // not a power of 2
         || 8*sizeof(upx_uint64_t) <= gnu_shift  // shifted result always == 0
@@ -5204,7 +5231,7 @@ PackLinuxElf64::elf_find_dynamic(unsigned int key) const
 {
     Elf64_Dyn const *dynp= dynseg;
     if (dynp)
-    for (; (unsigned)((char const *)dynp - (char const *)dynseg) < sz_dynseg
+    for (; ((upx_uint64_t)(uintptr_t)dynp - (upx_uint64_t)(uintptr_t)dynseg) < sz_dynseg
             && Elf64_Dyn::DT_NULL!=dynp->d_tag; ++dynp) if (get_te64(&dynp->d_tag)==key) {
         upx_uint64_t const t= elf_get_offset_from_address(get_te64(&dynp->d_val));
         if (t && t < (upx_uint64_t)file_size) {
@@ -5220,7 +5247,7 @@ PackLinuxElf64::elf_unsigned_dynamic(unsigned int key) const
 {
     Elf64_Dyn const *dynp= dynseg;
     if (dynp)
-    for (; (unsigned)((char const *)dynp - (char const *)dynseg) < sz_dynseg
+    for (; ((upx_uint64_t)(uintptr_t)dynp - (upx_uint64_t)(uintptr_t)dynseg) < sz_dynseg
             && Elf64_Dyn::DT_NULL!=dynp->d_tag; ++dynp) if (get_te64(&dynp->d_tag)==key) {
         return get_te64(&dynp->d_val);
     }