diff --git a/ext/standard/var_unserializer.c b/ext/standard/var_unserializer.c
index 3fc074dd..86815de6 100644
--- a/ext/standard/var_unserializer.c
+++ b/ext/standard/var_unserializer.c
@@ -393,13 +393,22 @@ string_key:
 
 static inline int finish_nested_data(UNSERIALIZE_PARAMETER)
 {
-	if (*((*p)++) == '}')
-		return 1;
+    /* Make sure we don't read past the provided buffer before checking
+     * for the terminating '}' character. The previous code incremented
+     * the pointer and dereferenced it without verifying bounds which
+     * could lead to a buffer over-read when unserializing crafted input.
+     */
+    if ((*p) >= max) {
+        return 0;
+    }
 
-#if SOMETHING_NEW_MIGHT_LEAD_TO_CRASH_ENABLE_IF_YOU_ARE_BRAVE
-	zval_ptr_dtor(rval);
-#endif
-	return 0;
+    if (*(*p) == '}') {
+        /* consume the '}' and succeed */
+        (*p)++;
+        return 1;
+    }
+
+    return 0;
 }
 
 static inline int object_custom(UNSERIALIZE_PARAMETER, zend_class_entry *ce)
diff --git a/main/reentrancy.c b/main/reentrancy.c
index 72b744d6..2900f8a3 100644
--- a/main/reentrancy.c
+++ b/main/reentrancy.c
@@ -29,12 +29,12 @@
 #include "ext/standard/php_rand.h"                   /* for PHP_RAND_MAX */
 
 enum {
-	LOCALTIME_R,
-	CTIME_R,
-	ASCTIME_R,
-	GMTIME_R,
-	READDIR_R,
-	NUMBER_OF_LOCKS
+        LOCALTIME_R,
+        CTIME_R,
+        ASCTIME_R,
+        GMTIME_R,
+        READDIR_R,
+        NUMBER_OF_LOCKS
 };
 
 #if defined(PHP_NEED_REENTRANCY)
@@ -60,16 +60,16 @@ static MUTEX_T reentrant_locks[NUMBER_OF_LOCKS];
 
 PHPAPI char *php_ctime_r(const time_t *clock, char *buf)
 {
-	if (ctime_r(clock, buf) == buf)
-		return (buf);
-	return (NULL);
+        if (ctime_r(clock, buf) == buf)
+                return (buf);
+        return (NULL);
 }
 
 PHPAPI char *php_asctime_r(const struct tm *tm, char *buf)
 {
-	if (asctime_r(tm, buf) == buf)
-		return (buf);
-	return (NULL);
+        if (asctime_r(tm, buf) == buf)
+                return (buf);
+        return (NULL);
 }
 
 #endif
@@ -83,30 +83,30 @@ PHPAPI char *php_asctime_r(const struct tm *tm, char *buf)
 
 PHPAPI struct tm *php_localtime_r(const time_t *const timep, struct tm *p_tm)
 {
-	if (localtime_r(timep, p_tm) == 0)
-		return (p_tm);
-	return (NULL);
+        if (localtime_r(timep, p_tm) == 0)
+                return (p_tm);
+        return (NULL);
 }
 
 PHPAPI char *php_ctime_r(const time_t *clock, char *buf)
 {
-	if (ctime_r(clock, buf, 26) != -1)
-		return (buf);
-	return (NULL);
+        if (ctime_r(clock, buf, 26) != -1)
+                return (buf);
+        return (NULL);
 }
 
 PHPAPI char *php_asctime_r(const struct tm *tm, char *buf)
 {
-	if (asctime_r(tm, buf, 26) != -1)
-		return (buf);
-	return (NULL);
+        if (asctime_r(tm, buf, 26) != -1)
+                return (buf);
+        return (NULL);
 }
 
 PHPAPI struct tm *php_gmtime_r(const time_t *const timep, struct tm *p_tm)
 {
-	if (gmtime_r(timep, p_tm) == 0)
-		return (p_tm);
-	return (NULL);
+        if (gmtime_r(timep, p_tm) == 0)
+                return (p_tm);
+        return (NULL);
 }
 
 #endif
@@ -126,46 +126,51 @@ PHPAPI struct tm *php_gmtime_r(const time_t *const timep, struct tm *p_tm)
 #if !defined(HAVE_POSIX_READDIR_R)
 
 PHPAPI int php_readdir_r(DIR *dirp, struct dirent *entry,
-		struct dirent **result)
+                struct dirent **result)
 {
 #if defined(HAVE_OLD_READDIR_R)
-	int ret = 0;
-
-	/* We cannot rely on the return value of readdir_r
-	   as it differs between various platforms
-	   (HPUX returns 0 on success whereas Solaris returns non-zero)
-	 */
-	entry->d_name[0] = '\0';
-	readdir_r(dirp, entry);
-
-	if (entry->d_name[0] == '\0') {
-		*result = NULL;
-		ret = errno;
-	} else {
-		*result = entry;
-	}
-	return ret;
+        int ret = 0;
+
+        /* We cannot rely on the return value of readdir_r
+           as it differs between various platforms
+           (HPUX returns 0 on success whereas Solaris returns non-zero)
+         */
+        entry->d_name[0] = '\0';
+        struct dirent *entry_result = readdir(dirp);
+if (entry_result) {
+    memcpy(entry, entry_result, sizeof(struct dirent));
+} else {
+    return errno;
+}
+
+        if (entry->d_name[0] == '\0') {
+                *result = NULL;
+                ret = errno;
+        } else {
+                *result = entry;
+        }
+        return ret;
 #else
-	struct dirent *ptr;
-	int ret = 0;
+        struct dirent *ptr;
+        int ret = 0;
 
-	local_lock(READDIR_R);
+        local_lock(READDIR_R);
 
-	errno = 0;
+        errno = 0;
 
-	ptr = readdir(dirp);
+        ptr = readdir(dirp);
 
-	if (!ptr && errno != 0)
-		ret = errno;
+        if (!ptr && errno != 0)
+                ret = errno;
 
-	if (ptr)
-		memcpy(entry, ptr, sizeof(*ptr));
+        if (ptr)
+                memcpy(entry, ptr, sizeof(*ptr));
 
-	*result = ptr;
+        *result = ptr;
 
-	local_unlock(READDIR_R);
+        local_unlock(READDIR_R);
 
-	return ret;
+        return ret;
 #endif
 }
 
@@ -175,19 +180,19 @@ PHPAPI int php_readdir_r(DIR *dirp, struct dirent *entry,
 
 PHPAPI struct tm *php_localtime_r(const time_t *const timep, struct tm *p_tm)
 {
-	struct tm *tmp;
+        struct tm *tmp;
 
-	local_lock(LOCALTIME_R);
+        local_lock(LOCALTIME_R);
 
-	tmp = localtime(timep);
-	if (tmp) {
-		memcpy(p_tm, tmp, sizeof(struct tm));
-		tmp = p_tm;
-	}
+        tmp = localtime(timep);
+        if (tmp) {
+                memcpy(p_tm, tmp, sizeof(struct tm));
+                tmp = p_tm;
+        }
 
-	local_unlock(LOCALTIME_R);
+        local_unlock(LOCALTIME_R);
 
-	return tmp;
+        return tmp;
 }
 
 #endif
@@ -196,16 +201,16 @@ PHPAPI struct tm *php_localtime_r(const time_t *const timep, struct tm *p_tm)
 
 PHPAPI char *php_ctime_r(const time_t *clock, char *buf)
 {
-	char *tmp;
+        char *tmp;
 
-	local_lock(CTIME_R);
+        local_lock(CTIME_R);
 
-	tmp = ctime(clock);
-	strcpy(buf, tmp);
+        tmp = ctime(clock);
+        strcpy(buf, tmp);
 
-	local_unlock(CTIME_R);
+        local_unlock(CTIME_R);
 
-	return buf;
+        return buf;
 }
 
 #endif
@@ -214,16 +219,16 @@ PHPAPI char *php_ctime_r(const time_t *clock, char *buf)
 
 PHPAPI char *php_asctime_r(const struct tm *tm, char *buf)
 {
-	char *tmp;
+        char *tmp;
 
-	local_lock(ASCTIME_R);
+        local_lock(ASCTIME_R);
 
-	tmp = asctime(tm);
-	strcpy(buf, tmp);
+        tmp = asctime(tm);
+        strcpy(buf, tmp);
 
-	local_unlock(ASCTIME_R);
+        local_unlock(ASCTIME_R);
 
-	return buf;
+        return buf;
 }
 
 #endif
@@ -232,19 +237,19 @@ PHPAPI char *php_asctime_r(const struct tm *tm, char *buf)
 
 PHPAPI struct tm *php_gmtime_r(const time_t *const timep, struct tm *p_tm)
 {
-	struct tm *tmp;
+        struct tm *tmp;
 
-	local_lock(GMTIME_R);
+        local_lock(GMTIME_R);
 
-	tmp = gmtime(timep);
-	if (tmp) {
-		memcpy(p_tm, tmp, sizeof(struct tm));
-		tmp = p_tm;
-	}
+        tmp = gmtime(timep);
+        if (tmp) {
+                memcpy(p_tm, tmp, sizeof(struct tm));
+                tmp = p_tm;
+        }
 
-	local_unlock(GMTIME_R);
+        local_unlock(GMTIME_R);
 
-	return tmp;
+        return tmp;
 }
 
 #endif
@@ -253,20 +258,20 @@ PHPAPI struct tm *php_gmtime_r(const time_t *const timep, struct tm *p_tm)
 
 void reentrancy_startup(void)
 {
-	int i;
+        int i;
 
-	for (i = 0; i < NUMBER_OF_LOCKS; i++) {
-		reentrant_locks[i] = tsrm_mutex_alloc();
-	}
+        for (i = 0; i < NUMBER_OF_LOCKS; i++) {
+                reentrant_locks[i] = tsrm_mutex_alloc();
+        }
 }
 
 void reentrancy_shutdown(void)
 {
-	int i;
+        int i;
 
-	for (i = 0; i < NUMBER_OF_LOCKS; i++) {
-		tsrm_mutex_free(reentrant_locks[i]);
-	}
+        for (i = 0; i < NUMBER_OF_LOCKS; i++) {
+                tsrm_mutex_free(reentrant_locks[i]);
+        }
 }
 
 #endif
@@ -275,7 +280,7 @@ void reentrancy_shutdown(void)
 
 /*-
  * Copyright (c) 1990, 1993
- *	The Regents of the University of California.  All rights reserved.
+ *      The Regents of the University of California.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -287,8 +292,8 @@ void reentrancy_shutdown(void)
  *    documentation and/or other materials provided with the distribution.
  * 3. All advertising materials mentioning features or use of this software
  *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
+ *      This product includes software developed by the University of
+ *      California, Berkeley and its contributors.
  * 4. Neither the name of the University nor the names of its contributors
  *    may be used to endorse or promote products derived from this software
  *    without specific prior written permission.
@@ -314,16 +319,16 @@ void reentrancy_shutdown(void)
 static int
 do_rand(unsigned long *ctx)
 {
-	return ((*ctx = *ctx * 1103515245 + 12345) % ((u_long)PHP_RAND_MAX + 1));
+        return ((*ctx = *ctx * 1103515245 + 12345) % ((u_long)PHP_RAND_MAX + 1));
 }
 
 
 PHPAPI int
 php_rand_r(unsigned int *ctx)
 {
-	u_long val = (u_long) *ctx;
-	*ctx = do_rand(&val);
-	return (int) *ctx;
+        u_long val = (u_long) *ctx;
+        *ctx = do_rand(&val);
+        return (int) *ctx;
 }
 
 #endif
@@ -338,7 +343,7 @@ php_rand_r(unsigned int *ctx)
  * Oct 13, 1998 by Wes Peters <wes@softweyr.com>
  *
  * Copyright (c) 1988, 1993
- *	The Regents of the University of California.  All rights reserved.
+ *      The Regents of the University of California.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -354,7 +359,7 @@ php_rand_r(unsigned int *ctx)
  * 3. All advertising materials mentioning features or use of this software
  *    must display the following acknowledgement:
  *
- *	This product includes software developed by Softweyr LLC, the
+ *      This product includes software developed by Softweyr LLC, the
  *      University of California, Berkeley, and its contributors.
  *
  * 4. Neither the name of the University nor the names of its contributors
@@ -385,7 +390,7 @@ php_strtok_r(char *s, const char *delim, char **last)
 
     if (s == NULL && (s = *last) == NULL)
     {
-	return NULL;
+        return NULL;
     }
 
     /*
@@ -395,16 +400,16 @@ cont:
     c = *s++;
     for (spanp = (char *)delim; (sc = *spanp++) != 0; )
     {
-	if (c == sc)
-	{
-	    goto cont;
-	}
+        if (c == sc)
+        {
+            goto cont;
+        }
     }
 
-    if (c == 0)		/* no non-delimiter characters */
+    if (c == 0)         /* no non-delimiter characters */
     {
-	*last = NULL;
-	return NULL;
+        *last = NULL;
+        return NULL;
     }
     tok = s - 1;
 
@@ -414,26 +419,26 @@ cont:
      */
     for (;;)
     {
-	c = *s++;
-	spanp = (char *)delim;
-	do
-	{
-	    if ((sc = *spanp++) == c)
-	    {
-		if (c == 0)
-		{
-		    s = NULL;
-		}
-		else
-		{
-		    char *w = s - 1;
-		    *w = '\0';
-		}
-		*last = s;
-		return tok;
-	    }
-	}
-	while (sc != 0);
+        c = *s++;
+        spanp = (char *)delim;
+        do
+        {
+            if ((sc = *spanp++) == c)
+            {
+                if (c == 0)
+                {
+                    s = NULL;
+                }
+                else
+                {
+                    char *w = s - 1;
+                    *w = '\0';
+                }
+                *last = s;
+                return tok;
+            }
+        }
+        while (sc != 0);
     }
     /* NOTREACHED */
 }