diff --git a/src/array.c b/src/array.c
index 07ceefb..7ded079 100644
--- a/src/array.c
+++ b/src/array.c
@@ -30,6 +30,11 @@ ary_new_capa(mrb_state *mrb, mrb_int capa)
   blen = capa * sizeof(mrb_value);
 
   a = MRB_OBJ_ALLOC(mrb, MRB_TT_ARRAY, mrb->array_class);
+  /* initialize heap fields to safe defaults to avoid uninitialized
+     pointer dereference when embedded-array support is disabled */
+  a->as.heap.ptr = NULL;
+  a->as.heap.aux.capa = 0;
+  a->as.heap.len = 0;
   if (capa <= MRB_ARY_EMBED_LEN_MAX) {
     ARY_SET_EMBED_LEN(a, 0);
   }
@@ -499,12 +504,31 @@ mrb_ary_reverse(mrb_state *mrb, mrb_value self)
 MRB_API void
 mrb_ary_push(mrb_state *mrb, mrb_value ary, mrb_value elem)
 {
+  /* Guard against being called with a non-array value to avoid
+     dereferencing invalid pointers which can lead to crashes. */
+  if (!mrb_array_p(ary)) {
+    mrb_raise(mrb, E_TYPE_ERROR, "not an Array");
+  }
   struct RArray *a = mrb_ary_ptr(ary);
   mrb_int len = ARY_LEN(a);
 
   ary_modify(mrb, a);
-  if (len == ARY_CAPA(a))
+  /* Validate length to avoid OOB and handle corrupted len values. */
+  if (len < 0 || len > ARY_MAX_SIZE) {
+    mrb_raise(mrb, E_ARGUMENT_ERROR, "array length corrupted");
+  }
+  if (len >= ARY_CAPA(a))
+    ary_expand_capa(mrb, a, len + 1);
+  /* Ensure the array pointer is valid. If allocation unexpectedly did not occur,
+     attempt to expand the capacity again and signal an error if it still fails.
+     This prevents dereferencing a NULL pointer which triggered an out-of-bounds
+     read in some configurations. */
+  if (ARY_PTR(a) == NULL) {
     ary_expand_capa(mrb, a, len + 1);
+    if (ARY_PTR(a) == NULL) {
+      mrb_raise(mrb, E_RUNTIME_ERROR, "internal array allocation failed");
+    }
+  }
   ARY_PTR(a)[len] = elem;
   ARY_SET_LEN(a, len+1);
   mrb_field_write_barrier_value(mrb, (struct RBasic*)a, elem);
diff --git a/src/gc.c b/src/gc.c
index a6ff0c5..d535ad0 100644
--- a/src/gc.c
+++ b/src/gc.c
@@ -533,7 +533,7 @@ MRB_API struct RBasic*
 mrb_obj_alloc(mrb_state *mrb, enum mrb_vtype ttype, struct RClass *cls)
 {
   struct RBasic *p;
-  static const RVALUE RVALUE_zero = { { { NULL, NULL, MRB_TT_FALSE } } };
+  static const RVALUE RVALUE_zero = { 0 };
   mrb_gc *gc = &mrb->gc;
 
   if (cls) {
@@ -582,6 +582,16 @@ mrb_obj_alloc(mrb_state *mrb, enum mrb_vtype ttype, struct RClass *cls)
   *(RVALUE *)p = RVALUE_zero;
   p->tt = ttype;
   p->c = cls;
+  /* Initialize type-specific union fields to safe defaults to avoid
+     uninitialized pointer dereferences when object memory contains
+     leftover bytes. This is important for types like Array where
+     later operations expect heap.ptr to be NULL or valid. */
+  if (ttype == MRB_TT_ARRAY) {
+    struct RArray *a = (struct RArray*)p;
+    a->as.heap.ptr = NULL;
+    a->as.heap.aux.capa = 0;
+    a->as.heap.len = 0;
+  }
   paint_partial_white(gc, p);
   return p;
 }