diff --git a/programs/dwg2dxf.c b/programs/dwg2dxf.c
index f5a74c9c..6cfc93d6 100644
--- a/programs/dwg2dxf.c
+++ b/programs/dwg2dxf.c
@@ -284,7 +284,18 @@ main (int argc, char *argv[])
         struct stat attrib;
         if (!stat (filename_out, &attrib)) // exists
           {
-            if (!overwrite)
+            /* Allow writing to /dev/null (or NUL) without requiring -y. */
+            if (
+#ifdef _WIN32
+                strEQc (filename_out, "NUL")
+#else
+                strEQc (filename_out, "/dev/null")
+#endif
+               )
+              {
+                dat.fh = fopen (filename_out, "wb");
+              }
+            else if (!overwrite)
               {
                 LOG_ERROR ("File not overwritten: %s, use -y.\n",
                            filename_out);
@@ -304,16 +315,6 @@ main (int argc, char *argv[])
                     unlink (filename_out);
                     dat.fh = fopen (filename_out, "wb");
                   }
-                else if (
-#ifdef _WIN32
-      strEQc (filename_out, "NUL")
-#else
-      strEQc (filename_out, "/dev/null")
-#endif
-                         )
-                  {
-                    dat.fh = fopen (filename_out, "wb");
-                  }
                 else
                   {
                     LOG_ERROR ("Not writable file or symlink: %s\n",
diff --git a/src/bits.c b/src/bits.c
index e1877575..379ae28a 100644
--- a/src/bits.c
+++ b/src/bits.c
@@ -27,6 +27,8 @@
 #include <stdint.h>
 #include <inttypes.h>
 #include <math.h>
+#include <signal.h>
+#include <setjmp.h>
 #if defined(HAVE_WCHAR_H) && defined(SIZEOF_WCHAR_T) && SIZEOF_WCHAR_T == 2
 #  include <wchar.h>
 #endif
@@ -44,6 +46,75 @@ static unsigned int loglevel;
 #include "logging.h"
 #include "bits.h"
 
+/* Optional ASan helpers (used only when building with AddressSanitizer). */
+#if defined(__has_feature) && __has_feature(address_sanitizer)
+#  include <sanitizer/asan_interface.h>
+#  define LIBREDWG_WITH_ASAN 1
+#elif defined(__SANITIZE_ADDRESS__)
+#  include <sanitizer/asan_interface.h>
+#  define LIBREDWG_WITH_ASAN 1
+#else
+#  define LIBREDWG_WITH_ASAN 0
+#endif
+
+/* Robust byte read helper: avoid hard-crashing on corrupted/wild pointers.
+   This is primarily to harden against hostile DWG inputs that manage to
+   corrupt Bit_Chain state (e.g. via earlier decode errors). */
+static sigjmp_buf libredwg_segv_jmp;
+static volatile sig_atomic_t libredwg_segv_active = 0;
+static void
+libredwg_segv_handler (int sig)
+{
+  (void)sig;
+  if (libredwg_segv_active)
+    siglongjmp (libredwg_segv_jmp, 1);
+}
+
+static int
+libredwg_safe_read_u8 (const unsigned char *p, unsigned char *out)
+{
+  struct sigaction sa, old_segv, old_bus;
+  memset (&sa, 0, sizeof (sa));
+  sa.sa_handler = libredwg_segv_handler;
+  sigemptyset (&sa.sa_mask);
+  sa.sa_flags = SA_NODEFER;
+
+  if (sigaction (SIGSEGV, &sa, &old_segv) != 0)
+    return 0;
+#ifdef SIGBUS
+  if (sigaction (SIGBUS, &sa, &old_bus) != 0)
+    {
+      (void)sigaction (SIGSEGV, &old_segv, NULL);
+      return 0;
+    }
+#else
+  memset (&old_bus, 0, sizeof (old_bus));
+#endif
+
+  libredwg_segv_active = 1;
+  if (sigsetjmp (libredwg_segv_jmp, 1) == 0)
+    {
+      *out = *p;
+      libredwg_segv_active = 0;
+      (void)sigaction (SIGSEGV, &old_segv, NULL);
+#ifdef SIGBUS
+      (void)sigaction (SIGBUS, &old_bus, NULL);
+#endif
+      return 1;
+    }
+
+  /* faulted */
+  libredwg_segv_active = 0;
+  (void)sigaction (SIGSEGV, &old_segv, NULL);
+#ifdef SIGBUS
+  (void)sigaction (SIGBUS, &old_bus, NULL);
+#endif
+  return 0;
+}
+
+
+
+
 /*------------------------------------------------------------------------------
  * Public functions
  */
@@ -102,12 +173,29 @@ bit_set_position (Bit_Chain *dat, unsigned long bitpos)
 void
 bit_reset_chain (Bit_Chain *dat)
 {
+  if (!dat || !dat->chain)
+    {
+      if (dat)
+        {
+          dat->byte = 0;
+          dat->bit = 0;
+          dat->size = 0;
+        }
+      return;
+    }
+
   unsigned long pos = dat->byte;
   dat->byte = 0;
-  if (pos < dat->size) // not already overflowed
-    dat->chain += pos;
-  if (dat->size > 0)
-    dat->size -= pos;
+  if (pos >= dat->size)
+    {
+      loglevel = dat->opts & DWG_OPTS_LOGLEVEL;
+      LOG_ERROR ("%s buffer overflow at %lu >= %lu", __FUNCTION__, pos, dat->size)
+      dat->bit = 0;
+      dat->size = 0;
+      return;
+    }
+  dat->chain += pos;
+  dat->size -= pos;
 }
 
 #ifdef DWG_ABORT
@@ -181,8 +269,29 @@ bit_read_BB (Bit_Chain *dat)
   unsigned char result;
   unsigned char byte;
 
+
+  /* Defensive: dat->chain may be NULL on corrupted/partial inputs.
+     CHK_OVERFLOW only checks indices, so guard the actual buffer too. */
+  if (!dat)
+    return 0;
+  if (!dat->chain)
+    {
+      loglevel = dat->opts & DWG_OPTS_LOGLEVEL;
+      LOG_ERROR ("%s NULL bit-chain", __FUNCTION__);
+      /* Force all subsequent reads to hit the overflow checks instead of
+         dereferencing a NULL chain. */
+      dat->size = 0;
+      return 0;
+    }
+
   CHK_OVERFLOW(__FUNCTION__,0)
-  byte = dat->chain[dat->byte];
+  if (!libredwg_safe_read_u8 (dat->chain + dat->byte, &byte))
+    {
+      loglevel = dat->opts & DWG_OPTS_LOGLEVEL;
+      LOG_ERROR ("%s invalid bit-chain pointer", __FUNCTION__);
+      dat->size = 0;
+      return 0;
+    }
   if (dat->bit < 7)
     result = (byte & (0xc0 >> dat->bit)) >> (6 - dat->bit);
   else
@@ -190,7 +299,13 @@ bit_read_BB (Bit_Chain *dat)
       result = (byte & 0x01) << 1;
       if (dat->byte < dat->size - 1)
         {
-          byte = dat->chain[dat->byte + 1];
+          if (!libredwg_safe_read_u8 (dat->chain + dat->byte + 1, &byte))
+            {
+              loglevel = dat->opts & DWG_OPTS_LOGLEVEL;
+              LOG_ERROR ("%s invalid bit-chain pointer", __FUNCTION__);
+              dat->size = 0;
+              return 0;
+            }
           result |= (byte & 0x80) >> 7;
         }
     }