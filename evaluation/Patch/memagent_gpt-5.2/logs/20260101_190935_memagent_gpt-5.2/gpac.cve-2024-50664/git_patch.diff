diff --git a/src/isomedia/sample_descs.c b/src/isomedia/sample_descs.c
index 8c1807518..bc7e674d6 100644
--- a/src/isomedia/sample_descs.c
+++ b/src/isomedia/sample_descs.c
@@ -1786,17 +1786,32 @@ GF_Err gf_isom_new_mpha_description(GF_ISOFile *movie, u32 trackNumber, const ch
 	if (outDescriptionIndex) *outDescriptionIndex = gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);
 
 	if (dsi) {
+		u32 payload_len;
 		mpa->cfg_mha = (GF_MHAConfigBox *) gf_isom_box_new_parent(&mpa->child_boxes, GF_ISOM_BOX_TYPE_MHAC);
 		if (!mpa->cfg_mha) return GF_OUT_OF_MEM;
+		/*
+			The MHAC DSI format stores a 16-bit configuration size at bytes 3-4.
+			The previous code allocated using this size but copied (dsi_size-5)
+			bytes, which can overflow when these two lengths disagree.
+		*/
+		if (dsi_size < 5) return GF_BAD_PARAM;
+		payload_len = dsi_size - 5;
 		mpa->cfg_mha->configuration_version = dsi[0];
 		mpa->cfg_mha->mha_pl_indication = dsi[1];
 		mpa->cfg_mha->reference_channel_layout = dsi[2];
 		mpa->cfg_mha->mha_config_size = dsi[3];
 		mpa->cfg_mha->mha_config_size <<= 8;
 		mpa->cfg_mha->mha_config_size |= dsi[4];
-		mpa->cfg_mha->mha_config = gf_malloc(sizeof(u8) * mpa->cfg_mha->mha_config_size);
-		if (!mpa->cfg_mha->mha_config) return GF_OUT_OF_MEM;
-		memcpy(mpa->cfg_mha->mha_config, dsi+5, dsi_size-5);
+		/* Reject non-compliant bitstreams to avoid heap overflows */
+		if (mpa->cfg_mha->mha_config_size > payload_len)
+			return GF_NON_COMPLIANT_BITSTREAM;
+		if (mpa->cfg_mha->mha_config_size) {
+			mpa->cfg_mha->mha_config = gf_malloc(sizeof(u8) * mpa->cfg_mha->mha_config_size);
+			if (!mpa->cfg_mha->mha_config) return GF_OUT_OF_MEM;
+			memcpy(mpa->cfg_mha->mha_config, dsi+5, mpa->cfg_mha->mha_config_size);
+		} else {
+			mpa->cfg_mha->mha_config = NULL;
+		}
 	}
 	return GF_OK;
 }