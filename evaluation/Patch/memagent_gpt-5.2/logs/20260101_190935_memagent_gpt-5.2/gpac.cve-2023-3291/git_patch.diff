diff --git a/modules/dektec_out/dektec_video_decl.c b/modules/dektec_out/dektec_video_decl.c
index fea32e5a1..274927242 100644
--- a/modules/dektec_out/dektec_video_decl.c
+++ b/modules/dektec_out/dektec_video_decl.c
@@ -62,7 +62,7 @@ GF_FilterRegister DTOutRegister;
 GPAC_MODULE_EXPORT
 GF_FilterRegister *RegisterFilter(GF_FilterSession *session)
 #else
-GF_FilterRegister *dtout_register(GF_FilterSession *session)
+const GF_FilterRegister *dtout_register(GF_FilterSession *session)
 #endif
 {
 	memset(DTOutCaps, 0, sizeof(DTOutCaps));
diff --git a/src/filter_core/filter_pck.c b/src/filter_core/filter_pck.c
index 917e3ab4a..bfdad2b11 100644
--- a/src/filter_core/filter_pck.c
+++ b/src/filter_core/filter_pck.c
@@ -1626,8 +1626,8 @@ GF_EXPORT
 GF_Err gf_filter_pck_set_sap(GF_FilterPacket *pck, GF_FilterSAPType sap_type)
 {
 	PCK_SETTER_CHECK("SAP")
-	pck->info.flags &= ~GF_PCK_SAP_MASK;
-	pck->info.flags |= (sap_type)<<GF_PCK_SAP_POS;
+	pck->info.flags &= (u32) (~(u32)GF_PCK_SAP_MASK);
+	pck->info.flags |= ((u32)sap_type)<<GF_PCK_SAP_POS;
 
 	return GF_OK;
 }
diff --git a/src/filter_core/filter_pid.c b/src/filter_core/filter_pid.c
index ba73c59c3..bf53a5b6a 100644
--- a/src/filter_core/filter_pid.c
+++ b/src/filter_core/filter_pid.c
@@ -3152,7 +3152,7 @@ static void gf_filter_pid_resolve_link_dijkstra(GF_FilterPid *pid, GF_Filter *ds
 		reg_desc->cap_idx = 0;
 		reg_desc->in_edges_enabling = 0;
 		//set node distance and priority to infinity, whether we are in the final dijsktra set or not
-		reg_desc->dist = -1;
+			reg_desc->dist = 0xFFFFFFFFu;
 		reg_desc->priority = 0xFF;
 
 		//remember our source descriptor - it may be absent of the final node set in case we want reconfigurable only filters
diff --git a/src/filters/reframe_h263.c b/src/filters/reframe_h263.c
index 4b9da7ed2..156a4b619 100644
--- a/src/filters/reframe_h263.c
+++ b/src/filters/reframe_h263.c
@@ -347,7 +347,7 @@ static s32 h263dmx_next_start_code(u8 *data, u32 size)
 	v = 0xffffffff;
 	while (!end) {
 		if (bpos == size) return -1;
-		v = (v<<8) | data[bpos];
+			v = (u32)((v << 8) | data[bpos]);
 		bpos++;
 		if ((v >> (32-22)) == 0x20) end = start + bpos - 4;
 	}
diff --git a/src/filters/reframe_mp3.c b/src/filters/reframe_mp3.c
index e81dd174a..ed56c63e0 100644
--- a/src/filters/reframe_mp3.c
+++ b/src/filters/reframe_mp3.c
@@ -265,9 +265,28 @@ void id3dmx_flush(GF_Filter *filter, u8 *id3_buf, u32 id3_buf_size, GF_FilterPid
 			break;
 		}
 
-		if (buf_alloc<=fsize) {
-			_buf = gf_realloc(_buf, fsize+3);
-			buf_alloc = fsize+3;
+		/*
+			We read frame payload at _buf+1 and then write two NUL bytes at
+			offsets fsize+1 and fsize+2. Therefore we need at least
+			fsize+3 bytes allocated in _buf.
+			The previous check (buf_alloc<=fsize) could skip realloc when
+			buf_alloc was in (fsize, fsize+2], causing a heap OOB write.
+		*/
+		{
+			u32 needed = fsize + 3;
+			if (needed < fsize) {
+				GF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, ("[MP3Dmx] Broken ID3 frame tag %s, invalid size %u\n", gf_4cc_to_str(ftag), fsize));
+				break;
+			}
+			if (buf_alloc < needed) {
+				char *tmp = gf_realloc(_buf, needed);
+				if (!tmp) {
+					GF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, ("[MP3Dmx] Failed to allocate %u bytes for ID3 frame %s\n", needed, gf_4cc_to_str(ftag) ));
+					break;
+				}
+				_buf = tmp;
+				buf_alloc = needed;
+			}
 		}
 		//read into _buf+1 so that buf+1 is always %2 mem aligned as it can be loaded as unsigned short
 		gf_bs_read_data(bs, _buf+1, fsize);