diff --git a/src/mat5.c b/src/mat5.c
index 2841b58..d7745e7 100644
--- a/src/mat5.c
+++ b/src/mat5.c
@@ -30,6 +30,7 @@
 
 /* FIXME: Implement Unicode support */
 #include <stddef.h>
+#include <stdint.h>
 #include <stdlib.h>
 #include <string.h>
 #include <stdio.h>
@@ -1824,10 +1825,44 @@ ReadNextFunctionHandle(mat_t *mat, matvar_t *matvar)
     int j;
     size_t bytesread = 0, nfunctions = 1;
 
-    for ( j = 0; j < matvar->rank; j++ )
-        nfunctions *= matvar->dims[j];
+    /*
+     * nfunctions is derived from attacker-controlled dimensions from the file.
+     * Protect against integer overflow in the product and in the allocation
+     * size computation to avoid undersized allocations leading to OOB writes.
+     */
+    for ( j = 0; j < matvar->rank; j++ ) {
+        size_t d = matvar->dims[j];
+        if ( d == 0 ) {
+            nfunctions = 0;
+            break;
+        }
+        if ( nfunctions > SIZE_MAX / d ) {
+            Mat_Critical("Integer overflow computing function-handle element count");
+            matvar->data = NULL;
+            matvar->data_size = 0;
+            matvar->nbytes = 0;
+            return 0;
+        }
+        nfunctions *= d;
+    }
+
+    if ( nfunctions == 0 ) {
+        /* Empty function handle array */
+        matvar->data = NULL;
+        matvar->data_size = 0;
+        matvar->nbytes = 0;
+        return 0;
+    }
+
+    if ( nfunctions > SIZE_MAX / sizeof(matvar_t *) ) {
+        Mat_Critical("Integer overflow computing function-handle allocation size");
+        matvar->data = NULL;
+        matvar->data_size = 0;
+        matvar->nbytes = 0;
+        return 0;
+    }
 
-    matvar->data = malloc(nfunctions*sizeof(matvar_t *));
+    matvar->data = malloc(nfunctions * sizeof(matvar_t *));
     if ( matvar->data != NULL ) {
         size_t i;
         matvar_t **functions = (matvar_t**)matvar->data;;