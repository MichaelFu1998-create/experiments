diff --git a/programs/escape.c b/programs/escape.c
index 8a907414..79c95d40 100644
--- a/programs/escape.c
+++ b/programs/escape.c
@@ -6,6 +6,7 @@
 /*  This library is free software, licensed under the terms of the GNU       */
 /*  General Public License as published by the Free Software Foundation,     */
 /*  either version 3 of the License, or (at your option) any later version.  */
+/*                                                                           */
 /*  You should have received a copy of the GNU General Public License        */
 /*  along with this program.  If not, see <http://www.gnu.org/licenses/>.    */
 /*****************************************************************************/
@@ -23,47 +24,129 @@
 #include "common.h"
 #include "escape.h"
 
+/* Ensure that DEST has enough capacity for appending EXTRA bytes at D.
+   Keeps D pointing into DEST across reallocations.
+   Returns 1 on success, 0 on OOM (and frees DEST). */
+static int
+ensure_cap (char **destp, char **dp, int *lenp, const int extra)
+{
+  const int off = (int)(*dp - *destp);
+  /* +1 for trailing NUL */
+  if (off + extra + 1 < *lenp)
+    return 1;
+
+  int newlen = *lenp;
+  const int need = off + extra + 1;
+  while (newlen < need)
+    newlen += 64;
+
+  char *newdest = realloc (*destp, newlen);
+  if (!newdest)
+    {
+      free (*destp);
+      *destp = NULL;
+      *dp = NULL;
+      *lenp = 0;
+      return 0;
+    }
+  *destp = newdest;
+  *dp = newdest + off;
+  *lenp = newlen;
+  return 1;
+}
+
 char * ATTRIBUTE_MALLOC
 htmlescape (const char *restrict src, const int cp)
 {
   int len;
   char *dest, *d;
-  unsigned char *s;
+  const unsigned char *s;
+
+  (void)cp;
   if (!src)
     return NULL;
-  len = strlen (src) + 10;
+
+  len = (int)strlen (src) + 10;
   d = malloc (len);
-  s = (unsigned char *)src;
+  if (!d)
+    return NULL;
+
+  s = (const unsigned char *)src;
   dest = d;
-  while (*s++)
+
+  while (*s)
     {
-      const int off = d - dest;
-      if (off >= len - 8)
+      const unsigned char c = *s++;
+      switch (c)
         {
-          len += 10;
-          dest = realloc (dest, len);
-          d = dest + off;
-        }
-      switch (*s)
-        {
-        case '"': strcat (d, "&quot;"); d += 6; break;
-        case '\'': strcat (d, "&#39;"); d += 5; break;
-        case '`': strcat (d, "&#96;"); d += 5; break;
-        case '&': strcat (d, "&amp;"); d += 5; break;
-        case '<': strcat (d, "&lt;"); d += 4; break;
-        case '>': strcat (d, "&gt;"); d += 4; break;
-        case '{': strcat (d, "&#123;"); d += 6; break;
-        case '}': strcat (d, "&#125;"); d += 6; break;
+        case '"':
+          if (!ensure_cap (&dest, &d, &len, 6))
+            return NULL;
+          memcpy (d, "&quot;", 6);
+          d += 6;
+          break;
+        case '\'':
+          if (!ensure_cap (&dest, &d, &len, 5))
+            return NULL;
+          memcpy (d, "&#39;", 5);
+          d += 5;
+          break;
+        case '`':
+          if (!ensure_cap (&dest, &d, &len, 5))
+            return NULL;
+          memcpy (d, "&#96;", 5);
+          d += 5;
+          break;
+        case '&':
+          if (!ensure_cap (&dest, &d, &len, 5))
+            return NULL;
+          memcpy (d, "&amp;", 5);
+          d += 5;
+          break;
+        case '<':
+          if (!ensure_cap (&dest, &d, &len, 4))
+            return NULL;
+          memcpy (d, "&lt;", 4);
+          d += 4;
+          break;
+        case '>':
+          if (!ensure_cap (&dest, &d, &len, 4))
+            return NULL;
+          memcpy (d, "&gt;", 4);
+          d += 4;
+          break;
+        case '{':
+          if (!ensure_cap (&dest, &d, &len, 6))
+            return NULL;
+          memcpy (d, "&#123;", 6);
+          d += 6;
+          break;
+        case '}':
+          if (!ensure_cap (&dest, &d, &len, 6))
+            return NULL;
+          memcpy (d, "&#125;", 6);
+          d += 6;
+          break;
         default:
-          if (*s >= 127) // maybe encodings, no utf8 (see htmlwescape)
+          if (c >= 127) /* maybe encodings, no utf8 (see htmlwescape) */
+            {
+              /* "&#x%X;" for a byte is short, but keep room to be safe. */
+              if (!ensure_cap (&dest, &d, &len, 12))
+                return NULL;
+              const int off = (int)(d - dest);
+              const int n = snprintf (d, (size_t)(len - off), "&#x%X;", c);
+              if (n > 0)
+                d += n;
+            }
+          else if (c >= 20)
             {
-              sprintf (d, "&#x%X;", *s); // 4 + 4
-              d += strlen (d);
+              if (!ensure_cap (&dest, &d, &len, 1))
+                return NULL;
+              *d++ = (char)c;
             }
-          else if (*s >= 20)
-            *d++ = *s;
         }
     }
+
   *d = 0;
   return dest;
 }
@@ -78,40 +161,87 @@ htmlwescape (BITCODE_TU wstr)
 
   if (!wstr)
     return NULL;
+
   while ((c = *tmp++))
     len++;
   len += 16;
   d = dest = malloc (len);
+  if (!dest)
+    return NULL;
 
-  while (*wstr++)
+  while (*wstr)
     {
-      const int off = d - dest;
-      if (off >= len - 8)
-        {
-          len += 16;
-          dest = realloc (dest, len);
-          d = dest + off;
-        }
-      switch (*wstr)
+      c = *wstr++;
+      switch (c)
         {
-        case 34: strcat (d, "&quot;"); d += 6; break;
-        case 39: strcat (d, "&#39;"); d += 5; break;
-        case 38: strcat (d, "&amp;"); d += 5; break;
-        case 60: strcat (d, "&lt;"); d += 4; break;
-        case 62: strcat (d, "&gt;"); d += 4; break;
-        case 96: strcat (d, "&#96;"); d += 5; break;
-        case 123: strcat (d, "&#123;"); d += 6; break;
-        case 125: strcat (d, "&#125;"); d += 6; break;
+        case 34:
+          if (!ensure_cap (&dest, &d, &len, 6))
+            return NULL;
+          memcpy (d, "&quot;", 6);
+          d += 6;
+          break;
+        case 39:
+          if (!ensure_cap (&dest, &d, &len, 5))
+            return NULL;
+          memcpy (d, "&#39;", 5);
+          d += 5;
+          break;
+        case 38:
+          if (!ensure_cap (&dest, &d, &len, 5))
+            return NULL;
+          memcpy (d, "&amp;", 5);
+          d += 5;
+          break;
+        case 60:
+          if (!ensure_cap (&dest, &d, &len, 4))
+            return NULL;
+          memcpy (d, "&lt;", 4);
+          d += 4;
+          break;
+        case 62:
+          if (!ensure_cap (&dest, &d, &len, 4))
+            return NULL;
+          memcpy (d, "&gt;", 4);
+          d += 4;
+          break;
+        case 96:
+          if (!ensure_cap (&dest, &d, &len, 5))
+            return NULL;
+          memcpy (d, "&#96;", 5);
+          d += 5;
+          break;
+        case 123:
+          if (!ensure_cap (&dest, &d, &len, 6))
+            return NULL;
+          memcpy (d, "&#123;", 6);
+          d += 6;
+          break;
+        case 125:
+          if (!ensure_cap (&dest, &d, &len, 6))
+            return NULL;
+          memcpy (d, "&#125;", 6);
+          d += 6;
+          break;
         default:
-          if (*wstr >= 127) // utf8 encodings
+          if (c >= 127) /* utf8 encodings */
             {
-              sprintf (d, "&#x%X;", *wstr);
-              d += strlen (d);
+              if (!ensure_cap (&dest, &d, &len, 16))
+                return NULL;
+              const int off = (int)(d - dest);
+              const int n = snprintf (d, (size_t)(len - off), "&#x%X;",
+                                      (unsigned)c);
+              if (n > 0)
+                d += n;
+            }
+          else if (c >= 20)
+            {
+              if (!ensure_cap (&dest, &d, &len, 1))
+                return NULL;
+              *d++ = (char)c;
             }
-          else if (*wstr >= 20)
-            *d++ = *wstr;
         }
     }
+
   *d = 0;
   return dest;
 }