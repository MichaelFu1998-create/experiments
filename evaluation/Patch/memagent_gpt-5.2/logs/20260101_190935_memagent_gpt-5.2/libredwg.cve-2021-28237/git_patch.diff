diff --git a/src/decode.c b/src/decode.c
index 281df66c..4fbdb7bc 100644
--- a/src/decode.c
+++ b/src/decode.c
@@ -303,15 +303,19 @@ decode_preR13_section (Dwg_Section_Type_r11 id, Bit_Chain *restrict dat,
   int i;
   BITCODE_BL vcount;
   int error = 0;
-  long unsigned int num = dwg->num_objects;
-  long unsigned int old_size = num * sizeof (Dwg_Object);
-  long unsigned int size = tbl->number * sizeof (Dwg_Object);
-  long unsigned int pos;
+  size_t num = (size_t)dwg->num_objects;
+  size_t pos;
+  size_t need_objects;
+  size_t cur_cap = 0;
+  size_t new_cap;
+  size_t size = (size_t)tbl->number * sizeof (Dwg_Object);
 
   if ((unsigned)tbl->number > 100000 || size > dat->size)
     {
       LOG_ERROR ("Invalid table number %ld for %-8s [%2d]", (long)tbl->number, tbl->name, id);
-      return DWG_ERR_INVALIDDWG;
+      /* Malformed pre-R13 table header: skip this table (non-critical). */
+      tbl->number = 0;
+      return DWG_ERR_VALUEOUTOFBOUNDS;
     }
   LOG_TRACE ("\ncontents table %-8s [%2d]: size:%-4u nr:%-3ld (0x%lx-0x%lx)\n",
              tbl->name, id, tbl->size, (long)tbl->number, (unsigned long)tbl->address,
@@ -322,15 +326,51 @@ decode_preR13_section (Dwg_Section_Type_r11 id, Bit_Chain *restrict dat,
     {
       LOG_ERROR ("Invalid table number %ld or size %ld for %-8s [%2d]", (long)tbl->number, (long)tbl->size,
                  tbl->name, id);
-      return DWG_ERR_INVALIDDWG;
+      /* Malformed table bounds: skip this table (non-critical). */
+      tbl->number = 0;
+      return DWG_ERR_VALUEOUTOFBOUNDS;
+    }
+
+  /* Ensure dwg->object has capacity for all table objects (num + tbl->number).
+     The previous code only realloc"ed at REFS_PER_REALLOC boundaries and
+     also mixed up elements and bytes (+REFS_PER_REALLOC).
+     This could under-allocate and lead to OOB writes in PREP_TABLE. */
+  need_objects = num + (size_t)tbl->number;
+  if (dwg->object)
+    cur_cap = ((num + REFS_PER_REALLOC - 1) / REFS_PER_REALLOC) * REFS_PER_REALLOC;
+  else
+    cur_cap = 0;
+
+  if (need_objects > cur_cap)
+    {
+      size_t old_cap = cur_cap;
+      new_cap = ((need_objects + REFS_PER_REALLOC - 1) / REFS_PER_REALLOC)
+                * REFS_PER_REALLOC;
+      if (new_cap > ((size_t)-1) / sizeof (Dwg_Object))
+        {
+          LOG_ERROR ("Out of memory (object table too large)");
+          return DWG_ERR_OUTOFMEM;
+        }
+      void *tmp = realloc (dwg->object, new_cap * sizeof (Dwg_Object));
+      if (!tmp)
+        {
+          LOG_ERROR ("Out of memory");
+          return DWG_ERR_OUTOFMEM;
+        }
+      dwg->object = (Dwg_Object *)tmp;
+      /* Zero-initialize the newly-grown portion to keep later logic safe. */
+      if (new_cap > old_cap)
+        memset (&dwg->object[old_cap], 0,
+                (new_cap - old_cap) * sizeof (Dwg_Object));
     }
-  if (dwg->num_objects % REFS_PER_REALLOC == 0)
-    dwg->object = (Dwg_Object*)realloc (dwg->object, old_size + size + REFS_PER_REALLOC);
 
     // TODO: move to a spec dwg_r11.spec, and dwg_decode_r11_NAME
 #define PREP_TABLE(token)                                                     \
   Dwg_Object *obj = &dwg->object[num + i];                                    \
-  Dwg_Object_##token *_obj = (Dwg_Object_##token*)calloc (1, sizeof (Dwg_Object_##token)); \
+  memset (obj, 0, sizeof (Dwg_Object));                                       \
+  obj->parent = dwg;                                                          \
+  Dwg_Object_##token *_obj                                                    \
+    = (Dwg_Object_##token*)calloc (1, sizeof (Dwg_Object_##token));           \
   if (dat->byte > dat->size)                                                  \
     {                                                                         \
       free (_obj);                                                            \
@@ -346,7 +386,7 @@ decode_preR13_section (Dwg_Section_Type_r11 id, Bit_Chain *restrict dat,
   dwg->num_objects++;                                                         \
   obj->tio.object->tio.token = _obj;                                          \
   obj->tio.object->objid = obj->index;                                        \
-  obj->tio.object->dwg = obj->parent;                                         \
+  obj->tio.object->dwg = dwg;                                                 \
   obj->supertype = DWG_SUPERTYPE_OBJECT;                                      \
   obj->parent = dwg;                                                          \
   obj->name = obj->dxfname = (char *)#token;                                  \
@@ -358,10 +398,11 @@ decode_preR13_section (Dwg_Section_Type_r11 id, Bit_Chain *restrict dat,
   pos = tbl->address + ((long)(i + 1) * tbl->size);                           \
   if ((long)(pos - dat->byte) != 2)                                           \
     {                                                                         \
-      LOG_ERROR ("offset %ld", pos - dat->byte);                              \
-      return DWG_ERR_SECTIONNOTFOUND;                                         \
+      /* Do not abort decoding with a critical error on malformed offsets. */ \
+      LOG_ERROR ("offset %ld", (long)(pos - dat->byte));                      \
+      error |= DWG_ERR_VALUEOUTOFBOUNDS;                                      \
     }                                                                         \
-  dat->byte = pos
+  dat->byte = (pos <= dat->size ? pos : dat->size)
 
   switch (id)
     {