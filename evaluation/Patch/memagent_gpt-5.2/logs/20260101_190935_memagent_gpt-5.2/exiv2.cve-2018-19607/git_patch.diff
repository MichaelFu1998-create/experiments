diff --git a/src/easyaccess.cpp b/src/easyaccess.cpp
index 1eed30c4..1a1e2831 100644
--- a/src/easyaccess.cpp
+++ b/src/easyaccess.cpp
@@ -39,7 +39,7 @@ namespace {
       @param count Number of elements in the array
      */
     ExifData::const_iterator findMetadatum(const ExifData& ed,
-                                           const char* keys[],
+                                           const char* const keys[],
                                            int count)
     {
         for (int i = 0; i < count; ++i) {
@@ -160,22 +160,40 @@ namespace Exiv2 {
                 break;
             // pick up list of ISO tags, and check for at least one of
             // them available.
-            const SensKeyNameList *sensKeys = &sensitivityKey[st_val - 1];
+            const SensKeyNameList* sensKeys = &sensitivityKey[st_val - 1];
             md_st = ed.end();
-            for (int idx = 0; idx < sensKeys->count; md_st = ed.end()) {
-                md_st = findMetadatum(ed, const_cast<const char**>(sensKeys->keys), sensKeys->count);
-                if (md_st == ed.end())
-                    break;
+            for (int idx = 0; idx < sensKeys->count; ) {
+                // Search remaining ISO-related tags referenced by SensitivityType.
+                md_st = findMetadatum(ed, sensKeys->keys + idx, sensKeys->count - idx);
+                if (md_st == ed.end()) break;
+
                 std::ostringstream os_iso;
                 md_st->write(os_iso, &ed);
                 ok = false;
-                iso_tmp_val = parseLong(os_iso.str(), ok);
-                // something wrong with the value
-                if (ok || iso_tmp_val > 0) {
+                const long candidate = parseLong(os_iso.str(), ok);
+
+                // Accept only properly parsed, positive ISO values.
+                if (ok && candidate > 0) {
+                    iso_tmp_val = candidate;
                     md = md_st;
                     break;
                 }
-                while (strcmp(sensKeys->keys[idx++], md_st->key().c_str()) != 0 && idx < cnt) {}
+
+                // Advance idx past the key we just processed (bounded by sensKeys->count).
+                while (idx < sensKeys->count) {
+                    const char* k = sensKeys->keys[idx];
+                    if (k == nullptr) {
+                        ++idx;
+                        continue;
+                    }
+                    if (strcmp(k, md_st->key().c_str()) == 0) {
+                        ++idx;
+                        break;
+                    }
+                    ++idx;
+                }
+
+                md_st = ed.end();
             }
             break;
         }