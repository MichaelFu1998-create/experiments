diff --git a/include/yaml-cpp/exceptions.h b/include/yaml-cpp/exceptions.h
index 9c96859..f67ed81 100644
--- a/include/yaml-cpp/exceptions.h
+++ b/include/yaml-cpp/exceptions.h
@@ -40,6 +40,8 @@ const char* const END_OF_MAP = "end of map not found";
 const char* const END_OF_MAP_FLOW = "end of map flow not found";
 const char* const END_OF_SEQ = "end of sequence not found";
 const char* const END_OF_SEQ_FLOW = "end of sequence flow not found";
+// A hard cap to prevent stack exhaustion on maliciously deep inputs.
+const char* const DEPTH_LIMIT_EXCEEDED = "maximum nesting depth exceeded";
 const char* const MULTIPLE_TAGS =
     "cannot assign multiple tags to the same node";
 const char* const MULTIPLE_ANCHORS =
diff --git a/src/singledocparser.cpp b/src/singledocparser.cpp
index a27c1c3..cb7d5cb 100644
--- a/src/singledocparser.cpp
+++ b/src/singledocparser.cpp
@@ -18,7 +18,8 @@ SingleDocParser::SingleDocParser(Scanner& scanner, const Directives& directives)
     : m_scanner(scanner),
       m_directives(directives),
       m_pCollectionStack(new CollectionStack),
-      m_curAnchor(0) {}
+      m_curAnchor(0),
+      m_nestingDepth(0) {}
 
 SingleDocParser::~SingleDocParser() {}
 
@@ -46,6 +47,11 @@ void SingleDocParser::HandleDocument(EventHandler& eventHandler) {
 }
 
 void SingleDocParser::HandleNode(EventHandler& eventHandler) {
+  struct DepthGuard {
+    explicit DepthGuard(std::size_t& depth) : m_depth(depth) { ++m_depth; }
+    ~DepthGuard() { --m_depth; }
+    std::size_t& m_depth;
+  };
   // an empty node *is* a possibility
   if (m_scanner.empty()) {
     eventHandler.OnNull(m_scanner.mark(), NullAnchor);
@@ -55,6 +61,11 @@ void SingleDocParser::HandleNode(EventHandler& eventHandler) {
   // save location
   Mark mark = m_scanner.peek().mark;
 
+  // Cap nesting depth to avoid stack overflow on malicious input.
+  if (m_nestingDepth >= kMaxNestingDepth)
+    throw ParserException(mark, ErrorMsg::DEPTH_LIMIT_EXCEEDED);
+  DepthGuard depthGuard(m_nestingDepth);
+
   // special case: a value node by itself must be a map, with no header
   if (m_scanner.peek().type == Token::VALUE) {
     eventHandler.OnMapStart(mark, "?", NullAnchor, EmitterStyle::Default);
diff --git a/src/singledocparser.h b/src/singledocparser.h
index 2b92067..10e2698 100644
--- a/src/singledocparser.h
+++ b/src/singledocparser.h
@@ -10,6 +10,7 @@
 #include <map>
 #include <memory>
 #include <string>
+#include <cstddef>
 
 #include "yaml-cpp/anchor.h"
 #include "yaml-cpp/noncopyable.h"
@@ -51,6 +52,11 @@ class SingleDocParser : private noncopyable {
   anchor_t LookupAnchor(const Mark& mark, const std::string& name) const;
 
  private:
+  // Prevent unbounded recursive descent from exhausting the call stack on
+  // maliciously deep YAML inputs (e.g. nested flow maps/sequences).
+  static const std::size_t kMaxNestingDepth = 256;
+  std::size_t m_nestingDepth;
+
   Scanner& m_scanner;
   const Directives& m_directives;
   std::unique_ptr<CollectionStack> m_pCollectionStack;