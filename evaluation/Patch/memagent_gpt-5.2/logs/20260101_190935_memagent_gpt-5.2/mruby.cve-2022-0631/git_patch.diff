diff --git a/src/vm.c b/src/vm.c
index 9cb50847f..5b5bdcab3 100644
--- a/src/vm.c
+++ b/src/vm.c
@@ -692,6 +692,16 @@ mrb_f_send(mrb_state *mrb, mrb_value self)
     mrb_argnum_error(mrb, 0, 1, -1);
   }
   else if (n == 15) {
+    /* variable length arguments are packed in an Array in regs[0] */
+    if (!mrb_array_p(regs[0])) {
+      goto funcall;
+    }
+    mrb_int len = RARRAY_LEN(regs[0]);
+    /* If the packed array is empty, treat it as a no-op instead of
+     * reading past the end (malformed call frame / recursion edge case). */
+    if (len < 1) {
+      return mrb_nil_value();
+    }
     name = mrb_obj_to_sym(mrb, RARRAY_PTR(regs[0])[0]);
   }
   else {
@@ -708,7 +718,18 @@ mrb_f_send(mrb_state *mrb, mrb_value self)
   ci->u.target_class = c;
   /* remove first symbol from arguments */
   if (n == 15) {     /* variable length arguments */
-    regs[0] = mrb_ary_subseq(mrb, regs[0], 1, RARRAY_LEN(regs[0]) - 1);
+    /* regs[0] is validated above; keep it defensive here too */
+    if (!mrb_array_p(regs[0])) {
+      goto funcall;
+    }
+    mrb_int len = RARRAY_LEN(regs[0]);
+    /* remove the method name (first element) from the packed args array */
+    if (len <= 1) {
+      regs[0] = mrb_ary_new_capa(mrb, 0);
+    }
+    else {
+      regs[0] = mrb_ary_subseq(mrb, regs[0], 1, len - 1);
+    }
   }
   else { /* n > 0 */
     for (int i=0; i<n; i++) {