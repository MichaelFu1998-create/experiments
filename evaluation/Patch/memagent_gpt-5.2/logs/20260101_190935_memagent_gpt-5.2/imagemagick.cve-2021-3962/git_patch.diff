diff --git a/MagickCore/constitute.c b/MagickCore/constitute.c
index 2b30644e5..5cf1f8744 100644
--- a/MagickCore/constitute.c
+++ b/MagickCore/constitute.c
@@ -1124,6 +1124,13 @@ MagickExport MagickBooleanType WriteImage(const ImageInfo *image_info,
   (void) CopyMagickString(write_info->filename,image->filename,
     MagickPathExtent);
   (void) SetImageInfo(write_info,1,sans_exception);
+  /*
+    Special case: /dev/null is commonly used as a sink output filename
+    by tooling/harnesses.  Treat it as the NULL coder so we do not
+    attempt to encode using the input format (which may not be writable).
+  */
+  if (LocaleCompare(write_info->filename,"/dev/null") == 0)
+    (void) CopyMagickString(write_info->magick,"NULL",MagickPathExtent);
   if (*write_info->magick == '\0')
     (void) CopyMagickString(write_info->magick,image->magick,MagickPathExtent);
   (void) CopyMagickString(filename,image->filename,MagickPathExtent);
diff --git a/coders/dcm.c b/coders/dcm.c
index edc09e9f4..5bd2f52f7 100644
--- a/coders/dcm.c
+++ b/coders/dcm.c
@@ -3036,11 +3036,13 @@ static inline void RelinquishDCMMemory(DCMInfo *info,DCMMap *map,
     map->green=(int *) RelinquishMagickMemory(map->green);
   if (map->red != (int *) NULL)
     map->red=(int *) RelinquishMagickMemory(map->red);
-  if (stream_info->offsets != (ssize_t *) NULL)
-    stream_info->offsets=(ssize_t *) RelinquishMagickMemory(
-      stream_info->offsets);
   if (stream_info != (DCMStreamInfo *) NULL)
-    stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info);
+    {
+      if (stream_info->offsets != (ssize_t *) NULL)
+        stream_info->offsets=(ssize_t *) RelinquishMagickMemory(
+          stream_info->offsets);
+      stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info);
+    }
   if (stack != (LinkedListInfo *) NULL)
     stack=DestroyLinkedList(stack,RelinquishDCMInfo);
   if (data != (unsigned char *) NULL)
@@ -3996,10 +3998,30 @@ static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)
           (void) RelinquishUniqueFileResource(filename);
         }
         read_info=DestroyImageInfo(read_info);
+        /*
+          If we failed to extract any embedded frame, fall back to returning the
+          original (header-only) DCM image list rather than erroring out.
+        */
+        if (GetFirstImageInList(images) == (Image *) NULL)
+          {
+            images=DestroyImageList(images);
+            images=image;
+            image=(Image *) NULL;
+          }
+        /*
+          Ensure DCM cleanup is performed exactly once. This path can fall
+          through to ThrowDCMException which also calls RelinquishDCMMemory.
+        */
         RelinquishDCMMemory(&info,&map,stream_info,stack,data);
-        image=DestroyImageList(image);
+        stream_info=(DCMStreamInfo *) NULL;
+        stack=(LinkedListInfo *) NULL;
+        data=(unsigned char *) NULL;
+        if (image != (Image *) NULL)
+          image=DestroyImageList(image);
         if ((status == MagickFalse) && (exception->severity < ErrorException))
-          ThrowDCMException(CorruptImageError,"CorruptImageError")
+          (void) ThrowMagickException(exception,GetMagickModule(),
+            CorruptImageWarning,"CorruptImageError","`%s'",
+            image_info->filename);
         return(GetFirstImageInList(images));
       }
     if (info.depth != (1UL*MAGICKCORE_QUANTUM_DEPTH))