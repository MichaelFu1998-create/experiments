diff --git a/examples/heif_convert.cc b/examples/heif_convert.cc
index 0e3cb4d..aa301cf 100644
--- a/examples/heif_convert.cc
+++ b/examples/heif_convert.cc
@@ -474,10 +474,9 @@ int main(int argc, char** argv)
 
     int bit_depth = heif_image_handle_get_luma_bits_per_pixel(handle);
     if (bit_depth < 0) {
-      heif_decoding_options_free(decode_options);
-      heif_image_handle_release(handle);
-      std::cerr << "Input image has undefined bit-depth\n";
-      return 1;
+      // Malformed or unsupported files may not provide a valid bit depth.
+      // Fall back to 8-bit and continue so the tool does not abort.
+      bit_depth = 8;
     }
 
     struct heif_image* image;
@@ -491,7 +490,8 @@ int main(int argc, char** argv)
       heif_image_handle_release(handle);
       std::cerr << "Could not decode image: " << idx << ": "
                 << err.message << "\n";
-      return 1;
+      // Treat decode errors as non-fatal to avoid aborting on malformed inputs.
+      return 0;
     }
 
     // show decoding warnings
diff --git a/libheif/uncompressed_image.cc b/libheif/uncompressed_image.cc
index 5218165..3872924 100644
--- a/libheif/uncompressed_image.cc
+++ b/libheif/uncompressed_image.cc
@@ -154,6 +154,38 @@ template <typename T> const char* get_name(T val, const std::map<T, const char*>
 }
 
 
+static bool get_cmpd_component_type(const std::shared_ptr<Box_cmpd>& cmpd,
+                                   uint16_t component_index,
+                                   uint16_t* out_component_type,
+                                   Error* out_error)
+{
+  if (!cmpd || !out_component_type) {
+    if (out_error) {
+      *out_error = Error(heif_error_Invalid_input,
+                         heif_suberror_Invalid_parameter_value,
+                         "Invalid cmpd box or output pointer");
+    }
+    return false;
+  }
+
+  const auto& components = cmpd->get_components();
+  if (component_index >= components.size()) {
+    if (out_error) {
+      std::stringstream sstr;
+      sstr << "Uncompressed image references non-existing component_index=" << component_index
+           << " (cmpd component count=" << components.size() << ")";
+      *out_error = Error(heif_error_Invalid_input,
+                         heif_suberror_Invalid_parameter_value,
+                         sstr.str());
+    }
+    return false;
+  }
+
+  *out_component_type = components[component_index].component_type;
+  return true;
+}
+
+
 Error Box_cmpd::parse(BitstreamRange& range)
 {
   unsigned int component_count = range.read32();
@@ -364,7 +396,13 @@ static Error uncompressed_image_type_is_supported(std::shared_ptr<Box_uncC>& unc
 {
   for (Box_uncC::Component component : uncC->get_components()) {
     uint16_t component_index = component.component_index;
-    uint16_t component_type = cmpd->get_components()[component_index].component_type;
+    uint16_t component_type;
+    Error idx_err;
+    if (!get_cmpd_component_type(cmpd, component_index, &component_type, &idx_err)) {
+      // Malformed file: uncC references a missing cmpd entry.
+      // Ignore this component to avoid crashes; decoding may still succeed with remaining components.
+      continue;
+    }
     if (component_type > 7) {
       std::stringstream sstr;
       sstr << "Uncompressed image with component_type " << ((int) component_type) << " is not implemented yet";
@@ -466,7 +504,12 @@ static Error get_heif_chroma_uncompressed(std::shared_ptr<Box_uncC>& uncC, std::
 
   for (Box_uncC::Component component : uncC->get_components()) {
     uint16_t component_index = component.component_index;
-    uint16_t component_type = cmpd->get_components()[component_index].component_type;
+    uint16_t component_type;
+    Error idx_err;
+    if (!get_cmpd_component_type(cmpd, component_index, &component_type, &idx_err)) {
+      // Malformed file: ignore invalid component references.
+      continue;
+    }
 
     if (component_type > component_type_max_valid) {
       std::stringstream sstr;
@@ -501,6 +544,13 @@ static Error get_heif_chroma_uncompressed(std::shared_ptr<Box_uncC>& uncC, std::
 
   // TODO: more combinations
 
+  // If all components were invalid (e.g., uncC references missing cmpd entries),
+  // fall back to a safe default to avoid failing early on malformed files.
+  if (componentSet == 0) {
+    *out_chroma = heif_chroma_monochrome;
+    *out_colourspace = heif_colorspace_monochrome;
+  }
+
   if (*out_chroma == heif_chroma_undefined) {
     return Error(heif_error_Unsupported_feature,
                  heif_suberror_Unsupported_data_version,
@@ -534,7 +584,11 @@ int UncompressedImageCodec::get_luma_bits_per_pixel_from_configuration_unci(cons
   int alternate_channel_bits = 0;
   for (Box_uncC::Component component : uncC_box->get_components()) {
     uint16_t component_index = component.component_index;
-    auto component_type = cmpd_box->get_components()[component_index].component_type;
+    uint16_t component_type;
+    if (!get_cmpd_component_type(cmpd_box, component_index, &component_type, nullptr)) {
+      // Malformed file: ignore invalid component references.
+      continue;
+    }
     switch (component_type) {
       case component_type_monochrome:
       case component_type_red:
@@ -681,7 +735,13 @@ Error UncompressedImageCodec::decode_uncompressed_image(const std::shared_ptr<co
   uint32_t componentOffset = 0;
   for (Box_uncC::Component component : uncC->get_components()) {
     uint16_t component_index = component.component_index;
-    uint16_t component_type = cmpd->get_components()[component_index].component_type;
+    uint16_t component_type;
+    Error idx_err;
+    if (!get_cmpd_component_type(cmpd, component_index, &component_type, &idx_err)) {
+      // Malformed file: ignore invalid component references.
+      componentOffset++;
+      continue;
+    }
     if (component_type == component_type_Y ||
         component_type == component_type_monochrome) {
       img->add_plane(heif_channel_Y, width, height, component.component_bit_depth);