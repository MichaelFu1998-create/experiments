diff --git a/src/vm.c b/src/vm.c
index 5f2ef779a..a01c9670a 100644
--- a/src/vm.c
+++ b/src/vm.c
@@ -1165,34 +1165,67 @@ hash_new_from_values(mrb_state *mrb, mrb_int argc, mrb_value *regs)
 }
 
 #define ARGUMENT_NORMALIZE(arg_base, arg_info, insn) do { \
-  int n = *(arg_info)&0xf; \
-  int nk = (*(arg_info)>>4)&0xf; \
-  mrb_int bidx = (arg_base) + mrb_bidx(*(arg_info)); \
+  uint16_t arg_info0 = *(arg_info); \
+  int n = arg_info0 & 0xf; \
+  int nk = (arg_info0 >> 4) & 0xf; \
+  /* bidx is based on the original arg_info. new_bidx is based on the possibly-updated arg_info. */ \
+  mrb_int bidx = (arg_base) + mrb_bidx(arg_info0); \
+  /* regs is the current irep register window (0..irep->nregs-1). */ \
+  mrb_int limit = (mrb_int)irep->nregs; \
+  \
   if (nk == CALL_MAXARGS) { \
-    mrb_ensure_hash_type(mrb, regs[(arg_base)+(n==CALL_MAXARGS?1:n)+1]); \
+    mrb_int kidx0 = (arg_base) + (n == CALL_MAXARGS ? 1 : n) + 1; \
+    /* If the keyword hash slot is invalid, drop keyword args to keep execution safe. */ \
+    if (kidx0 >= 0 && kidx0 < limit) { \
+      mrb_ensure_hash_type(mrb, regs[kidx0]); \
+    } \
+    else { \
+      nk = 0; \
+      *(arg_info) = (uint16_t)(n | (nk<<4)); \
+    } \
   } \
   else if (nk > 0) {  /* pack keyword arguments */ \
-    mrb_int kidx = (arg_base)+(n==CALL_MAXARGS?1:n)+1; \
-    mrb_value kdict = hash_new_from_values(mrb, nk, regs+kidx); \
-    regs[kidx] = kdict; \
-    nk = CALL_MAXARGS; \
-    *(arg_info) = n | (nk<<4); \
+    mrb_int kidx = (arg_base) + (n == CALL_MAXARGS ? 1 : n) + 1; \
+    /* If keyword pairs are out-of-range, drop keyword args (don't read/write regs out of bounds). */ \
+    if (kidx >= 0 && kidx + (mrb_int)nk * 2 <= limit) { \
+      /* Copy out keyword pairs before calling into hash code because it may re-enter the VM and relocate the stack. */ \
+      mrb_value tmp_kv[CALL_MAXARGS * 2]; \
+      for (mrb_int i = 0; i < (mrb_int)nk * 2; i++) { \
+        tmp_kv[i] = regs[kidx + i]; \
+      } \
+      mrb_value kdict = hash_new_from_values(mrb, nk, tmp_kv); \
+      regs[kidx] = kdict; \
+      nk = CALL_MAXARGS; \
+      *(arg_info) = (uint16_t)(n | (nk<<4)); \
+    } \
+    else { \
+      nk = 0; \
+      *(arg_info) = (uint16_t)(n | (nk<<4)); \
+    } \
   } \
   \
-  mrb_assert(bidx < irep->nregs+(arg_base)); \
-  mrb_int new_bidx = (arg_base)+mrb_bidx(*(arg_info)); \
+  mrb_int new_bidx = (arg_base) + mrb_bidx(*(arg_info)); \
   if ((insn) == OP_SEND) { \
     /* clear block argument */ \
-    SET_NIL_VALUE(regs[new_bidx]); \
+    if (new_bidx >= 0 && new_bidx < limit) { \
+      SET_NIL_VALUE(regs[new_bidx]); \
+    } \
     SET_NIL_VALUE(blk); \
   } \
   else { \
-    blk = regs[bidx]; \
+    if (bidx >= 0 && bidx < limit) { \
+      blk = regs[bidx]; \
+    } \
+    else { \
+      SET_NIL_VALUE(blk); \
+    } \
     if (!mrb_nil_p(blk) && !mrb_proc_p(blk)) { \
       blk = mrb_type_convert(mrb, blk, MRB_TT_PROC, MRB_SYM(to_proc)); \
       /* The stack might have been reallocated during mrb_type_convert(), see #3622 */ \
     } \
-    regs[new_bidx] = blk; \
+    if (new_bidx >= 0 && new_bidx < limit) { \
+      regs[new_bidx] = blk; \
+    } \
   } \
 } while (0)
 
@@ -1843,7 +1876,7 @@ RETRY_TRY_BLOCK:
       else {
         struct REnv *e = uvenv(mrb, lv-1);
         if (!e) goto L_NOSUPER;
-        if (MRB_ENV_LEN(e) <= m1+r+m2+1)
+        if (MRB_ENV_LEN(e) <= m1+r+m2+kd+1)
           goto L_NOSUPER;
         stack = e->stack + 1;
       }
@@ -1938,7 +1971,7 @@ RETRY_TRY_BLOCK:
       if (argc == 15) {
         struct RArray *ary = mrb_ary_ptr(regs[1]);
         argv = ARY_PTR(ary);
-        argc = (int)ARY_LEN(ary);
+        argc = ARY_LEN(ary);
         mrb_gc_protect(mrb, regs[1]);
       }
 
@@ -1952,7 +1985,7 @@ RETRY_TRY_BLOCK:
       /* extract first argument array to arguments */
       else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
         mrb_gc_protect(mrb, argv[0]);
-        argc = (int)RARRAY_LEN(argv[0]);
+        argc = RARRAY_LEN(argv[0]);
         argv = RARRAY_PTR(argv[0]);
       }
 
@@ -2370,7 +2403,7 @@ RETRY_TRY_BLOCK:
       else {
         struct REnv *e = uvenv(mrb, lv-1);
         if (!e || (!MRB_ENV_ONSTACK_P(e) && e->mid == 0) ||
-            MRB_ENV_LEN(e) <= m1+r+m2+1) {
+            MRB_ENV_LEN(e) <= m1+r+m2+kd+1) {
           localjump_error(mrb, LOCALJUMP_ERROR_YIELD);
           goto L_RAISE;
         }