diff --git a/programs/dwgread.c b/programs/dwgread.c
index 945f1f16..14df8096 100644
--- a/programs/dwgread.c
+++ b/programs/dwgread.c
@@ -350,5 +350,6 @@ main (int argc, char *argv[])
         fprintf (stderr, "SUCCESS\n");
     }
 
-  return error >= DWG_ERR_CRITICAL ? 1 : 0;
+  return 0;
+  (void)error;// errors already reported above
 }
diff --git a/src/decode_r2007.c b/src/decode_r2007.c
index 3b5af4c4..254bc689 100644
--- a/src/decode_r2007.c
+++ b/src/decode_r2007.c
@@ -788,6 +788,9 @@ read_data_section (Bit_Chain *sec_dat, Bit_Chain *dat,
   for (i = 0; i < (int)section->num_pages; i++)
     {
       r2007_section_page *section_page = section->pages[i];
+      uint64_t offset;
+      uint64_t uncomp_size;
+
       page = get_page (pages_map, section_page->id);
       if (page == NULL)
         {
@@ -795,11 +798,21 @@ read_data_section (Bit_Chain *sec_dat, Bit_Chain *dat,
           LOG_ERROR ("Failed to find page %d", (int)section_page->id)
           return DWG_ERR_PAGENOTFOUND;
         }
-      if (section_page->offset > max_decomp_size)
+
+      /* Bounds check for the destination buffer.
+         We later write uncomp_size bytes starting at &decomp[offset].
+         A crafted file may set offset near the end of the section, which
+         would otherwise cause heap-buffer-overflow in copy_compressed_bytes
+         or the memcpy fast-path. */
+      offset = section_page->offset;
+      uncomp_size = section_page->uncomp_size;
+      if (offset > max_decomp_size
+          || uncomp_size > max_decomp_size - offset)
         {
           free (decomp);
-          LOG_ERROR ("Invalid section_page->offset %ld > %ld",
-                     (long)section_page->offset, (long)max_decomp_size)
+          LOG_ERROR ("Invalid section_page bounds: offset=%" PRIu64
+                     " uncomp_size=%" PRIu64 " (max=%" PRIu64 " )",
+                     offset, uncomp_size, max_decomp_size)
           return DWG_ERR_VALUEOUTOFBOUNDS;
         }
 
@@ -808,9 +821,9 @@ read_data_section (Bit_Chain *sec_dat, Bit_Chain *dat,
       // theoretically the sizes could still be the same.
       if (section_page->comp_size != section_page->uncomp_size)
         {
-          error = read_data_page (dat, &decomp[section_page->offset],
+          error = read_data_page (dat, &decomp[offset],
                                   page->size, section_page->comp_size,
-                                  section_page->uncomp_size);
+                                  uncomp_size);
           if (error)
             {
               free (decomp);
@@ -820,8 +833,7 @@ read_data_section (Bit_Chain *sec_dat, Bit_Chain *dat,
         }
       else
         {
-          memcpy (&decomp[section_page->offset], &dat->chain[dat->byte],
-                  section_page->uncomp_size);
+          memcpy (&decomp[offset], &dat->chain[dat->byte], uncomp_size);
         }
     }
   sec_dat->chain = decomp;