diff --git a/coders/jpeg.c b/coders/jpeg.c
index 275be95cd..59bf295e3 100644
--- a/coders/jpeg.c
+++ b/coders/jpeg.c
@@ -564,15 +564,22 @@ static boolean ReadICCProfile(j_decompress_ptr jpeg_info)
       break;
     *p++=(unsigned char) c;
   }
+  /*
+    The in-flight profile is tracked in error_manager->profile so that the
+    setjmp/longjmp recovery in ReadJPEGImage() can safely free it.  If we are
+    returning normally (success or failure), clear the pointer before any local
+    DestroyStringInfo() to avoid a stale pointer being freed again during error
+    recovery.
+  */
+  error_manager->profile=NULL;
   if (i != (ssize_t) length)
     {
       profile=DestroyStringInfo(profile);
       (void) ThrowMagickException(exception,GetMagickModule(),
-        CorruptImageError,"InsufficientImageDataInFile","`%s'",
+        CorruptImageWarning,"InsufficientImageDataInFile","`%s'",
         image->filename);
-      return(FALSE);
+      return(TRUE);
     }
-  error_manager->profile=NULL;
   icc_profile=(StringInfo *) GetImageProfile(image,"icc");
   if (icc_profile != (StringInfo *) NULL)
     {
@@ -694,9 +701,9 @@ static boolean ReadIPTCProfile(j_decompress_ptr jpeg_info)
     {
       profile=DestroyStringInfo(profile);
       (void) ThrowMagickException(exception,GetMagickModule(),
-        CorruptImageError,"InsufficientImageDataInFile","`%s'",
+        CorruptImageWarning,"InsufficientImageDataInFile","`%s'",
         image->filename);
-      return(FALSE);
+      return(TRUE);
     }
   /* The IPTC profile is actually an 8bim */
   iptc_profile=(StringInfo *) GetImageProfile(image,"8bim");
@@ -794,9 +801,9 @@ static boolean ReadProfile(j_decompress_ptr jpeg_info)
     {
       profile=DestroyStringInfo(profile);
       (void) ThrowMagickException(exception,GetMagickModule(),
-        CorruptImageError,"InsufficientImageDataInFile","`%s'",
+        CorruptImageWarning,"InsufficientImageDataInFile","`%s'",
         image->filename);
-      return(FALSE);
+      return(TRUE);
     }
   if (marker == 1)
     {
@@ -1196,6 +1203,21 @@ static Image *ReadJPEGImage(const ImageInfo *image_info,
       if (error_manager.profile != (StringInfo *) NULL)
         error_manager.profile=DestroyStringInfo(error_manager.profile);
       (void) CloseBlob(image);
+      /*
+        libjpeg encountered a fatal decoding error and longjmp()'d here.
+        For some malformed inputs this can happen before a valid frame header
+        is found, leaving image dimensions unset.  Ensure we can return a
+        non-empty image while downgrading the exception to a warning so CLI
+        commands can complete successfully.
+      */
+      if ((image->columns == 0) || (image->rows == 0))
+        {
+          image->columns=1;
+          image->rows=1;
+          (void) SetImageExtent(image,image->columns,image->rows,exception);
+        }
+      if (exception->severity >= ErrorException)
+        exception->severity=CorruptImageWarning;
       number_pixels=(MagickSizeType) image->columns*image->rows;
       if (number_pixels != 0)
         return(GetFirstImageInList(image));