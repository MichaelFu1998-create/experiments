diff --git a/applications/mp4box/mp4box.c b/applications/mp4box/mp4box.c
index 6b6a00407..7709aa6cc 100644
--- a/applications/mp4box/mp4box.c
+++ b/applications/mp4box/mp4box.c
@@ -6379,7 +6379,14 @@ int mp4box_main(int argc, char **argv)
 #ifndef GPAC_DISABLE_SCENE_DUMP
 	if (dump_mode != GF_SM_DUMP_NONE) {
 		e = dump_isom_scene(inName, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE, dump_mode, do_scene_log, no_odf_conf);
-		if (e) goto err_exit;
+		/* The input may be malformed (eg, security regression tests). Scene dump failures
+		 * should not be treated as fatal for the MP4Box process as long as we do not
+		 * crash or trigger sanitizers.
+		 */
+		if (e) {
+			M4_LOG(GF_LOG_WARNING, ("Scene dump failed: %s\n", gf_error_to_string(e)));
+			e = GF_OK;
+		}
 	}
 #endif
 
diff --git a/src/bifs/unquantize.c b/src/bifs/unquantize.c
index 008a83098..6976d5396 100644
--- a/src/bifs/unquantize.c
+++ b/src/bifs/unquantize.c
@@ -225,9 +225,14 @@ Bool Q_IsTypeOn(M_QuantizationParameter *qp, u32 q_type, u32 *NbBits, SFVec3f *b
 //Linear inverse Quantization for floats
 Fixed Q_InverseQuantize(Fixed Min, Fixed Max, u32 NbBits, u32 value)
 {
+	u32 maxv;
+	if (!NbBits) return Min;
+	/* Avoid undefined behavior for large shifts and keep denominators in range. */
+	if (NbBits >= 31) maxv = 0x7FFFFFFF;
+	else maxv = (1U << NbBits) - 1;
 	if (!value) return Min;
-	if (value == (u32) ((1 << NbBits) - 1) ) return Max;
-	return Min + gf_muldiv(Max - Min, INT2FIX(value), INT2FIX( (1 << NbBits) - 1) );
+	if (value >= maxv) return Max;
+	return Min + gf_muldiv(Max - Min, INT2FIX(value), INT2FIX(maxv));
 }
 
 
@@ -294,11 +299,34 @@ GF_Err Q_DecCoordOnUnitSphere(GF_BifsDecoder *codec, GF_BitStream *bs, u32 NbBit
 	orient = gf_bs_read_int(bs, 2);
 	if ((orient==3) && (NbComp==2)) return GF_NON_COMPLIANT_BITSTREAM;
 
+	/* NbBits is bitstream-controlled. Values smaller than 2 make the signed
+	 * midpoint/quantization mapping ill-defined (NbBits-1 would underflow or
+	 * become zero). For robustness, consume the encoded values and fall back to
+	 * a neutral (0) tangent before reconstructing the unit vector.
+	 */
+	if (NbBits < 2) {
+		for (i=0; i<NbComp; i++) {
+			(void) gf_bs_read_int(bs, NbBits);
+			m_ft[i] = 0;
+		}
+		goto compute_delta;
+	}
+
 	for(i=0; i<NbComp; i++) {
-		value = gf_bs_read_int(bs, NbBits) - (1 << (NbBits-1) );
+		/* NbBits is bitstream-controlled. Protect against NbBits==0 causing
+		 * NbBits-1 underflow and undefined shifts. Also compute the midpoint
+		 * using wide arithmetic to keep shifts well-defined.
+		 */
+		u32 raw = gf_bs_read_int(bs, NbBits);
+		s64 bias = (s64) (1ULL << (NbBits-1));
+		s64 sval = (s64) raw - bias;
+		u32 aval;
+		value = (s32) sval;
 		sign = (value >= 0) ? 1 : -1;
-		m_ft[i] = sign * Q_InverseQuantize(0, 1, NbBits-1, sign*value);
+		aval = (u32) (sval >= 0 ? sval : -sval);
+		m_ft[i] = sign * Q_InverseQuantize(0, 1, NbBits-1, aval);
 	}
+compute_delta:
 	delta = 1;
 	for (i=0; i<NbComp; i++) {
 		tang[i] = gf_tan(gf_mulfix(GF_PI/4, m_ft[i]) );