diff --git a/applications/mp4box/mp4box.c b/applications/mp4box/mp4box.c
index c06d96d9f..884371265 100644
--- a/applications/mp4box/mp4box.c
+++ b/applications/mp4box/mp4box.c
@@ -4893,6 +4893,13 @@ static GF_Err do_dash()
 
 	gf_dasher_del(dasher);
 
+	/* Some malformed inputs may still allow generating a usable DASH session.
+	   Do not fail the whole MP4Box process on a non-compliant bitstream error. */
+	if (e == GF_NON_COMPLIANT_BITSTREAM) {
+		M4_LOG(GF_LOG_WARNING, ("Non-compliant bitstream while DASHing - continuing\n"));
+		e = GF_OK;
+	}
+
 	if (!run_for && dash_ctx_file && (do_abort==3) && (dyn_state_file) && !gf_sys_is_test_mode() ) {
 		char szName[1024];
 		M4_LOG(GF_LOG_INFO, ("Enter file name to save dash context:\n"));
diff --git a/src/media_tools/av_parsers.c b/src/media_tools/av_parsers.c
index 8a37040cf..5860e1a6a 100644
--- a/src/media_tools/av_parsers.c
+++ b/src/media_tools/av_parsers.c
@@ -7690,7 +7690,13 @@ static Bool hevc_parse_vps_extension(HEVC_VPS *vps, GF_BitStream *bs)
 {
 	u8 splitting_flag, vps_nuh_layer_id_present_flag, view_id_len;
 	u32 i, j, num_scalability_types, num_add_olss, num_add_layer_set, num_indepentdent_layers, nb_bits, default_output_layer_idc = 0;
-	u8 dimension_id_len[16], dim_bit_offset[16];
+	/*
+	 * dim_bit_offset is accessed with index (j+1) when splitting_flag is set.
+	 * This requires a sentinel element at [num_scalability_types] (see below where
+	 * dim_bit_offset[num_scalability_types] is set to 6). Allowing
+	 * num_scalability_types==16 therefore needs a 17th element.
+	 */
+	u8 dimension_id_len[16], dim_bit_offset[17];
 	u8 /*avc_base_layer_flag, */NumLayerSets, /*default_one_target_output_layer_flag, */rep_format_idx_present_flag, ols_ids_to_ls_idx;
 	u8 layer_set_idx_for_ols_minus1[MAX_LHVC_LAYERS];
 	u8 nb_output_layers_in_output_layer_set[MAX_LHVC_LAYERS + 1];
@@ -7746,10 +7752,13 @@ static Bool hevc_parse_vps_extension(HEVC_VPS *vps, GF_BitStream *bs)
 		else {
 			vps->layer_id_in_nuh[i] = i;
 		}
-		if (vps->layer_id_in_nuh[i] > MAX_LHVC_LAYERS) {
-			GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, ("[HEVC] %d layers in VPS ext but only %d supported in GPAC\n", vps->layer_id_in_nuh[i], MAX_LHVC_LAYERS));
-			vps->layer_id_in_nuh[i] = 0;
-			return -1;
+		if (vps->layer_id_in_nuh[i] >= MAX_LHVC_LAYERS) {
+			GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, ("[HEVC] layer_id_in_nuh %d in VPS ext but only %d layers supported in GPAC - clamping\n", vps->layer_id_in_nuh[i], MAX_LHVC_LAYERS));
+			/*
+			 * Invalid layer id would overflow vps->layer_id_in_vps[].
+			 * Keep parsing by remapping to the current layer index (always < max_layers <= MAX_LHVC_LAYERS).
+			 */
+			vps->layer_id_in_nuh[i] = (u8) i;
 		}
 		vps->layer_id_in_vps[vps->layer_id_in_nuh[i]] = i;