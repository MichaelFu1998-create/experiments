diff --git a/src/decode_r2007.c b/src/decode_r2007.c
index 3b5af4c4..b44a5781 100644
--- a/src/decode_r2007.c
+++ b/src/decode_r2007.c
@@ -803,6 +803,22 @@ read_data_section (Bit_Chain *sec_dat, Bit_Chain *dat,
           return DWG_ERR_VALUEOUTOFBOUNDS;
         }
 
+      /* Ensure the (offset, uncomp_size) window fits into the backing
+         allocation (max_decomp_size). The per-page decompressor only knows
+         about its dst_size, but dst is a pointer into the section buffer.
+         A crafted DWG can otherwise make us write past the end of 'decomp'. */
+      if ((uint64_t)section_page->uncomp_size > max_decomp_size
+          || (uint64_t)section_page->offset
+                 > (max_decomp_size - (uint64_t)section_page->uncomp_size))
+        {
+          free (decomp);
+          LOG_ERROR ("Invalid section page window: offset=%" PRIu64
+                     " uncomp_size=%u max=%" PRIu64,
+                     (uint64_t)section_page->offset, section_page->uncomp_size,
+                     max_decomp_size)
+          return DWG_ERR_VALUEOUTOFBOUNDS;
+        }
+
       dat->byte = page->offset;
       // only if compressed. TODO: Isn't there a compressed flag as with 2004+?
       // theoretically the sizes could still be the same.
@@ -820,6 +836,16 @@ read_data_section (Bit_Chain *sec_dat, Bit_Chain *dat,
         }
       else
         {
+          if ((uint64_t)dat->byte + (uint64_t)section_page->uncomp_size
+              > (uint64_t)dat->size)
+            {
+              free (decomp);
+              LOG_ERROR ("Invalid page read: byte=%lu + size=%u > %lu",
+                         (unsigned long)dat->byte,
+                         section_page->uncomp_size,
+                         (unsigned long)dat->size)
+              return DWG_ERR_VALUEOUTOFBOUNDS;
+            }
           memcpy (&decomp[section_page->offset], &dat->chain[dat->byte],
                   section_page->uncomp_size);
         }