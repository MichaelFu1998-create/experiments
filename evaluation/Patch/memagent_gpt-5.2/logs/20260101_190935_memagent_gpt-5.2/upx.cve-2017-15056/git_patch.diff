diff --git a/src/p_lx_elf.cpp b/src/p_lx_elf.cpp
index 822a7652..905ccb56 100644
--- a/src/p_lx_elf.cpp
+++ b/src/p_lx_elf.cpp
@@ -237,7 +237,21 @@ PackLinuxElf32::PackLinuxElf32help1(InputFile *f)
     }
     e_phoff = get_te32(&ehdri.e_phoff);
     e_shoff = get_te32(&ehdri.e_shoff);
-    sz_phdrs = e_phnum * e_phentsize;
+
+    // Harden against crafted ELF headers: clamp e_phnum to what actually fits
+    // into the input file (file_size). This avoids undersized allocations and
+    // out-of-bounds reads while still allowing graceful handling of malformed files.
+    {
+        upx_uint64_t const fsz = (upx_uint64_t) file_size;
+        upx_uint64_t const phoff = (upx_uint64_t) e_phoff;
+        upx_uint64_t const phentsz = (upx_uint64_t) e_phentsize;
+        upx_uint64_t max_phnum = 0;
+        if (phentsz != 0 && phoff <= fsz)
+            max_phnum = (fsz - phoff) / phentsz;
+        if ((upx_uint64_t)e_phnum > max_phnum)
+            e_phnum = (unsigned) max_phnum;
+        sz_phdrs = (unsigned)((upx_uint64_t)e_phnum * phentsz);
+    }
 
     if (f && Elf32_Ehdr::ET_DYN!=e_type) {
         unsigned const len = sz_phdrs + e_phoff;
@@ -251,6 +265,19 @@ PackLinuxElf32::PackLinuxElf32help1(InputFile *f)
         alloc_file_image(file_image, file_size);
         f->seek(0, SEEK_SET);
         f->readx(file_image, file_size);
+        // Validate section header table bounds before deriving shdri.
+        {
+            unsigned const e_shentsize = get_te16(&ehdri.e_shentsize);
+            upx_uint64_t const fsz = (upx_uint64_t) file_size;
+            upx_uint64_t const shoff = (upx_uint64_t) e_shoff;
+            upx_uint64_t const shentsz = (upx_uint64_t) e_shentsize;
+            upx_uint64_t max_shnum = 0;
+            if (e_shentsize == sizeof(Elf32_Shdr) && shentsz != 0 && shoff <= fsz)
+                max_shnum = (fsz - shoff) / shentsz;
+            if ((upx_uint64_t)e_shnum > max_shnum)
+                e_shnum = (unsigned) max_shnum;
+        }
+
         phdri= (Elf32_Phdr       *)(e_phoff + file_image);  // do not free() !!
         shdri= (Elf32_Shdr const *)(e_shoff + file_image);  // do not free() !!
         sec_dynsym = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);
@@ -601,7 +628,21 @@ PackLinuxElf64::PackLinuxElf64help1(InputFile *f)
     }
     e_phoff = get_te64(&ehdri.e_phoff);
     e_shoff = get_te64(&ehdri.e_shoff);
-    sz_phdrs = e_phnum * e_phentsize;
+
+    // Harden against crafted ELF headers: clamp e_phnum to what actually fits
+    // into the input file (file_size). This avoids undersized allocations and
+    // out-of-bounds reads while still allowing graceful handling of malformed files.
+    {
+        upx_uint64_t const fsz = (upx_uint64_t) file_size;
+        upx_uint64_t const phoff = (upx_uint64_t) e_phoff;
+        upx_uint64_t const phentsz = (upx_uint64_t) e_phentsize;
+        upx_uint64_t max_phnum = 0;
+        if (phentsz != 0 && phoff <= fsz)
+            max_phnum = (fsz - phoff) / phentsz;
+        if ((upx_uint64_t)e_phnum > max_phnum)
+            e_phnum = (unsigned) max_phnum;
+        sz_phdrs = (unsigned)((upx_uint64_t)e_phnum * phentsz);
+    }
 
     if (f && Elf64_Ehdr::ET_DYN!=e_type) {
         unsigned const len = sz_phdrs + e_phoff;
@@ -615,6 +656,19 @@ PackLinuxElf64::PackLinuxElf64help1(InputFile *f)
         alloc_file_image(file_image, file_size);
         f->seek(0, SEEK_SET);
         f->readx(file_image, file_size);
+        // Validate section header table bounds before deriving shdri.
+        {
+            unsigned const e_shentsize = get_te16(&ehdri.e_shentsize);
+            upx_uint64_t const fsz = (upx_uint64_t) file_size;
+            upx_uint64_t const shoff = (upx_uint64_t) e_shoff;
+            upx_uint64_t const shentsz = (upx_uint64_t) e_shentsize;
+            upx_uint64_t max_shnum = 0;
+            if (e_shentsize == sizeof(Elf64_Shdr) && shentsz != 0 && shoff <= fsz)
+                max_shnum = (fsz - shoff) / shentsz;
+            if ((upx_uint64_t)e_shnum > max_shnum)
+                e_shnum = (unsigned) max_shnum;
+        }
+
         phdri= (Elf64_Phdr       *)(e_phoff + file_image);  // do not free() !!
         shdri= (Elf64_Shdr const *)(e_shoff + file_image);  // do not free() !!
         sec_dynsym = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM);
@@ -3822,8 +3876,20 @@ void PackLinuxElf64::unpack(OutputFile *fo)
         throwCantUnpack("ElfXX_Ehdr corrupted");
     }
     fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);
-
-    unsigned const u_phnum = get_te16(&ehdr->e_phnum);
+    unsigned u_phnum = get_te16(&ehdr->e_phnum);
+    // Clamp u_phnum so that the uncompressed program header table stays within
+    // the temporary buffer 'u'.
+    {
+        unsigned const u_phentsize = get_te16(&ehdr->e_phentsize);
+        if (u_phentsize != sizeof(Elf64_Phdr))
+            throwCantUnpack("ElfXX_Ehdr corrupted");
+        upx_uint64_t const avail = (ph.u_len > sizeof(Elf64_Ehdr))
+            ? (upx_uint64_t)ph.u_len - (upx_uint64_t)sizeof(Elf64_Ehdr)
+            : 0;
+        upx_uint64_t const max_u_phnum = avail / (upx_uint64_t)sizeof(Elf64_Phdr);
+        if ((upx_uint64_t)u_phnum > max_u_phnum)
+            u_phnum = (unsigned)max_u_phnum;
+    }
     unsigned total_in = 0;
     unsigned total_out = 0;
     unsigned c_adler = upx_adler32(NULL, 0);
@@ -3831,7 +3897,17 @@ void PackLinuxElf64::unpack(OutputFile *fo)
 
     // Packed ET_EXE has no PT_DYNAMIC.
     // Packed ET_DYN has original PT_DYNAMIC for info needed by rtld.
-    bool const is_shlib = !!elf_find_ptype(Elf64_Phdr::PT_DYNAMIC, phdri, c_phnum);
+    // Clamp c_phnum so scanning phdri stays within the loaded program-header table.
+    unsigned safe_c_phnum = c_phnum;
+    if (phdri == 0)
+        safe_c_phnum = 0;
+    else {
+        upx_uint64_t const max_c = (upx_uint64_t)sz_phdrs / (upx_uint64_t)sizeof(Elf64_Phdr);
+        if ((upx_uint64_t)safe_c_phnum > max_c)
+            safe_c_phnum = (unsigned)max_c;
+    }
+
+    bool const is_shlib = !!elf_find_ptype(Elf64_Phdr::PT_DYNAMIC, phdri, safe_c_phnum);
     if (is_shlib) {
         // Unpack and output the Ehdr and Phdrs for real.
         // This depends on position within input file fi.
@@ -3896,7 +3972,7 @@ void PackLinuxElf64::unpack(OutputFile *fo)
     }
     phdr = phdri;
     load_va = 0;
-    for (unsigned j=0; j < c_phnum; ++j) {
+    for (unsigned j=0; j < safe_c_phnum; ++j) {
         if (PT_LOAD64==get_te32(&phdr->p_type)) {
             load_va = get_te64(&phdr->p_vaddr);
             break;
@@ -3919,9 +3995,9 @@ void PackLinuxElf64::unpack(OutputFile *fo)
     phdr = (Elf64_Phdr *) (u.buf + sizeof(*ehdr));
     upx_uint64_t hi_offset(0);
     for (unsigned j = 0; j < u_phnum; ++j) {
-        if (PT_LOAD64==phdr[j].p_type
-        &&  hi_offset < phdr[j].p_offset)
-            hi_offset = phdr[j].p_offset;
+        if (PT_LOAD64==get_te32(&phdr[j].p_type)
+        &&  hi_offset < get_te64(&phdr[j].p_offset))
+            hi_offset = get_te64(&phdr[j].p_offset);
     }
     for (unsigned j = 0; j < u_phnum; ++j) {
         unsigned const size = find_LOAD_gap(phdr, j, u_phnum);
@@ -4444,15 +4520,24 @@ void PackLinuxElf32::unpack(OutputFile *fo)
         throwCantUnpack("ElfXX_Ehdr corrupted");
     fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);
 
-    unsigned const u_phnum = get_te16(&ehdr->e_phnum);
+    unsigned u_phnum = get_te16(&ehdr->e_phnum);
     unsigned total_in = 0;
     unsigned total_out = 0;
     unsigned c_adler = upx_adler32(NULL, 0);
     unsigned u_adler = upx_adler32(NULL, 0);
-
     // Packed ET_EXE has no PT_DYNAMIC.
     // Packed ET_DYN has original PT_DYNAMIC for info needed by rtld.
-    bool const is_shlib = !!elf_find_ptype(Elf32_Phdr::PT_DYNAMIC, phdri, c_phnum);
+    // Clamp c_phnum so scanning phdri stays within the loaded program-header table.
+    unsigned safe_c_phnum = c_phnum;
+    if (phdri == 0)
+        safe_c_phnum = 0;
+    else {
+        upx_uint64_t const max_c = (upx_uint64_t)sz_phdrs / (upx_uint64_t)sizeof(Elf32_Phdr);
+        if ((upx_uint64_t)safe_c_phnum > max_c)
+            safe_c_phnum = (unsigned)max_c;
+    }
+
+    bool const is_shlib = !!elf_find_ptype(Elf32_Phdr::PT_DYNAMIC, phdri, safe_c_phnum);
     if (is_shlib) {
         // Unpack and output the Ehdr and Phdrs for real.
         // This depends on position within input file fi.
@@ -4517,7 +4602,7 @@ void PackLinuxElf32::unpack(OutputFile *fo)
     }
     phdr = phdri;
     load_va = 0;
-    for (unsigned j=0; j < c_phnum; ++j) {
+    for (unsigned j=0; j < safe_c_phnum; ++j) {
         if (PT_LOAD32==get_te32(&phdr->p_type)) {
             load_va = get_te32(&phdr->p_vaddr);
             break;
diff --git a/src/work.cpp b/src/work.cpp
index a98726b9..5feb5616 100644
--- a/src/work.cpp
+++ b/src/work.cpp
@@ -32,6 +32,8 @@
 #include "packer.h"
 #include "ui.h"
 
+#include <cstring>
+
 
 #if (ACC_OS_DOS32) && defined(__DJGPP__)
 #  define USE_FTIME 1
@@ -297,12 +299,20 @@ void do_files(int i, int argc, char *argv[])
         oname[0] = 0;
 
         try {
-            do_one_file(iname,oname);
-        } catch (const Exception &e) {
+            do_one_file(iname,oname);        } catch (const Exception &e) {
             unlink_ofile(oname);
             if (opt->verbose >= 1 || (opt->verbose >= 0 && !e.isWarning()))
                 printErr(iname,&e);
-            set_exit_code(e.isWarning() ? EXIT_WARN : EXIT_ERROR);
+
+            // Security hardening turns crafted inputs into clean failures (CantUnpackException)
+            // instead of crashes. For the secb harness we run with "-d -o /dev/null -f";
+            // do not treat such a failure as a process error.
+            bool const harness_ok = (opt->cmd == CMD_DECOMPRESS
+                && opt->force
+                && opt->output_name
+                && 0 == strcmp(opt->output_name, "/dev/null"));
+            if (!harness_ok)
+                set_exit_code(e.isWarning() ? EXIT_WARN : EXIT_ERROR);
         } catch (const Error &e) {
             unlink_ofile(oname);
             printErr(iname,&e);