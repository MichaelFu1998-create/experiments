diff --git a/src/class.c b/src/class.c
index c761f46a..57f8c5c6 100644
--- a/src/class.c
+++ b/src/class.c
@@ -311,7 +311,17 @@ mrb_vm_define_class(mrb_state *mrb, mrb_value outer, mrb_value super, mrb_sym id
     c = mrb_class_ptr(old);
     if (s) {
       /* check super class */
-      if (mrb_class_real(c->super) != s) {
+      struct RClass *rs = mrb_class_real(c->super);
+      /*
+       * BasicObject legitimately has no superclass (NULL). When modules are
+       * prepended/included, the superclass chain may temporarily contain
+       * ICLASS/SCLASS wrappers whose `super` can also become NULL at the end
+       * of the chain.
+       *
+       * In that case, treat the existing superclass as unknown/absent and do
+       * not raise a mismatch error here; the class is simply re-opened.
+       */
+      if (rs && rs != s) {
         mrb_raisef(mrb, E_TYPE_ERROR, "superclass mismatch for class %S", old);
       }
     }
@@ -1765,7 +1775,14 @@ mrb_class_real(struct RClass* cl)
 {
   if (cl == 0)
     return NULL;
-  while ((cl->tt == MRB_TT_SCLASS) || (cl->tt == MRB_TT_ICLASS)) {
+  /*
+   * SCLASS/ICLASS nodes are internal wrappers. Walk up to the "real" class.
+   *
+   * In some edge cases (e.g. BasicObject-related bootstrapping), the superclass
+   * chain for these wrappers can terminate at NULL. Guard against cl becoming
+   * NULL while iterating to avoid NULL pointer dereference.
+   */
+  while (cl && ((cl->tt == MRB_TT_SCLASS) || (cl->tt == MRB_TT_ICLASS))) {
     cl = cl->super;
   }
   return cl;