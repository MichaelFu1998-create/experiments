diff --git a/src/mat5.c b/src/mat5.c
index abdb351..be6fe70 100644
--- a/src/mat5.c
+++ b/src/mat5.c
@@ -30,6 +30,7 @@
 
 /* FIXME: Implement Unicode support */
 #include <stddef.h>
+#include <stdint.h>
 #include <stdlib.h>
 #include <string.h>
 #include <stdio.h>
@@ -4864,21 +4865,50 @@ Mat_VarReadNextInfo5( mat_t *mat )
                     (void)Mat_uint32Swap(uncomp_buf);
                 /* Name of variable */
                 if ( uncomp_buf[0] == MAT_T_INT8 ) {    /* Name not in tag */
-                    mat_uint32_t len, len_pad;
+                    /*
+                     * Variable name length is file-controlled. Compute padded
+                     * length using size_t and guard against integer overflow.
+                     */
+                    mat_uint32_t len;
+                    size_t len_sz, len_pad_sz;
                     if ( mat->byteswap )
                         len = Mat_uint32Swap(uncomp_buf+1);
                     else
                         len = uncomp_buf[1];
 
-                    if ( len % 8 == 0 )
-                        len_pad = len;
-                    else
-                        len_pad = len + 8 - (len % 8);
-                    matvar->name = (char*)malloc(len_pad + 1);
+                    /* Avoid excessive allocation/DoS on corrupt files */
+                    if ( len > 1024U*1024U ) {
+                        Mat_VarFree(matvar);
+                        matvar = NULL;
+                        (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);
+                        break;
+                    }
+
+                    len_sz = (size_t)len;
+                    if ( len_sz > (SIZE_MAX - 7) ) {
+                        Mat_VarFree(matvar);
+                        matvar = NULL;
+                        (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);
+                        break;
+                    }
+                    len_pad_sz = (len_sz + 7) & ~(size_t)7;
+                    if ( len_pad_sz < len_sz || len_pad_sz > (SIZE_MAX - 1) ) {
+                        Mat_VarFree(matvar);
+                        matvar = NULL;
+                        (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);
+                        break;
+                    }
+
+                    matvar->name = (char*)malloc(len_pad_sz + 1);
                     if ( NULL != matvar->name ) {
                         /* Variable name */
-                        bytesread += InflateVarName(mat,matvar,matvar->name,len_pad);
-                        matvar->name[len] = '\0';
+                        bytesread += InflateVarName(mat,matvar,matvar->name,len_pad_sz);
+                        matvar->name[len_sz] = '\0';
+                    } else {
+                        Mat_VarFree(matvar);
+                        matvar = NULL;
+                        (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);
+                        break;
                     }
                 } else {
                     mat_uint32_t len = (uncomp_buf[0] & 0xffff0000) >> 16;
@@ -4967,26 +4997,56 @@ Mat_VarReadNextInfo5( mat_t *mat )
                 (void)Mat_uint32Swap(buf);
             /* Name of variable */
             if ( buf[0] == MAT_T_INT8 ) {    /* Name not in tag */
-                mat_uint32_t len, len_pad;
+                /*
+                 * Variable name length is file-controlled. Compute padded
+                 * length using size_t and guard against integer overflow.
+                 */
+                mat_uint32_t len;
+                size_t len_sz, len_pad_sz;
                 if ( mat->byteswap )
                     len = Mat_uint32Swap(buf+1);
                 else
                     len = buf[1];
-                if ( len % 8 == 0 )
-                    len_pad = len;
-                else
-                    len_pad = len + 8 - (len % 8);
-                matvar->name = (char*)malloc(len_pad + 1);
+
+                /* Avoid excessive allocation/DoS on corrupt files */
+                if ( len > 1024U*1024U ) {
+                    Mat_VarFree(matvar);
+                    matvar = NULL;
+                    (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);
+                    break;
+                }
+
+                len_sz = (size_t)len;
+                if ( len_sz > (SIZE_MAX - 7) ) {
+                    Mat_VarFree(matvar);
+                    matvar = NULL;
+                    (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);
+                    break;
+                }
+                len_pad_sz = (len_sz + 7) & ~(size_t)7;
+                if ( len_pad_sz < len_sz || len_pad_sz > (SIZE_MAX - 1) ) {
+                    Mat_VarFree(matvar);
+                    matvar = NULL;
+                    (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);
+                    break;
+                }
+
+                matvar->name = (char*)malloc(len_pad_sz + 1);
                 if ( NULL != matvar->name ) {
-                    readresult = fread(matvar->name, 1, len_pad, (FILE*)mat->fp);
-                    if ( readresult == len_pad ) {
-                        matvar->name[len] = '\0';
+                    readresult = fread(matvar->name, 1, len_pad_sz, (FILE*)mat->fp);
+                    if ( readresult == len_pad_sz ) {
+                        matvar->name[len_sz] = '\0';
                     } else {
                         Mat_VarFree(matvar);
                         matvar = NULL;
                         (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);
                         break;
                     }
+                } else {
+                    Mat_VarFree(matvar);
+                    matvar = NULL;
+                    (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);
+                    break;
                 }
             } else {
                 mat_uint32_t len = (buf[0] & 0xffff0000) >> 16;