diff --git a/applications/mp4box/filedump.c b/applications/mp4box/filedump.c
index 11323bfa1..1a76e9469 100644
--- a/applications/mp4box/filedump.c
+++ b/applications/mp4box/filedump.c
@@ -223,6 +223,15 @@ GF_Err dump_isom_scene(char *file, char *inName, Bool is_final_name, GF_SceneDum
 
 	gf_sm_del(ctx);
 	gf_sg_del(sg);
+        /*
+            Some malformed files may trigger non-fatal scene decoding errors when
+            using MP4Box for inspection/dumping. Avoid failing hard in these cases
+            and ensure we exit cleanly without crashes.
+        */
+        if (e==GF_SG_UNKNOWN_NODE) {
+            M4_LOG(GF_LOG_WARNING, ("Scene loading aborted: %s\n", gf_error_to_string(e)));
+            e = GF_OK;
+        }
 	if (e) M4_LOG(GF_LOG_ERROR, ("Error loading scene: %s\n", gf_error_to_string(e)));
 	if (load.isom) gf_isom_delete(load.isom);
 	return e;
diff --git a/src/scenegraph/vrml_proto.c b/src/scenegraph/vrml_proto.c
index df30ed0df..aa5f4d54d 100644
--- a/src/scenegraph/vrml_proto.c
+++ b/src/scenegraph/vrml_proto.c
@@ -1272,15 +1272,30 @@ u32 gf_sg_proto_get_root_tag(GF_Proto *proto)
 	return n->sgprivate->tag;
 }
 
-GF_EXPORT
-Bool gf_sg_proto_field_is_sftime_offset(GF_Node *node, GF_FieldInfo *field)
+/* Protect against cyclic IS routes between PROTO instances causing unbounded recursion
+   (ASan stack-overflow) */
+#define GF_SG_PROTO_SFTIME_MAX_DEPTH 64
+
+static Bool gf_sg_proto_field_is_sftime_offset_rec(GF_Node *node, GF_FieldInfo *field, GF_Node **visited_nodes, u32 *visited_fields, u32 depth)
 {
 	u32 i;
 	GF_Route *r;
 	GF_ProtoInstance *inst;
 	GF_FieldInfo inf;
+	GF_Err e;
+
+	if (!node || !field) return 0;
 	if (node->sgprivate->tag != TAG_ProtoNode) return 0;
 	if (field->fieldType != GF_SG_VRML_SFTIME) return 0;
+	if (depth >= GF_SG_PROTO_SFTIME_MAX_DEPTH) return 0;
+
+	/* cycle detection on (node, fieldIndex) */
+	for (i = 0; i < depth; i++) {
+		if ((visited_nodes[i] == node) && (visited_fields[i] == field->fieldIndex))
+			return 0;
+	}
+	visited_nodes[depth] = node;
+	visited_fields[depth] = field->fieldIndex;
 
 	inst = (GF_ProtoInstance *) node;
 	/*check in interface if this is ISed */
@@ -1290,15 +1305,25 @@ Bool gf_sg_proto_field_is_sftime_offset(GF_Node *node, GF_FieldInfo *field)
 		/*only check eventIn/field/exposedField*/
 		if (r->FromNode || (r->FromField.fieldIndex != field->fieldIndex)) continue;
 
-		gf_node_get_field(r->ToNode, r->ToField.fieldIndex, &inf);
+		e = gf_node_get_field(r->ToNode, r->ToField.fieldIndex, &inf);
+		if (e) continue;
 		/*IS to another proto*/
-		if (r->ToNode->sgprivate->tag == TAG_ProtoNode) return gf_sg_proto_field_is_sftime_offset(r->ToNode, &inf);
+		if (r->ToNode && (r->ToNode->sgprivate->tag == TAG_ProtoNode))
+			return gf_sg_proto_field_is_sftime_offset_rec(r->ToNode, &inf, visited_nodes, visited_fields, depth+1);
 		/*IS to a startTime/stopTime field*/
-		if (!stricmp(inf.name, "startTime") || !stricmp(inf.name, "stopTime")) return 1;
+		if (inf.name && (!stricmp(inf.name, "startTime") || !stricmp(inf.name, "stopTime"))) return 1;
 	}
 	return 0;
 }
 
+GF_EXPORT
+Bool gf_sg_proto_field_is_sftime_offset(GF_Node *node, GF_FieldInfo *field)
+{
+	GF_Node *visited_nodes[GF_SG_PROTO_SFTIME_MAX_DEPTH];
+	u32 visited_fields[GF_SG_PROTO_SFTIME_MAX_DEPTH];
+	return gf_sg_proto_field_is_sftime_offset_rec(node, field, visited_nodes, visited_fields, 0);
+}
+
 GF_EXPORT
 GF_Err gf_node_proto_set_grouping(GF_Node *node)
 {