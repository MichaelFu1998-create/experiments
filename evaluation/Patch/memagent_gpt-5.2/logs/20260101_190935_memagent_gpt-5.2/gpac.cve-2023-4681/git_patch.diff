diff --git a/src/filters/dasher.c b/src/filters/dasher.c
index 2619d2291..80e9dbad8 100644
--- a/src/filters/dasher.c
+++ b/src/filters/dasher.c
@@ -8381,12 +8381,26 @@ static GF_Err dasher_process(GF_Filter *filter)
 		return GF_EOS;
 	if (ctx->setup_failure) return ctx->setup_failure;
 
+	/* Defensive: current period may be NULL during reconfigure/period switch/abort
+	 * sequences (e.g. when forcing period switch due to config changes). In that case
+	 * just wait for setup to complete rather than dereferencing NULL pointers.
+	 */
+	if (!ctx->current_period || !ctx->current_period->streams) {
+		return gf_filter_end_of_session(filter) ? GF_SERVICE_ERROR : GF_OK;
+	}
+
 	count = gf_list_count(ctx->current_period->streams);
 	if (!ctx->min_cts_period.den) {
 		u64 min_ts=0, min_timescale = 0;
 		u32 num_ready=0, num_blocked=0;
 		for (i=0; i<count; i++) {
 			GF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);
+			/* Defensive: streams may be listed before their input PID is attached.
+			 * Avoid calling PID APIs with NULL. Treat as blocked/not ready. */
+			if (!ds || !ds->ipid) {
+				num_blocked++;
+				continue;
+			}
 			GF_FilterPacket *pck = gf_filter_pid_get_packet(ds->ipid);
 			if (!pck) continue;
 			u64 ts = gf_filter_pck_get_cts(pck);
@@ -8413,7 +8427,8 @@ static GF_Err dasher_process(GF_Filter *filter)
 	for (i=0; i<count; i++) {
 		GF_DashStream *base_ds;
 		GF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);
-		assert(ds);
+		/* Defensive: list may contain NULL entries in some error/reconfigure paths */
+		if (!ds) continue;
 		if (ds->done) continue;
 		base_ds = ds->muxed_base ? ds->muxed_base : ds;
 		//subdur mode abort, don't process
@@ -9457,6 +9472,7 @@ static GF_Err dasher_process(GF_Filter *filter)
 	nb_init = 0;
 	for (i=0; i<count; i++) {
 		GF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);
+		if (!ds) continue;
 		//if (ds->muxed_base) ds = ds->muxed_base;
 		if (ds->done || ds->subdur_done) nb_init++;
 		else if (ds->seg_done && ctx->force_period_switch) nb_init++;
diff --git a/src/media_tools/avilib.c b/src/media_tools/avilib.c
index 27cd81133..dda03dd2f 100644
--- a/src/media_tools/avilib.c
+++ b/src/media_tools/avilib.c
@@ -541,6 +541,12 @@ static int avi_add_odml_index_entry(avi_t *AVI, unsigned char *tag, int flags, u
 
 static int avi_add_index_entry(avi_t *AVI, unsigned char *tag, int flags, u64 pos, u64 len)
 {
+	/* Defensive: AVI->idx can be NULL if idx1 parsing failed but max_idx was
+	 * left non-zero. Avoid NULL dereference and re-init the index storage. */
+	if (!AVI->idx) {
+		AVI->n_idx = 0;
+		AVI->max_idx = 0;
+	}
 	if(AVI->n_idx>=AVI->max_idx) {
 		void *ptr = gf_realloc((void *)AVI->idx,(AVI->max_idx+4096)*16);
 
@@ -1969,6 +1975,7 @@ int avi_parse_input_file(avi_t *AVI, int getIndex)
 					gf_free( AVI->idx);
 					AVI->idx=NULL;
 					AVI->n_idx = 0;
+					AVI->max_idx = 0;
 				}
 		}
 		else
diff --git a/src/media_tools/mpeg2_ps.c b/src/media_tools/mpeg2_ps.c
index 8e33e48d4..7b369e92c 100644
--- a/src/media_tools/mpeg2_ps.c
+++ b/src/media_tools/mpeg2_ps.c
@@ -153,6 +153,7 @@ static Bool file_okay (FILE *fd)
 
 static void file_close (FILE *fd)
 {
+	if (!fd) return;
 	gf_fclose(fd);
 }
 
@@ -160,6 +161,8 @@ static Bool file_read_bytes(FILE *fd,
                             u8 *buffer,
                             u32 len)
 {
+	/* Defensive: gf_fread ultimately calls libc fread(), which crashes on a NULL FILE* */
+	if (!fd) return 0;
 	u32 readval = (u32) gf_fread(buffer, len, fd);
 	return readval == len;
 }
@@ -167,14 +170,24 @@ static Bool file_read_bytes(FILE *fd,
 // note: len could be negative.
 static void file_skip_bytes (FILE *fd, s32 len)
 {
+	if (!fd) return;
 	gf_fseek(fd, len, SEEK_CUR);
 }
+static s64 file_location(FILE *fd)
+{
+	if (!fd) return -1;
+	return gf_ftell(fd);
+}
 
-#define file_location(__f) gf_ftell(__f)
-#define file_seek_to(__f, __off) gf_fseek(__f, __off, SEEK_SET)
+static void file_seek_to(FILE *fd, s64 off)
+{
+	if (!fd) return;
+	gf_fseek(fd, off, SEEK_SET);
+}
 
 static u64 file_size(FILE *fd)
 {
+	if (!fd) return 0;
 	return gf_fsize(fd);
 }