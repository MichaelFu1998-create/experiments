diff --git a/src/dwg.c b/src/dwg.c
index 72c38705..1bfc093a 100644
--- a/src/dwg.c
+++ b/src/dwg.c
@@ -421,12 +421,14 @@ dwg_bmp (const Dwg_Data *restrict dwg, BITCODE_RL *restrict size)
   int found;
   BITCODE_RL header_size, address, osize;
   Bit_Chain *dat;
+  size_t need;
 
   loglevel = dwg->opts & DWG_OPTS_LOGLEVEL;
-  *size = 0;
+  if (size)
+    *size = 0;
   assert (dwg);
   dat = (Bit_Chain *)&dwg->thumbnail;
-  if (!dat || !dat->size)
+  if (!size || !dat || !dat->size || !dat->chain)
     {
       LOG_INFO ("no THUMBNAIL Image Data\n")
       return NULL;
@@ -435,6 +437,16 @@ dwg_bmp (const Dwg_Data *restrict dwg, BITCODE_RL *restrict size)
   dat->version = dwg->header.version;
   dat->from_version = dwg->header.from_version;
 
+  /* Ensure minimal data is available before parsing.
+     A corrupt thumbnail stream could otherwise cause bit_read_* to read
+     beyond dat->chain and produce bogus size/pointers which are later used
+     by callers (e.g. fwrite in dwgbmp). */
+  if (dat->size < 5) /* RL + RC */
+    {
+      LOG_ERROR ("Preview too small: %lu", (unsigned long)dat->size);
+      return NULL;
+    }
+
 #ifdef USE_TRACING
   /* Before starting, set the logging level, but only do so once.  */
   if (!env_var_checked_p)
@@ -460,47 +472,113 @@ dwg_bmp (const Dwg_Data *restrict dwg, BITCODE_RL *restrict size)
   header_size = 0;
   for (i = 0; i < num_pictures; i++)
     {
+      /* Per-picture header needs at least Code[RC] + Address[RL] + Size[RL].
+         Some types (code==1) have an additional RL.
+         Validate before each read to prevent out-of-bounds reads.
+       */
       if (dat->byte > dat->size)
         {
           LOG_ERROR ("Preview overflow");
           break;
         }
+
+      need = 1; /* RC */
+      if ((size_t)dat->byte + need > (size_t)dat->size)
+        {
+          LOG_ERROR ("Preview overflow");
+          *size = 0;
+          return NULL;
+        }
       code = bit_read_RC (dat);
       LOG_TRACE ("\t[%i] Code: %i [RC]\n", i, code)
+
+      need = 4; /* address RL */
+      if ((size_t)dat->byte + need > (size_t)dat->size)
+        {
+          LOG_ERROR ("Preview overflow");
+          *size = 0;
+          return NULL;
+        }
       address = bit_read_RL (dat);
       LOG_TRACE ("\t\tHeader data start: 0x%x [RL]\n", address)
       if (code == 1)
         {
+          need = 4; /* header data size RL */
+          if ((size_t)dat->byte + need > (size_t)dat->size)
+            {
+              LOG_ERROR ("Preview overflow");
+              *size = 0;
+              return NULL;
+            }
           header_size += bit_read_RL (dat);
           LOG_TRACE ("\t\tHeader data size: %i [RL]\n", header_size)
         }
       else if (code == 2 && found == 0)
         {
+          need = 4; /* bmp size RL */
+          if ((size_t)dat->byte + need > (size_t)dat->size)
+            {
+              LOG_ERROR ("Preview overflow");
+              *size = 0;
+              return NULL;
+            }
           *size = bit_read_RL (dat);
           found = 1;
           LOG_INFO ("\t\tBMP size: %i [RL]\n", *size)
         }
       else if (code == 3)
         {
+          need = 4; /* wmf size RL */
+          if ((size_t)dat->byte + need > (size_t)dat->size)
+            {
+              LOG_ERROR ("Preview overflow");
+              *size = 0;
+              return NULL;
+            }
           osize = bit_read_RL (dat);
           LOG_INFO ("\t\tWMF size: %i [RL]\n", osize)
         }
       else
         {
+          need = 4; /* unknown size RL */
+          if ((size_t)dat->byte + need > (size_t)dat->size)
+            {
+              LOG_ERROR ("Preview overflow");
+              *size = 0;
+              return NULL;
+            }
           osize = bit_read_RL (dat);
           LOG_TRACE ("\t\tSize of unknown code %i: %i [RL]\n", code, osize)
         }
     }
+
+  /* Advance to BMP payload start, but keep it within the thumbnail buffer. */
+  if ((size_t)header_size > (size_t)dat->size - (size_t)dat->byte)
+    {
+      LOG_ERROR ("Preview overflow");
+      *size = 0;
+      return NULL;
+    }
   dat->byte += header_size;
   if (*size)
     LOG_TRACE ("BMP offset: %lu\n", dat->byte)
 
   if (*size > 0)
-    return (dat->chain + dat->byte);
-  else
-    return NULL;
+    {
+      /* Final bounds check: ensure returned pointer/length is valid. */
+      if (!dat->chain || (size_t)dat->byte > (size_t)dat->size
+          || (size_t)*size > (size_t)dat->size - (size_t)dat->byte)
+        {
+          LOG_ERROR ("Preview overflow");
+          *size = 0;
+          return NULL;
+        }
+      return (dat->chain + dat->byte);
+    }
+  return NULL;
 }
 
+
 EXPORT double
 dwg_model_x_min (const Dwg_Data *dwg)
 {