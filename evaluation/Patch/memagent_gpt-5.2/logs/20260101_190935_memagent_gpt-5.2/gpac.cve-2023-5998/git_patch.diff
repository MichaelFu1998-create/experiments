diff --git a/src/filters/reframe_mpgvid.c b/src/filters/reframe_mpgvid.c
index 8e092f973..ea950f7b6 100644
--- a/src/filters/reframe_mpgvid.c
+++ b/src/filters/reframe_mpgvid.c
@@ -800,7 +800,59 @@ GF_Err mpgviddmx_process(GF_Filter *filter)
 					ctx->bytes_in_header = 3;
 				}
 
-				dst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data);
+				/*
+			 * Safety: the parser may compute an object size larger than what is currently
+			 * available in the input packet (malformed/truncated streams). Never let this
+			 * cause reads past the end of the input buffer.
+			 */
+			if (size > (u64) bytes_from_store + (u64) remain) {
+				u64 need = (u64) bytes_from_store + (u64) remain;
+				if (need > 0xFFFFFFFFULL) return GF_NON_COMPLIANT_BITSTREAM;
+				if (ctx->hdr_store_alloc < (u32) need) {
+					ctx->hdr_store_alloc = (u32) need;
+					ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);
+				}
+				if (bytes_from_store) {
+					memmove(ctx->hdr_store, ctx->hdr_store+current, bytes_from_store);
+					memmove(ctx->hdr_store + bytes_from_store, start, remain);
+					ctx->hdr_store_size = (u32) need;
+				} else {
+					memmove(ctx->hdr_store, start, remain);
+					ctx->hdr_store_size = remain;
+				}
+				ctx->bytes_in_header = 0;
+				ctx->resume_from = 0;
+				gf_filter_pid_drop_packet(ctx->ipid);
+				return GF_OK;
+			}
+
+			/*
+			 * Safety: never read beyond the current packet when assembling a frame.
+			 * The parser may return a size larger than what is available in this packet
+			 * (eg truncated/corrupt inputs). In that case, buffer and wait for more data.
+			 */
+			if (size > (u64) bytes_from_store + (u64) remain) {
+				u64 need = (u64) bytes_from_store + (u64) remain;
+				if (need > 0xFFFFFFFFULL) return GF_NON_COMPLIANT_BITSTREAM;
+				if (ctx->hdr_store_alloc < (u32) need) {
+					ctx->hdr_store_alloc = (u32) need;
+					ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);
+				}
+				if (bytes_from_store) {
+					memmove(ctx->hdr_store, ctx->hdr_store+current, bytes_from_store);
+					memmove(ctx->hdr_store + bytes_from_store, start, remain);
+					ctx->hdr_store_size = (u32) need;
+				} else {
+					memmove(ctx->hdr_store, start, remain);
+					ctx->hdr_store_size = remain;
+				}
+				ctx->bytes_in_header = 0;
+				ctx->resume_from = 0;
+				gf_filter_pid_drop_packet(ctx->ipid);
+				return GF_OK;
+			}
+
+			dst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data);
 				if (!dst_pck) return GF_OUT_OF_MEM;
 
 				if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
@@ -814,7 +866,7 @@ GF_Err mpgviddmx_process(GF_Filter *filter)
 				}
 
 				mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
-				if (copy_last_bytes) {
+				if (copy_last_bytes && (remain >= 3)) {
 					memcpy(ctx->hdr_store, start+remain-3, 3);
 				}
 				break;
@@ -1084,12 +1136,15 @@ GF_Err mpgviddmx_process(GF_Filter *filter)
 		}
 
 		if ((e == GF_EOS) && !ctx->input_is_au_end) {
-			u8 b3 = start[remain-3];
-			u8 b2 = start[remain-2];
-			u8 b1 = start[remain-1];
+			u8 b3 = 0, b2 = 0, b1 = 0;
+			if (remain >= 3) {
+				b3 = start[remain-3];
+				b2 = start[remain-2];
+				b1 = start[remain-1];
+			}
 
 			//we may have a startcode at the end of the packet, store it and don't dispatch the last 3 bytes !
-			if (!b1 || !b2 || !b3) {
+			if ((remain >= 3) && (!b1 || !b2 || !b3)) {
 				copy_last_bytes = GF_TRUE;
 				assert(size >= 3);
 				size -= 3;
@@ -1118,7 +1173,22 @@ GF_Err mpgviddmx_process(GF_Filter *filter)
 					if (bytes_from_store)
 						size-= bytes_from_store + hdr_offset;
 
-					assert(remain>=size);
+					if (remain < (s32) size) {
+						/* Inconsistent parser-derived size vs available bytes: buffer and wait. */
+						if (data != ctx->hdr_store) {
+							if (ctx->hdr_store_alloc < (u32) remain) {
+								ctx->hdr_store_alloc = (u32) remain;
+								ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);
+							}
+							memmove(ctx->hdr_store, start, remain);
+							ctx->hdr_store_size = remain;
+							ctx->bytes_in_header = 0;
+							ctx->resume_from = 0;
+							gf_filter_pid_drop_packet(ctx->ipid);
+							return GF_OK;
+						}
+						break;
+					}
 					start += size;
 					remain -= (s32) size;
 					//trash all packets until we align to a new startcode
@@ -1151,6 +1221,32 @@ GF_Err mpgviddmx_process(GF_Filter *filter)
 			full_frame = GF_FALSE;
 		}
 
+		/*
+		 * Safety: never read beyond the current packet when assembling a frame.
+		 * The parser may return a size larger than what is available in this packet
+		 * (eg truncated/corrupt inputs). In that case, buffer and wait for more data.
+		 */
+		if (size > (u64) bytes_from_store + (u64) remain) {
+			u64 need = (u64) bytes_from_store + (u64) remain;
+			if (need > 0xFFFFFFFFULL) return GF_NON_COMPLIANT_BITSTREAM;
+			if (ctx->hdr_store_alloc < (u32) need) {
+				ctx->hdr_store_alloc = (u32) need;
+				ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);
+			}
+			if (bytes_from_store) {
+				memmove(ctx->hdr_store, ctx->hdr_store+current, bytes_from_store);
+				memmove(ctx->hdr_store + bytes_from_store, start, remain);
+				ctx->hdr_store_size = (u32) need;
+			} else {
+				memmove(ctx->hdr_store, start, remain);
+				ctx->hdr_store_size = remain;
+			}
+			ctx->bytes_in_header = 0;
+			ctx->resume_from = 0;
+			gf_filter_pid_drop_packet(ctx->ipid);
+			return GF_OK;
+		}
+
 		dst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data);
 		if (!dst_pck) return GF_OUT_OF_MEM;
 
@@ -1160,12 +1256,21 @@ GF_Err mpgviddmx_process(GF_Filter *filter)
 			memcpy(pck_data, ctx->hdr_store+current, bytes_from_store);
 			assert(size >= bytes_from_store);
 			size -= bytes_from_store;
+			if (size > (u64) remain) {
+				/* should not happen thanks to the pre-check above */
+				gf_filter_pck_discard(dst_pck);
+				return GF_NON_COMPLIANT_BITSTREAM;
+			}
 			if (byte_offset != GF_FILTER_NO_BO) {
 				gf_filter_pck_set_byte_offset(dst_pck, byte_offset - bytes_from_store);
 			}
 			memcpy(pck_data + bytes_from_store, start, (size_t) size);
 		} else {
 			//bytes only come the data packet
+			if (size > (u64) remain) {
+				gf_filter_pck_discard(dst_pck);
+				return GF_NON_COMPLIANT_BITSTREAM;
+			}
 			memcpy(pck_data, start, (size_t) size);
 			if (byte_offset != GF_FILTER_NO_BO) {
 				gf_filter_pck_set_byte_offset(dst_pck, byte_offset + start - (u8 *) data);
@@ -1201,12 +1306,14 @@ GF_Err mpgviddmx_process(GF_Filter *filter)
 		}
 
 		if (!full_frame) {
-			if (copy_last_bytes) {
+			if (copy_last_bytes && (remain >= 3)) {
 				memcpy(ctx->hdr_store, start+remain-3, 3);
 			}
 			break;
 		}
-		assert(remain>=size);
+		if (remain < (s32) size) {
+			break;
+		}
 		start += size;
 		remain -= (s32) size;
 	}