diff --git a/src/decode.c b/src/decode.c
index 205056ab..11886c16 100644
--- a/src/decode.c
+++ b/src/decode.c
@@ -192,7 +192,7 @@ dwg_decode (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)
   if (!dat->chain || dat->size < 58)
     {
       LOG_ERROR ("dwg too small: %lu bytes", dat->size);
-      return DWG_ERR_INVALIDDWG;
+      return DWG_ERR_VALUEOUTOFBOUNDS;
     }
   strncpy (version, (const char *)dat->chain, 6);
   version[6] = '\0';
@@ -917,7 +917,7 @@ decode_R13_R2000 (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)
       if (dwg->header.section[j].address + dwg->header.section[j].size > dat->size)
         {
           LOG_ERROR ("section[%u] address or size overflow", j);
-          return DWG_ERR_INVALIDDWG;
+          return error | DWG_ERR_VALUEOUTOFBOUNDS;
         }
     }
 
@@ -2020,6 +2020,14 @@ read_R2004_section_info (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,
     }
 
   ptr = decomp;
+  /* Ensure we can read the fixed-size section_info header safely */
+  decomp_end = decomp + decomp_data_size + 1024;
+  if ((size_t)(decomp_end - ptr) < 20)
+    {
+      free (decomp);
+      LOG_ERROR ("read_R2004_section_info out of range");
+      return error | DWG_ERR_VALUEOUTOFBOUNDS;
+    }
   bfr_read (&dwg->header.section_infohdr, &ptr, 20);
   LOG_TRACE ("\n#### Read 2004 section_infohdr ####\n")
   LOG_TRACE ("num_desc:   %d\n", dwg->header.section_infohdr.num_desc)
@@ -2050,12 +2058,15 @@ read_R2004_section_info (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,
       uint64_t sum_decomp = 0;
       uint64_t prev_address = 0;
 
-      if (ptr + 64 >= decomp_end)
+      /* Each section_info descriptor consumes 96 bytes (32 + 64). The old
+         guard checked only 64 bytes, which allowed an out-of-bounds read via
+         bfr_read(..., 96) on truncated/corrupt input. */
+      if ((size_t)(decomp_end - ptr) < (32 + 64))
         {
           free (decomp);
           dwg->header.section_infohdr.num_desc = i;
           LOG_ERROR ("read_R2004_section_info out of range");
-          return DWG_ERR_INVALIDDWG;
+          return error | DWG_ERR_VALUEOUTOFBOUNDS;
         }
       info = &dwg->header.section_info[i];
       /* endian specific code */
@@ -2081,7 +2092,7 @@ read_R2004_section_info (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,
           dwg->header.section_infohdr.num_desc = i;
           free (decomp);
           LOG_ERROR ("read_R2004_section_info out of range");
-          return DWG_ERR_INVALIDDWG;
+          return error | DWG_ERR_VALUEOUTOFBOUNDS;
         }
 
       if (info->num_sections < 1000000)