diff --git a/src/media_tools/av_parsers.c b/src/media_tools/av_parsers.c
index 43c3200b9..1916b8f34 100644
--- a/src/media_tools/av_parsers.c
+++ b/src/media_tools/av_parsers.c
@@ -6865,6 +6865,18 @@ GF_Err gf_avc_change_vui(GF_AVCConfig *avcc, GF_VUIInfo *vui_info)
 	GF_AVCConfigSlot *slc;
 	orig = NULL;
 
+	/*
+		Defensive checks: this function may be called while importing/mutating
+		malformed files where the AVCConfig (or its SPS list) is missing.
+		The crash report indicates a NULL-derived dereference at
+		gf_list_enum(avcc->sequenceParameterSets, ...).
+	*/
+	if (!vui_info)
+		return GF_BAD_PARAM;
+	/* if no AVC config (or no SPS list), nothing to rewrite */
+	if (!avcc || !avcc->sequenceParameterSets)
+		return GF_OK;
+
 	memset(&avc, 0, sizeof(AVCState));
 	avc.sps_active_idx = -1;
 
@@ -6872,6 +6884,14 @@ GF_Err gf_avc_change_vui(GF_AVCConfig *avcc, GF_VUIInfo *vui_info)
 	while ((slc = (GF_AVCConfigSlot *)gf_list_enum(avcc->sequenceParameterSets, &i))) {
 		u8 *no_emulation_buf = NULL;
 		u32 no_emulation_buf_size = 0, emulation_bytes = 0;
+		if (!slc || !slc->data || (slc->size < 2)) {
+			/* need at least NALU header + 1 byte of payload */
+			if (orig) {
+				gf_bs_del(orig);
+				orig = NULL;
+			}
+			continue;
+		}
 		idx = gf_avc_read_sps(slc->data, slc->size, &avc, 0, &bit_offset);
 		if (idx<0) {
 			if ( orig )
@@ -6881,12 +6901,38 @@ GF_Err gf_avc_change_vui(GF_AVCConfig *avcc, GF_VUIInfo *vui_info)
 
 		/*SPS still contains emulation bytes*/
 		no_emulation_buf = gf_malloc((slc->size - 1) * sizeof(char));
+		if (!no_emulation_buf) {
+			if (orig) {
+				gf_bs_del(orig);
+				orig = NULL;
+			}
+			return GF_OUT_OF_MEM;
+		}
 		no_emulation_buf_size = gf_media_nalu_remove_emulation_bytes(slc->data + 1, no_emulation_buf, slc->size - 1);
+		if (!no_emulation_buf_size) {
+			/* invalid/empty SPS payload after emulation removal */
+			gf_free(no_emulation_buf);
+			if (orig) {
+				gf_bs_del(orig);
+				orig = NULL;
+			}
+			continue;
+		}
 
 		orig = gf_bs_new(no_emulation_buf, no_emulation_buf_size, GF_BITSTREAM_READ);
+		if (!orig) {
+			gf_free(no_emulation_buf);
+			return GF_OUT_OF_MEM;
+		}
 		gf_bs_read_data(orig, no_emulation_buf, no_emulation_buf_size);
 		gf_bs_seek(orig, 0);
 		mod = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
+		if (!mod) {
+			gf_bs_del(orig);
+			orig = NULL;
+			gf_free(no_emulation_buf);
+			return GF_OUT_OF_MEM;
+		}
 
 		/*copy over till vui flag*/
 		assert(bit_offset >= 8);
@@ -6910,8 +6956,15 @@ GF_Err gf_avc_change_vui(GF_AVCConfig *avcc, GF_VUIInfo *vui_info)
 		/*set anti-emulation*/
 		gf_bs_get_content(mod, &no_emulation_buf, &flag);
 		emulation_bytes = gf_media_nalu_emulation_bytes_add_count(no_emulation_buf, flag);
-		if (flag+emulation_bytes+1>slc->size)
-			slc->data = (char*)gf_realloc(slc->data, flag+emulation_bytes+1);
+		if (flag+emulation_bytes+1>slc->size) {
+			char *tmp = (char*)gf_realloc(slc->data, flag+emulation_bytes+1);
+			if (!tmp) {
+				gf_bs_del(mod);
+				gf_free(no_emulation_buf);
+				return GF_OUT_OF_MEM;
+			}
+			slc->data = tmp;
+		}
 		slc->size = gf_media_nalu_add_emulation_bytes(no_emulation_buf, slc->data + 1, flag) + 1;
 
 		gf_bs_del(mod);
diff --git a/src/media_tools/isom_tools.c b/src/media_tools/isom_tools.c
index 21f8905cf..10b4dd85a 100644
--- a/src/media_tools/isom_tools.c
+++ b/src/media_tools/isom_tools.c
@@ -195,6 +195,10 @@ GF_Err gf_media_change_color(GF_ISOFile *file, u32 track, s32 fullrange, s32 vid
 			|| (stype==GF_ISOM_SUBTYPE_AVC4_H264)
 	) {
 		GF_AVCConfig *avcc = gf_isom_avc_config_get(file, track, 1);
+		if (!avcc) {
+			/* Malformed file or missing avcC: do not fail import, just update visual signaling if possible */
+			return gf_isom_set_visual_color_info(file, track, 1, 0, 0, 0, 0, 0, NULL, 0);
+		}
 		gf_avc_change_color(avcc, fullrange, vidformat, colorprim, transfer, colmatrix);
 		e = gf_isom_avc_config_update(file, track, 1, avcc);
 		gf_odf_avc_cfg_del(avcc);
@@ -210,6 +214,9 @@ GF_Err gf_media_change_color(GF_ISOFile *file, u32 track, s32 fullrange, s32 vid
 			|| (stype==GF_ISOM_SUBTYPE_LHE1)
 	) {
 		GF_HEVCConfig *hvcc = gf_isom_hevc_config_get(file, track, 1);
+		if (!hvcc) {
+			return gf_isom_set_visual_color_info(file, track, 1, 0, 0, 0, 0, 0, NULL, 0);
+		}
 		gf_hevc_change_color(hvcc, fullrange, vidformat, colorprim, transfer, colmatrix);
 		e = gf_isom_hevc_config_update(file, track, 1, hvcc);
 		gf_odf_hevc_cfg_del(hvcc);
@@ -219,6 +226,9 @@ GF_Err gf_media_change_color(GF_ISOFile *file, u32 track, s32 fullrange, s32 vid
 	}
 	if ((stype==GF_ISOM_SUBTYPE_VVC1) || (stype==GF_ISOM_SUBTYPE_VVI1) ) {
 		GF_VVCConfig *vvcc = gf_isom_vvc_config_get(file, track, 1);
+		if (!vvcc) {
+			return gf_isom_set_visual_color_info(file, track, 1, 0, 0, 0, 0, 0, NULL, 0);
+		}
 		gf_vvc_change_color(vvcc, fullrange, vidformat, colorprim, transfer, colmatrix);
 		e = gf_isom_vvc_config_update(file, track, 1, vvcc);
 		gf_odf_vvc_cfg_del(vvcc);