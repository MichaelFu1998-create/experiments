diff --git a/mrbgems/mruby-io/src/io.c b/mrbgems/mruby-io/src/io.c
index 58bcdd1e..3d1633f1 100644
--- a/mrbgems/mruby-io/src/io.c
+++ b/mrbgems/mruby-io/src/io.c
@@ -561,13 +561,46 @@ mrb_io_initialize_copy(mrb_state *mrb, mrb_value copy)
   mrb_bool failed = TRUE;
 
   mrb_get_args(mrb, "o", &orig);
+
+  /* If orig is not an IO/File (or not a Data object), do nothing.
+   * This method is primarily used internally by dup/clone; ignoring invalid
+   * input avoids leaving `copy` in a partially-torn-down state.
+   */
+  if (mrb_type(orig) != MRB_TT_DATA) {
+    return copy;
+  }
+  if (DATA_TYPE(orig) != &mrb_io_type) {
+    return copy;
+  }
+
+  /*
+   * Dup/clone of a Data object is a shallow copy in mruby: `copy` can initially
+   * share the same internal pointer with `orig`. The previous implementation
+   * finalized/freed DATA_PTR(copy) before validating/reading `orig`, which
+   * could free the shared fptr and lead to use-after-free in io_get_open_fptr()
+   * and later in fptr_finalize() during GC teardown.
+   */
+  if (mrb_obj_ptr(copy) == mrb_obj_ptr(orig)) {
+    return copy;
+  }
+
+  /* Validate and fetch the original fptr before touching copy's fptr. */
+  fptr_orig = io_get_open_fptr(mrb, orig);
+
   fptr_copy = (struct mrb_io *)DATA_PTR(copy);
   if (fptr_copy != NULL) {
-    fptr_finalize(mrb, fptr_copy, FALSE);
-    mrb_free(mrb, fptr_copy);
+    /* If copy shares the same fptr with orig, do not finalize/free it here. */
+    if (fptr_copy != fptr_orig) {
+      /* Detach first so an exception won't leave a dangling DATA_PTR. */
+      DATA_PTR(copy) = NULL;
+      fptr_finalize(mrb, fptr_copy, FALSE);
+      mrb_free(mrb, fptr_copy);
+    }
+    else {
+      DATA_PTR(copy) = NULL;
+    }
   }
   fptr_copy = (struct mrb_io *)mrb_io_alloc(mrb);
-  fptr_orig = io_get_open_fptr(mrb, orig);
 
   DATA_TYPE(copy) = &mrb_io_type;
   DATA_PTR(copy) = fptr_copy;