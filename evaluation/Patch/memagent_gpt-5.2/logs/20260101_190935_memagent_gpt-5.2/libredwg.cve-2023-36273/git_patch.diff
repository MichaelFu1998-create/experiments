diff --git a/src/decode.c b/src/decode.c
index d68d0fcf..6159a47f 100644
--- a/src/decode.c
+++ b/src/decode.c
@@ -6314,9 +6314,16 @@ decode_preR13_auxheader (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)
       decode_preR13_section_chk (SECTION_VX, dat, dwg);
     }
   FIELD_RLx (auxheader_address, 0);
-  if (_obj->auxheader_address < pos
-      || _obj->auxheader_address + 16 > dat->size
-      || _obj->auxheader_address + _obj->auxheader_size > dat->size)
+  /* auxheader_address points to the begin of the AUX header sentinel.
+     auxheader_size is the byte size of the auxheader data after the
+     16-byte sentinel, including the trailing CRC16 (2 bytes).
+     Guard against truncated/crafted files: ensure all computations are
+     bounds-safe and prevent unsigned underflow in (auxheader_size - 2). */
+  if (_obj->auxheader_size < 2
+      || _obj->auxheader_address < pos
+      || (size_t)_obj->auxheader_address > dat->size
+      || (size_t)_obj->auxheader_address > dat->size - 16
+      || (size_t)_obj->auxheader_size > dat->size - ((size_t)_obj->auxheader_address + 16))
     {
       LOG_ERROR ("Invalid auxheader_address %04X", _obj->auxheader_address);
       error |= DWG_ERR_WRONGCRC;
@@ -6329,11 +6336,12 @@ decode_preR13_auxheader (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)
     }
   else
     {
+      const long crc_len = (long)_obj->auxheader_size - 2; /* safe: checked >= 2 */
       crcc = bit_calc_CRC (0xC0C1,
                            // after sentinel (16 bytes)
                            &dat->chain[_obj->auxheader_address + 16],
                            // minus crc length (2 bytes)
-                           _obj->auxheader_size - 2); 
+                           crc_len);
       crc = bit_read_RS (dat);
       LOG_TRACE ("crc: %04X [RSx] from 0x%x-0x%lx\n", crc,
                  _obj->auxheader_address + 16, dat->byte - 2);