diff --git a/libarchive/archive_string.c b/libarchive/archive_string.c
index bd39c96f..dd28a7f2 100644
--- a/libarchive/archive_string.c
+++ b/libarchive/archive_string.c
@@ -793,7 +793,18 @@ archive_string_append_from_wcs(struct archive_string *as,
 	 * We need this allocation here since it is possible that
 	 * as->s is still NULL.
 	 */
-	if (archive_string_ensure(as, as->length + len + 1) == NULL)
+	/*
+	 * Each wide character may expand to up to MB_CUR_MAX bytes in the
+	 * current locale.  Size calculations must be in bytes, not in wide
+	 * characters, otherwise we can under-allocate and overflow when
+	 * writing the final NUL terminator.
+	 */
+	if (len > ((size_t)-1 - as->length - 1) / (size_t)MB_CUR_MAX) {
+		errno = ENOMEM;
+		return (-1);
+	}
+	if (archive_string_ensure(as,
+	    as->length + len * (size_t)MB_CUR_MAX + 1) == NULL)
 		return (-1);
 
 	p = as->s + as->length;
@@ -803,11 +814,18 @@ archive_string_append_from_wcs(struct archive_string *as,
 			as->length = p - as->s;
 			as->s[as->length] = '\0';
 			/* Re-allocate buffer for MBS. */
+			if (len > ((size_t)-1 - as->length - 1) / (size_t)MB_CUR_MAX) {
+				errno = ENOMEM;
+				return (-1);
+			}
 			if (archive_string_ensure(as,
-			    as->length + len * 2 + 1) == NULL)
+			    as->length + len * (size_t)MB_CUR_MAX + 1) == NULL)
 				return (-1);
 			p = as->s + as->length;
 			end = as->s + as->buffer_length - MB_CUR_MAX -1;
+			/* Growth may not be sufficient in edge cases; ensure space. */
+			if (p >= end)
+				continue;
 		}
 #if HAVE_WCRTOMB
 		n = wcrtomb(p, *w++, &shift_state);
@@ -2643,7 +2661,18 @@ strncat_from_utf8_to_utf8(struct archive_string *as, const void *_p,
 
 	(void)sc; /* UNUSED */
 
-	if (archive_string_ensure(as, as->length + len + 1) == NULL)
+	/*
+	 * Each wide character may expand to up to MB_CUR_MAX bytes in the
+	 * current locale.  Size calculations must be in bytes, not in wide
+	 * characters, otherwise we can under-allocate and overflow when
+	 * writing the final NUL terminator.
+	 */
+	if (len > ((size_t)-1 - as->length - 1) / (size_t)MB_CUR_MAX) {
+		errno = ENOMEM;
+		return (-1);
+	}
+	if (archive_string_ensure(as,
+	    as->length + len * (size_t)MB_CUR_MAX + 1) == NULL)
 		return (-1);
 
 	s = (const char *)_p;
@@ -3433,7 +3462,18 @@ strncat_from_utf8_libarchive2(struct archive_string *as,
 	 * We need this allocation here since it is possible that
 	 * as->s is still NULL.
 	 */
-	if (archive_string_ensure(as, as->length + len + 1) == NULL)
+	/*
+	 * Each wide character may expand to up to MB_CUR_MAX bytes in the
+	 * current locale.  Size calculations must be in bytes, not in wide
+	 * characters, otherwise we can under-allocate and overflow when
+	 * writing the final NUL terminator.
+	 */
+	if (len > ((size_t)-1 - as->length - 1) / (size_t)MB_CUR_MAX) {
+		errno = ENOMEM;
+		return (-1);
+	}
+	if (archive_string_ensure(as,
+	    as->length + len * (size_t)MB_CUR_MAX + 1) == NULL)
 		return (-1);
 
 	s = (const char *)_p;
@@ -3445,8 +3485,12 @@ strncat_from_utf8_libarchive2(struct archive_string *as,
 		if (p >= end) {
 			as->length = p - as->s;
 			/* Re-allocate buffer for MBS. */
+			if (len > ((size_t)-1 - as->length - 1) / (size_t)MB_CUR_MAX) {
+				errno = ENOMEM;
+				return (-1);
+			}
 			if (archive_string_ensure(as,
-			    as->length + len * 2 + 1) == NULL)
+			    as->length + len * (size_t)MB_CUR_MAX + 1) == NULL)
 				return (-1);
 			p = as->s + as->length;
 			end = as->s + as->buffer_length - MB_CUR_MAX -1;