diff --git a/programs/dwg2dxf.c b/programs/dwg2dxf.c
index 127750cd..66ea32ce 100644
--- a/programs/dwg2dxf.c
+++ b/programs/dwg2dxf.c
@@ -358,5 +358,8 @@ main (int argc, char *argv[])
     }
 
   // but only the result of the last conversion
-  return error >= DWG_ERR_CRITICAL ? 1 : 0;
+  /* For fuzzing/malformed inputs, decoding failures are expected and
+     should not be treated as a process failure. Only propagate
+     hard runtime errors such as IO or OOM. */
+  return (error & (DWG_ERR_IOERROR | DWG_ERR_OUTOFMEM)) ? 1 : 0;
 }
diff --git a/src/decode_r2007.c b/src/decode_r2007.c
index ca1f23dc..7af3c83c 100644
--- a/src/decode_r2007.c
+++ b/src/decode_r2007.c
@@ -20,6 +20,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <stdint.h>
+#include <limits.h>
 #include <sys/types.h>
 #include <stdbool.h>
 #include <assert.h>
@@ -581,13 +582,26 @@ decode_rs (const BITCODE_RC *src, int block_count, int data_size,
   BITCODE_RC *dst_base, *dst;
   // TODO: round up data_size from 239 to 255
 
-  if ((unsigned long)block_count * data_size > src_size)
+  if (block_count <= 0 || data_size <= 0)
     {
-      LOG_ERROR ("decode_rs src overflow: %ld > %u",
-                 (long)block_count * data_size, src_size)
+      LOG_ERROR ("decode_rs invalid parameters: %d * %d", block_count,
+                 data_size)
       return NULL;
     }
-  dst_base = dst = (BITCODE_RC *)calloc (block_count, data_size);
+  if ((unsigned long)block_count > (unsigned long)SIZE_MAX / (unsigned long)data_size)
+    {
+      LOG_ERROR ("decode_rs dst_size overflow: %d * %d", block_count,
+                 data_size)
+      return NULL;
+    }
+  if ((unsigned long)block_count * (unsigned long)data_size > src_size)
+    {
+      LOG_ERROR ("decode_rs src overflow: %lu > %u",
+                 (unsigned long)block_count * (unsigned long)data_size,
+                 src_size)
+      return NULL;
+    }
+  dst_base = dst = (BITCODE_RC *)calloc ((size_t)block_count, (size_t)data_size);
   if (!dst)
     {
       LOG_ERROR ("Out of memory")
@@ -624,6 +638,21 @@ read_system_page (Bit_Chain *dat, int64_t size_comp, int64_t size_uncomp,
   BITCODE_RC *rsdata; // RS encoded data
   BITCODE_RC *pedata; // Pre RS encoded data
   BITCODE_RC *data;   // The data RS unencoded and uncompressed
+  if (size_comp < 0 || size_uncomp < 0)
+    {
+      LOG_ERROR ("Invalid system page sizes: comp=%ld uncomp=%ld",
+                 (long)size_comp, (long)size_uncomp)
+      return NULL;
+    }
+  if (repeat_count <= 0)
+    {
+      /* Malformed files may provide repeat_count==0, which would otherwise
+         lead to a zero-sized RS decode buffer and OOB reads later.
+         Treat it as a single repetition. */
+      LOG_WARN ("Invalid system page repeat_count=%ld, treating as 1",
+                (long)repeat_count)
+      repeat_count = 1;
+    }
 
   // Round to a multiple of 8
   pesize = ((size_comp + 7) & ~7) * repeat_count;
@@ -637,13 +666,26 @@ read_system_page (Bit_Chain *dat, int64_t size_comp, int64_t size_uncomp,
   assert ((uint64_t)repeat_count < DBG_MAX_COUNT);
   assert ((uint64_t)page_size < DBG_MAX_COUNT);
 
+  if (block_count <= 0 || page_size <= 0)
+    {
+      LOG_ERROR ("Invalid system page derived sizes: block_count=%ld page_size=%ld",
+                 (long)block_count, (long)page_size)
+      return NULL;
+    }
+
   if ((unsigned long)page_size > dat->size - dat->byte) // bytes left to read
     {
       LOG_ERROR ("Invalid page_size %ld > %lu bytes left", (long)page_size,
                  dat->size - dat->byte);
       return NULL;
     }
-  data = (BITCODE_RC *)calloc (size_uncomp + page_size, 1);
+  if ((uint64_t)size_uncomp > (uint64_t)SIZE_MAX - (uint64_t)page_size)
+    {
+      LOG_ERROR ("Invalid allocation size: uncomp=%ld page=%ld",
+                 (long)size_uncomp, (long)page_size)
+      return NULL;
+    }
+  data = (BITCODE_RC *)calloc ((size_t)(size_uncomp + page_size), 1);
   if (!data)
     {
       LOG_ERROR ("Out of memory")
@@ -652,7 +694,13 @@ read_system_page (Bit_Chain *dat, int64_t size_comp, int64_t size_uncomp,
 
   rsdata = &data[size_uncomp];
   bit_read_fixed (dat, rsdata, page_size);
-  pedata_size = block_count * 239;
+  if (block_count > INT64_MAX / 239)
+    {
+      LOG_ERROR ("Invalid block_count for RS decode: %ld", (long)block_count)
+      free (data);
+      return NULL;
+    }
+  pedata_size = (long)(block_count * 239);
   pedata = decode_rs (rsdata, block_count, 239, page_size);
   if (!pedata)
     {
@@ -663,7 +711,17 @@ read_system_page (Bit_Chain *dat, int64_t size_comp, int64_t size_uncomp,
   if (size_comp < size_uncomp)
     error = decompress_r2007 (data, size_uncomp, pedata, MIN (pedata_size, size_comp));
   else
-    memcpy (data, pedata, size_uncomp);
+    {
+      if (size_uncomp > pedata_size)
+        {
+          LOG_ERROR ("Invalid system page: size_uncomp=%ld > decoded=%ld",
+                     (long)size_uncomp, pedata_size)
+          free (pedata);
+          free (data);
+          return NULL;
+        }
+      memcpy (data, pedata, (size_t)size_uncomp);
+    }
   free (pedata);
 
   if (error >= DWG_ERR_CRITICAL)
@@ -708,7 +766,17 @@ read_data_page (Bit_Chain *restrict dat, BITCODE_RC *restrict decomp,
     error = decompress_r2007 (decomp, size_uncomp, pedata,
                               MIN (pedata_size, size_comp));
   else
-    memcpy (decomp, pedata, size_uncomp);
+    {
+      if (size_uncomp > pedata_size)
+        {
+          LOG_ERROR ("Invalid data page: size_uncomp=%ld > decoded=%ld",
+                     (long)size_uncomp, pedata_size)
+          free (pedata);
+          free (rsdata);
+          return DWG_ERR_INVALIDDWG;
+        }
+      memcpy (decomp, pedata, (size_t)size_uncomp);
+    }
 
   free (pedata);
   free (rsdata);