diff --git a/src/hash.c b/src/hash.c
index fc6b6fa6b..708c4d456 100644
--- a/src/hash.c
+++ b/src/hash.c
@@ -1151,6 +1151,8 @@ static mrb_value mrb_hash_default(mrb_state *mrb, mrb_value hash);
 static void
 hash_modify(mrb_state *mrb, mrb_value hash)
 {
+  /* Guard against invalid receivers (e.g. malformed bytecode). */
+  if (!mrb_hash_p(hash)) return;
   mrb_check_frozen(mrb, mrb_hash_ptr(hash));
 }
 
@@ -1239,6 +1241,8 @@ mrb_hash_fetch(mrb_state *mrb, mrb_value hash, mrb_value key, mrb_value def)
 MRB_API void
 mrb_hash_set(mrb_state *mrb, mrb_value hash, mrb_value key, mrb_value val)
 {
+  /* Defensive: ignore if called with non-Hash receiver (corrupt VM/bytecode). */
+  if (!mrb_hash_p(hash)) return;
   hash_modify(mrb, hash);
   key = h_key_for(mrb, key);
   h_set(mrb, mrb_hash_ptr(hash), key, val);
@@ -1729,6 +1733,13 @@ mrb_hash_has_value(mrb_state *mrb, mrb_value hash)
 MRB_API void
 mrb_hash_merge(mrb_state *mrb, mrb_value hash1, mrb_value hash2)
 {
+  /*
+   * hash1 is the receiver. Under malformed bytecode / corrupted VM state it is
+   * possible to reach this internal API with a non-Hash receiver; avoid
+   * dereferencing a fabricated pointer via mrb_hash_ptr().
+   */
+  if (!mrb_hash_p(hash1)) return;
+
   struct RHash *h1, *h2;
 
   hash_modify(mrb, hash1);