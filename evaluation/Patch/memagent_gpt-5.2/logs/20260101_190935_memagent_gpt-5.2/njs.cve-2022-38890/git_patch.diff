diff --git a/src/njs_string.c b/src/njs_string.c
index 83cede5..e312433 100644
--- a/src/njs_string.c
+++ b/src/njs_string.c
@@ -2528,20 +2528,21 @@ done:
 const u_char *
 njs_string_offset(const u_char *start, const u_char *end, size_t index)
 {
-    uint32_t    *map;
     njs_uint_t  skip;
 
-    if (index >= NJS_STRING_MAP_STRIDE) {
-        map = njs_string_map_start(end);
-
-        if (map[0] == 0) {
-            njs_string_offset_map_init(start, end - start);
-        }
-
-        start += map[index / NJS_STRING_MAP_STRIDE - 1];
-    }
+    /*
+     * Historically, this function could use an optional UTF-8 offset map stored
+     * after the string data for O(1) skipping.
+     *
+     * However, not all strings guarantee presence/validity of that map.  When
+     * the map is absent or uninitialized, reading it may access unallocated or
+     * poisoned memory and then compute a wild pointer, leading to a crash in
+     * njs_utf8_next().
+     *
+     * For safety, fall back to linear UTF-8 stepping bounded by "end".
+     */
 
-    for (skip = index % NJS_STRING_MAP_STRIDE; skip != 0; skip--) {
+    for (skip = index; skip != 0 && start < end; skip--) {
         start = njs_utf8_next(start, end);
     }
 
@@ -2556,37 +2557,23 @@ njs_string_offset(const u_char *start, const u_char *end, size_t index)
 uint32_t
 njs_string_index(njs_string_prop_t *string, uint32_t offset)
 {
-    uint32_t      *map, last, index;
+    uint32_t      index;
     const u_char  *p, *start, *end;
 
     if (string->size == string->length) {
         return offset;
     }
 
-    last = 0;
-    index = 0;
-
-    if (string->length > NJS_STRING_MAP_STRIDE) {
-
-        end = string->start + string->size;
-        map = njs_string_map_start(end);
-
-        if (map[0] == 0) {
-            njs_string_offset_map_init(string->start, string->size);
-        }
-
-        while (index + NJS_STRING_MAP_STRIDE < string->length
-               && *map <= offset)
-        {
-            last = *map++;
-            index += NJS_STRING_MAP_STRIDE;
-        }
+    if (offset > string->size) {
+        offset = string->size;
     }
 
-    p = string->start + last;
+    p = string->start;
     start = string->start + offset;
     end = string->start + string->size;
 
+    index = 0;
+
     while (p < start) {
         index++;
         p = njs_utf8_next(p, end);
diff --git a/src/njs_utf8.h b/src/njs_utf8.h
index 26c23db..5fc4562 100644
--- a/src/njs_utf8.h
+++ b/src/njs_utf8.h
@@ -7,6 +7,8 @@
 #ifndef _NJS_UTF8_H_INCLUDED_
 #define _NJS_UTF8_H_INCLUDED_
 
+#include <stdint.h>
+
 
 NJS_EXPORT uint32_t njs_utf8_decode(njs_unicode_decode_t *ctx,
     const u_char **data, const u_char *end);
@@ -49,11 +51,23 @@ njs_utf8_next(const u_char *p, const u_char *end)
 {
     u_char  c;
 
+    /*
+     * njs_utf8_next() historically assumed valid UTF-8 and that "p" points
+     * inside the [start, end) range.
+     *
+     * Some higher-level string routines may call it with an out-of-range
+     * pointer when string metadata is inconsistent (e.g. missing/invalid UTF-8
+     * offset map).  Avoid out-of-bounds reads and just clamp to "end".
+     */
+    if (p == NULL || end == NULL || (uintptr_t) p >= (uintptr_t) end) {
+        return end;
+    }
+
     c = *p++;
 
     if ((c & 0x80) != 0) {
 
-        do {
+        while ((uintptr_t) p < (uintptr_t) end) {
             c = *p;
 
             if ((c & 0xC0) != 0x80) {
@@ -61,8 +75,7 @@ njs_utf8_next(const u_char *p, const u_char *end)
             }
 
             p++;
-
-        } while (p < end);
+        }
     }
 
     return p;