diff --git a/mrbgems/mruby-fiber/src/fiber.c b/mrbgems/mruby-fiber/src/fiber.c
index 83153a9d..6bd2a388 100644
--- a/mrbgems/mruby-fiber/src/fiber.c
+++ b/mrbgems/mruby-fiber/src/fiber.c
@@ -2,6 +2,7 @@
 #include <mruby/array.h>
 #include <mruby/class.h>
 #include <mruby/proc.h>
+#include <limits.h>
 
 #define fiber_ptr(o) ((struct RFiber*)mrb_ptr(o))
 
@@ -201,9 +202,26 @@ fiber_switch(mrb_state *mrb, mrb_value self, mrb_int len, const mrb_value *a, mr
   if (c->status == MRB_FIBER_CREATED) {
     mrb_value *b, *e;
 
-    if (len >= c->stend - c->stack) {
+    /*
+     * Fiber#resume can pass arbitrary number of arguments.
+     * OP_ENTER uses argc-based indices like regs[argc+1] and regs[len+1],
+     * so the fiber stack must have at least (len+2) slots available on entry.
+     *
+     * The main VM grows the stack dynamically; do the same for fiber context.
+     */
+    if (len > (mrb_int)INT_MAX - 2) {
       mrb_raise(mrb, E_FIBER_ERROR, "too many arguments to fiber");
     }
+    {
+      int room = (int)len + 2;
+
+      if (c->stack + room >= c->stend) {
+        /* mrb_stack_extend() works on mrb->c; temporarily switch. */
+        mrb->c = c;
+        mrb_stack_extend(mrb, room);
+        mrb->c = old_c;
+      }
+    }
     b = c->stack+1;
     e = b + len;
     while (b<e) {