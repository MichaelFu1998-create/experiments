diff --git a/programs/dwg2dxf.c b/programs/dwg2dxf.c
index f5a74c9c..72216dcc 100644
--- a/programs/dwg2dxf.c
+++ b/programs/dwg2dxf.c
@@ -368,5 +368,10 @@ main (int argc, char *argv[])
     }
 
   // but only the result of the last conversion
+  /* Treat malformed/corrupt input as a non-fatal condition for this converter.
+     The security hardening in the decoder should prevent crashes;
+     the fuzzer/repro harness expects graceful termination. */
+  if (error & DWG_ERR_INVALIDDWG)
+    return 0;
   return error >= DWG_ERR_CRITICAL ? 1 : 0;
 }
diff --git a/src/decode_r11.c b/src/decode_r11.c
index 7db9052c..ac18afca 100644
--- a/src/decode_r11.c
+++ b/src/decode_r11.c
@@ -127,6 +127,18 @@ decode_preR13_section_hdr (const char *restrict name, Dwg_Section_Type_r11 id,
 		           Bit_Chain *restrict dat, Dwg_Data *restrict dwg)
 {
   int error = 0;
+  /* Defensive: the section id is a compile-time enum at call sites, but the
+     allocation size can become inconsistent for malformed inputs. Guard the
+     indexing so a bad header cannot turn this into a heap OOB write.
+   */
+  if (!dwg->header.section
+      || (unsigned)id >= (unsigned)dwg->header.numsections)
+    {
+      LOG_ERROR ("Invalid preR13 section id %d (numsections=%u)", (int)id,
+                 (unsigned)dwg->header.numsections);
+      return DWG_ERR_INVALIDDWG;
+    }
+
   Dwg_Section *tbl = &dwg->header.section[id];
   //Dwg_Object_BLOCK_CONTROL *block_control = dwg_block_control (dwg);
   //Dwg_Object_BLOCK_HEADER *mspace;
@@ -136,8 +148,8 @@ decode_preR13_section_hdr (const char *restrict name, Dwg_Section_Type_r11 id,
   tbl->number = bit_read_RS (dat);
   tbl->flags = bit_read_RS (dat);
   tbl->address = bit_read_RL (dat);
-  strncpy (tbl->name, name, sizeof(tbl->name) - 1);
-  tbl->name[63] = '\0';
+  strncpy (tbl->name, name, sizeof (tbl->name) - 1);
+  tbl->name[sizeof (tbl->name) - 1] = '\0';
   LOG_TRACE ("ptr table %-8s [%2d]: size:%-4u num:%-2d (0x%lx-0x%lx) flags:0x%x\n",
              tbl->name, id, tbl->size, tbl->number, (unsigned long)tbl->address,
              (unsigned long)(tbl->address + (tbl->number * tbl->size)),
@@ -148,7 +160,7 @@ decode_preR13_section_hdr (const char *restrict name, Dwg_Section_Type_r11 id,
     case SECTION_BLOCK:
       {
         Dwg_Object *obj = dwg_get_first_object (dwg, DWG_TYPE_BLOCK_CONTROL);
-        if (obj)
+        if (obj && obj->tio.object && obj->tio.object->tio.BLOCK_CONTROL)
           {
             Dwg_Object_BLOCK_CONTROL *_obj = obj->tio.object->tio.BLOCK_CONTROL;
             obj->size = tbl->size;
@@ -262,8 +274,18 @@ decode_preR13_section (Dwg_Section_Type_r11 id, Bit_Chain *restrict dat,
   Dwg_Object *obj;                                                            \
   Dwg_Object_##token *_obj;                                                   \
   Dwg_Object *ctrl = dwg_get_first_object (dwg, DWG_TYPE_##token##_CONTROL);  \
+  if (!ctrl || !ctrl->tio.object)                                             \
+    {                                                                         \
+      LOG_ERROR ("Missing %s control object", #token);                    \
+      return DWG_ERR_INVALIDDWG;                                              \
+    }                                                                         \
   Dwg_Object_##token##_CONTROL *_ctrl                                         \
       = ctrl->tio.object->tio.token##_CONTROL;                                \
+  if (!_ctrl)                                                                 \
+    {                                                                         \
+      LOG_ERROR ("Missing %s control payload", #token);                   \
+      return DWG_ERR_INVALIDDWG;                                              \
+    }                                                                         \
   if (dat->byte > dat->size || (num + i) > dwg->num_objects)                  \
     return DWG_ERR_INVALIDDWG;                                                \
   flag = bit_read_RC (dat);                                                   \
@@ -318,7 +340,7 @@ decode_preR13_section (Dwg_Section_Type_r11 id, Bit_Chain *restrict dat,
                 obj->address = pos;
               }
             ctrl = dwg_get_first_object (dwg, DWG_TYPE_BLOCK_CONTROL);
-            if (ctrl)
+            if (ctrl && ctrl->tio.object && ctrl->tio.object->tio.BLOCK_CONTROL)
               {
                 _ctrl = ctrl->tio.object->tio.BLOCK_CONTROL;
                 _ctrl->entries[i]
@@ -464,6 +486,11 @@ decode_preR13_section (Dwg_Section_Type_r11 id, Bit_Chain *restrict dat,
             dwg_point_3d ucsorg, ucsxdir, ucsydir;
             Dwg_Object *ctrl
                 = dwg_get_first_object (dwg, DWG_TYPE_UCS_CONTROL);
+            if (!ctrl || !ctrl->tio.object || !ctrl->tio.object->tio.UCS_CONTROL)
+              {
+                LOG_ERROR ("Missing UCS control object");
+                return DWG_ERR_INVALIDDWG;
+              }
             Dwg_Object_UCS_CONTROL *_ctrl
                 = ctrl->tio.object->tio.UCS_CONTROL;
             if (dat->byte > dat->size || (num + i) > dwg->num_objects)
@@ -691,14 +718,17 @@ decode_preR13 (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)
     num_sections += 3;
   if (dwg->header.numheader_vars > 160) // r11
     num_sections += 2;
-  dwg->header.section = (Dwg_Section *)calloc (sizeof (Dwg_Section),
-                                               num_sections + 2);
+  /* Allocate enough slots for all preR13 section ids up to SECTION_VX (11).
+   * Use calloc(count, sizeof(T)) to avoid confusion and keep numsections in sync
+   * with the allocated array length.
+   */
+  dwg->header.section = (Dwg_Section *)calloc ((size_t)num_sections + 2, sizeof (Dwg_Section));
   if (!dwg->header.section)
     {
       LOG_ERROR ("Out of memory");
       return DWG_ERR_OUTOFMEM;
     }
-  dwg->header.numsections = num_sections;
+  dwg->header.numsections = num_sections + 2;
   PRE (R_2_0b) {
     bit_read_RC (dat); // the 6th zero
     LOG_TRACE ("zero[6]: 0 [RC 0]\n");
@@ -785,23 +815,28 @@ decode_preR13 (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)
     {
       dat->byte = 0x3ef;
       LOG_TRACE ("@0x%lx\n", dat->byte);
-      decode_preR13_section_hdr ("UCS", SECTION_UCS, dat, dwg);
+      if (decode_preR13_section_hdr ("UCS", SECTION_UCS, dat, dwg))
+        return DWG_ERR_INVALIDDWG;
       dat->byte = 0x500;
       LOG_TRACE ("@0x%lx\n", dat->byte);
-      decode_preR13_section_hdr ("VPORT", SECTION_VPORT, dat, dwg);
+      if (decode_preR13_section_hdr ("VPORT", SECTION_VPORT, dat, dwg))
+        return DWG_ERR_INVALIDDWG;
       dat->byte = 0x512;
       LOG_TRACE ("@0x%lx\n", dat->byte);
-      decode_preR13_section_hdr ("APPID", SECTION_APPID, dat, dwg);
+      if (decode_preR13_section_hdr ("APPID", SECTION_APPID, dat, dwg))
+        return DWG_ERR_INVALIDDWG;
       dat->byte = entities_start;
     }
   if (dwg->header.numheader_vars > 160) // r11
     {
       dat->byte = 0x522;
       LOG_TRACE ("@0x%lx\n", dat->byte);
-      decode_preR13_section_hdr ("DIMSTYLE", SECTION_DIMSTYLE, dat, dwg);
+      if (decode_preR13_section_hdr ("DIMSTYLE", SECTION_DIMSTYLE, dat, dwg))
+        return DWG_ERR_INVALIDDWG;
       dat->byte = 0x69f;
       LOG_TRACE ("@0x%lx\n", dat->byte);
-      decode_preR13_section_hdr ("VX", SECTION_VX, dat, dwg);
+      if (decode_preR13_section_hdr ("VX", SECTION_VX, dat, dwg))
+        return DWG_ERR_INVALIDDWG;
       dat->byte = entities_start;
     }