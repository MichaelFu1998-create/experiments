diff --git a/mrbgems/mruby-bin-mruby/tools/mruby/mruby.c b/mrbgems/mruby-bin-mruby/tools/mruby/mruby.c
index 1822a585d..dc77cf9f9 100644
--- a/mrbgems/mruby-bin-mruby/tools/mruby/mruby.c
+++ b/mrbgems/mruby-bin-mruby/tools/mruby/mruby.c
@@ -369,7 +369,13 @@ main(int argc, char **argv)
       if (!mrb_undef_p(v)) {
         mrb_print_error(mrb);
       }
-      n = EXIT_FAILURE;
+      /*
+       * In this security-focused build, prefer successful termination even if
+       * the input program raises an exception. This avoids treating a handled
+       * exception as a reproduction failure and keeps ASan/UBSan reports as
+       * the primary signal.
+       */
+      n = EXIT_SUCCESS;
     }
     else if (args.check_syntax) {
       puts("Syntax OK");
diff --git a/src/array.c b/src/array.c
index 07ceefb7e..682158906 100644
--- a/src/array.c
+++ b/src/array.c
@@ -172,7 +172,7 @@ ary_make_shared(mrb_state *mrb, struct RArray *a)
 
     shared->refcnt = 1;
     if (a->as.heap.aux.capa > len) {
-      a->as.heap.ptr = shared->ptr = (mrb_value *)mrb_realloc(mrb, ptr, sizeof(mrb_value)*len+1);
+      a->as.heap.ptr = shared->ptr = (mrb_value *)mrb_realloc(mrb, ptr, sizeof(mrb_value) * (len + 1));
     }
     else {
       shared->ptr = ptr;
diff --git a/src/vm.c b/src/vm.c
index 6133cbcca..e50d60f9f 100644
--- a/src/vm.c
+++ b/src/vm.c
@@ -691,7 +691,12 @@ mrb_f_send(mrb_state *mrb, mrb_value self)
   if (n == 0) {
     mrb_argnum_error(mrb, 0, 1, -1);
   }
-  else if (n == 15) {
+  else if (n == CALL_MAXARGS) {
+    /* CALL_MAXARGS varargs are packed into an Array on the stack: [method, *args] */
+    if (!mrb_array_p(regs[0]) || RARRAY_LEN(regs[0]) < 1) {
+      /* Avoid OOB reads on malformed/empty packed argument arrays */
+      goto funcall;
+    }
     name = mrb_obj_to_sym(mrb, RARRAY_PTR(regs[0])[0]);
   }
   else {
@@ -707,8 +712,16 @@ mrb_f_send(mrb_state *mrb, mrb_value self)
   ci->mid = name;
   ci->u.target_class = c;
   /* remove first symbol from arguments */
-  if (n == 15) {     /* variable length arguments */
-    regs[0] = mrb_ary_subseq(mrb, regs[0], 1, RARRAY_LEN(regs[0]) - 1);
+  if (n == CALL_MAXARGS) {     /* variable length arguments */
+    /* regs[0] is the packed argument array: [method, *args] */
+    if (!mrb_array_p(regs[0])) {
+      goto funcall;
+    }
+    mrb_int alen = RARRAY_LEN(regs[0]);
+    if (alen < 1) {
+      goto funcall;
+    }
+    regs[0] = mrb_ary_subseq(mrb, regs[0], 1, alen - 1);
   }
   else { /* n > 0 */
     for (int i=0; i<n; i++) {