diff --git a/libheif/pixelimage.cc b/libheif/pixelimage.cc
index 480b344..7c12605 100644
--- a/libheif/pixelimage.cc
+++ b/libheif/pixelimage.cc
@@ -144,13 +144,23 @@ static uint32_t rounded_size(uint32_t s)
 bool HeifPixelImage::add_plane(heif_channel channel, int width, int height, int bit_depth)
 {
   ImagePlane plane;
-  if (plane.alloc(width, height, bit_depth, m_chroma)) {
-    m_planes.insert(std::make_pair(channel, plane));
-    return true;
+  if (!plane.alloc(width, height, bit_depth, m_chroma)) {
+    return false;
+  }
+
+  // m_planes.insert() does not replace an existing plane. If the same channel is
+  // added multiple times (e.g. malformed component lists), we must not leak the
+  // newly allocated plane.
+  auto iter = m_planes.find(channel);
+  if (iter != m_planes.end()) {
+    delete[] iter->second.allocated_mem;
+    iter->second = plane;
   }
   else {
-    return false;
+    m_planes.insert(std::make_pair(channel, plane));
   }
+
+  return true;
 }
 
 
diff --git a/libheif/uncompressed_image.cc b/libheif/uncompressed_image.cc
index 5218165..a1a90d5 100644
--- a/libheif/uncompressed_image.cc
+++ b/libheif/uncompressed_image.cc
@@ -582,13 +582,21 @@ static long unsigned int get_tile_base_offset(uint32_t col, uint32_t row, const
 {
   uint32_t numTileColumns = uncC->get_number_of_tile_columns();
   uint32_t numTileRows = uncC->get_number_of_tile_rows();
+
+  // Avoid division-by-zero on malformed input. decode_uncompressed_image() should
+  // reject this earlier, but keep this helper robust as it is used in other paths.
+  if (numTileColumns == 0 || numTileRows == 0) {
+    return 0;
+  }
+
   uint32_t tile_width = width / numTileColumns;
   uint32_t tile_height = height / numTileRows;
   long unsigned int content_bytes_per_tile = tile_width * tile_height * get_bytes_per_pixel(uncC);
   uint32_t tile_align_size = uncC->get_tile_align_size();
   long unsigned int tile_padding = 0;
   if (tile_align_size > 0) {
-    tile_padding = tile_align_size - (content_bytes_per_tile % tile_align_size);
+    // If content size is already aligned, padding must be 0.
+    tile_padding = (tile_align_size - (content_bytes_per_tile % tile_align_size)) % tile_align_size;
   }
   long unsigned int bytes_per_tile = content_bytes_per_tile + tile_padding;
   uint32_t tile_idx_y = row / tile_height;
@@ -723,27 +731,93 @@ Error UncompressedImageCodec::decode_uncompressed_image(const std::shared_ptr<co
     componentOffset++;
   }
 
+  // Robustness: some malformed files may declare an uncompressed image item but provide
+  // no payload bytes. Older code would call memcpy() with uncompressed_data.data()==NULL
+  // and a non-zero length, crashing. Instead, decode to an all-zero image.
+  if (uncompressed_data.empty()) {
+    for (auto ch : channels) {
+      int stride = 0;
+      uint8_t* dst = img->get_plane(ch, &stride);
+      if (dst == nullptr) {
+        return Error(heif_error_Invalid_input,
+                     heif_suberror_Nonexisting_image_channel_referenced,
+                     "Missing destination plane");
+      }
+      // memset the full plane (stride may include padding).
+      std::memset(dst, 0, static_cast<size_t>(stride) * static_cast<size_t>(height));
+    }
+    return Error::Ok;
+  }
+
   // TODO: properly interpret uncompressed_data per uncC config, subsampling etc.
-  uint32_t bytes_per_channel = width * height;
+  const size_t uncompressed_size = uncompressed_data.size();
+  size_t bytes_per_channel = static_cast<size_t>(width) * static_cast<size_t>(height);
   uint32_t numTileColumns = uncC->get_number_of_tile_columns();
   uint32_t numTileRows = uncC->get_number_of_tile_rows();
+
+  // Robustness against malformed tiling metadata (would otherwise divide by 0).
+  if (numTileColumns == 0 || numTileRows == 0) {
+    return Error(heif_error_Invalid_input,
+                 heif_suberror_Invalid_grid_data,
+                 "Invalid tiling configuration (0 tile rows/columns)");
+  }
+
+  // Reject nonsensical tiling (would yield tile_width/tile_height == 0).
+  if (numTileColumns > width || numTileRows > height) {
+    return Error(heif_error_Invalid_input,
+                 heif_suberror_Invalid_grid_data,
+                 "Invalid tiling configuration (tile grid larger than image)");
+  }
+
   uint32_t tile_width = width / numTileColumns;
   uint32_t tile_height = height / numTileRows;
+  if (tile_width == 0 || tile_height == 0) {
+    return Error(heif_error_Invalid_input,
+                 heif_suberror_Invalid_grid_data,
+                 "Invalid tiling configuration (zero tile dimension)");
+  }
+
+  // Helper for bounds-checking reads from uncompressed_data.
+  auto check_src_range = [&](size_t offset, size_t len) -> bool {
+    return offset <= uncompressed_size && len <= (uncompressed_size - offset);
+  };
   if (uncC->get_interleave_type() == interleave_type_component) {
     // Source is planar
     // TODO: assumes 8 bits
-    long unsigned int content_bytes_per_tile = tile_width * tile_height * get_bytes_per_pixel(uncC);
+    const size_t bytes_per_pixel = get_bytes_per_pixel(uncC);
+    const size_t content_bytes_per_tile = static_cast<size_t>(tile_width) * static_cast<size_t>(tile_height) * bytes_per_pixel;
     uint32_t tile_align_size = uncC->get_tile_align_size();
-    long unsigned int tile_padding = 0;
+    size_t tile_padding = 0;
     if (tile_align_size > 0) {
-      tile_padding = tile_align_size - (content_bytes_per_tile % tile_align_size);
+      tile_padding = (tile_align_size - (content_bytes_per_tile % tile_align_size)) % tile_align_size;
     };
-    long unsigned int bytes_per_tile = content_bytes_per_tile + tile_padding;
+    const size_t bytes_per_tile = content_bytes_per_tile + tile_padding;
+    const size_t num_tiles = static_cast<size_t>(numTileColumns) * static_cast<size_t>(numTileRows);
+    if (num_tiles > 0 && bytes_per_tile > 0) {
+      // Quick coarse check to reject clearly too-small payloads.
+      const size_t min_required = num_tiles * bytes_per_tile;
+      if (uncompressed_size < min_required) {
+        return Error(heif_error_Invalid_input,
+                     heif_suberror_End_of_data,
+                     "Uncompressed image payload is smaller than expected for tiling configuration");
+      }
+    }
     for (uint32_t c = 0; c < channels.size(); c++) {
       int stride;
       uint8_t* dst = img->get_plane(channels[c], &stride);
+      if (dst == nullptr) {
+        return Error(heif_error_Invalid_input,
+                     heif_suberror_Nonexisting_image_channel_referenced,
+                     "Missing destination plane");
+      }
       if ((numTileRows == 1) && (numTileColumns == 1) && (((uint32_t) stride) == width)) {
-        memcpy(dst, uncompressed_data.data() + c * bytes_per_channel, bytes_per_channel);
+        const size_t src_offset = static_cast<size_t>(c) * bytes_per_channel;
+        if (!check_src_range(src_offset, bytes_per_channel)) {
+          return Error(heif_error_Invalid_input,
+                       heif_suberror_End_of_data,
+                       "Uncompressed image payload too small");
+        }
+        memcpy(dst, uncompressed_data.data() + src_offset, bytes_per_channel);
       }
       else {
         int pixel_offset = channel_to_pixelOffset[channels[c]];
@@ -755,7 +829,16 @@ Error UncompressedImageCodec::decode_uncompressed_image(const std::shared_ptr<co
             long unsigned int tile_base_offset = tile_idx * bytes_per_tile;
             long unsigned int src_offset = tile_base_offset + pixel_offset * tile_width * tile_height;
             long unsigned int dst_offset = row * stride + col;
-            memcpy(dst + dst_offset, uncompressed_data.data() + src_offset /** + row * tile_width **/, tile_width);   // TODO: ** is a hack
+            // Within a tile, component planes are laid out consecutively.
+            // Add the row offset within the tile to avoid repeatedly copying the first row.
+            const uint32_t tile_row_idx = row % tile_height;
+            const size_t checked_src_offset = static_cast<size_t>(src_offset) + static_cast<size_t>(tile_row_idx) * static_cast<size_t>(tile_width);
+            if (!check_src_range(checked_src_offset, tile_width)) {
+              return Error(heif_error_Invalid_input,
+                           heif_suberror_End_of_data,
+                           "Uncompressed image payload too small (tiled component data)");
+            }
+            memcpy(dst + dst_offset, uncompressed_data.data() + checked_src_offset, tile_width);
           }
         }
       }
@@ -771,6 +854,11 @@ Error UncompressedImageCodec::decode_uncompressed_image(const std::shared_ptr<co
       int pixel_offset = channel_to_pixelOffset[channels[c]];
       int stride;
       uint8_t* dst = img->get_plane(channels[c], &stride);
+      if (dst == nullptr) {
+        return Error(heif_error_Invalid_input,
+                     heif_suberror_Nonexisting_image_channel_referenced,
+                     "Missing destination plane");
+      }
       for (uint32_t row = 0; row < height; row++) {
         long unsigned int tile_row_idx = row % tile_height;
         size_t tile_row_offset = tile_width * tile_row_idx * channels.size();
@@ -781,6 +869,11 @@ Error UncompressedImageCodec::decode_uncompressed_image(const std::shared_ptr<co
           size_t tile_offset = tile_row_offset + tile_col * pixel_stride + pixel_offset;
           size_t src_offset = tile_base_offset + tile_offset;
           uint32_t dstPixelIndex = row * stride + col;
+          if (!check_src_range(src_offset, 1)) {
+            return Error(heif_error_Invalid_input,
+                         heif_suberror_End_of_data,
+                         "Uncompressed image payload too small (pixel interleave)");
+          }
           dst[dstPixelIndex] = src[src_offset];
         }
         for (; col < (uint32_t) stride; col++) {
@@ -798,6 +891,11 @@ Error UncompressedImageCodec::decode_uncompressed_image(const std::shared_ptr<co
       int pixel_offset = channel_to_pixelOffset[channels[c]];
       int stride;
       uint8_t* dst = img->get_plane(channels[c], &stride);
+      if (dst == nullptr) {
+        return Error(heif_error_Invalid_input,
+                     heif_suberror_Nonexisting_image_channel_referenced,
+                     "Missing destination plane");
+      }
       for (uint32_t row = 0; row < height; row++) {
         long unsigned int tile_row_idx = row % tile_height;
         size_t tile_row_offset = tile_width * (tile_row_idx * channels.size() + pixel_offset);
@@ -808,6 +906,11 @@ Error UncompressedImageCodec::decode_uncompressed_image(const std::shared_ptr<co
           size_t tile_offset = tile_row_offset + tile_col;
           size_t src_offset = tile_base_offset + tile_offset;
           uint32_t dst_offset = row * stride + col;
+          if (!check_src_range(src_offset, tile_width)) {
+            return Error(heif_error_Invalid_input,
+                         heif_suberror_End_of_data,
+                         "Uncompressed image payload too small (row interleave)");
+          }
           memcpy(dst + dst_offset, uncompressed_data.data() + src_offset, tile_width);
         }
         for (; col < (uint32_t) stride; col++) {