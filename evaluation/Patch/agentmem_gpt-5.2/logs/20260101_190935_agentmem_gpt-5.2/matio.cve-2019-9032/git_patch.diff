diff --git a/src/inflate.c b/src/inflate.c
index 85a5348..5dffe02 100644
--- a/src/inflate.c
+++ b/src/inflate.c
@@ -383,6 +383,16 @@ InflateDimensions(mat_t *mat, matvar_t *matvar, void *buf)
         Mat_Critical("InflateDimensions: Reading dimensions expected type MAT_T_INT32");
         return bytesread;
     }
+
+    /* tag[1] is the size in bytes of the dimensions array (4*rank).
+     * All current call sites pass a 16*uint32 buffer (64 bytes), i.e. 8 bytes
+     * tag + up to 56 bytes dimension data. Guard to avoid overwriting buf.
+     */
+    if ( tag[1] < 0 || (tag[1] % 4) != 0 || tag[1] > 56 ) {
+        Mat_Critical("InflateDimensions: Invalid dimensions byte count %d", tag[1]);
+        return bytesread;
+    }
+
     rank = tag[1];
     if ( rank % 8 != 0 )
         i = 8-(rank %8);
diff --git a/src/mat.c b/src/mat.c
index a0bc257..08e0873 100644
--- a/src/mat.c
+++ b/src/mat.c
@@ -30,6 +30,7 @@
 
 /* FIXME: Implement Unicode support */
 #include <stdlib.h>
+#include <stdint.h>
 #include <string.h>
 #include <stdio.h>
 #include <math.h>
@@ -1360,6 +1361,23 @@ Mat_VarDuplicate(const matvar_t *in, int opt)
  * @ingroup MAT
  * @param matvar Pointer to the matvar_t structure
  */
+
+static int
+matio_ptr_is_plausible_free_ptr(const void *p)
+{
+    uintptr_t v = (uintptr_t)p;
+    if ( v == 0 )
+        return 0;
+    /* malloc pointers should be pointer-aligned */
+    if ( (v % sizeof(void*)) != 0 )
+        return 0;
+    /* reject very small addresses (NULL page / low memory) */
+    if ( v < 4096 )
+        return 0;
+    return 1;
+}
+
+
 void
 Mat_VarFree(matvar_t *matvar)
 {
@@ -1470,9 +1488,22 @@ Mat_VarFree(matvar_t *matvar)
             else if ( (matvar->internal->data != NULL) && matvar->isComplex ) {
                 mat_complex_split_t *complex_data =
                     (mat_complex_split_t*)matvar->internal->data;
-                free(complex_data->Re);
-                free(complex_data->Im);
-                free(complex_data);
+                /* Parsing of malformed files may leave corrupted pointers in internal->data.
+                 * Avoid crashing in cleanup if those pointers are clearly invalid.
+                 */
+                if ( !matio_ptr_is_plausible_free_ptr(complex_data) ) {
+                    Mat_Critical("Mat_VarFree: invalid complex internal->data pointer");
+                } else {
+                    if ( matio_ptr_is_plausible_free_ptr(complex_data->Re) )
+                        free(complex_data->Re);
+                    else
+                        Mat_Critical("Mat_VarFree: invalid complex Re pointer");
+                    if ( matio_ptr_is_plausible_free_ptr(complex_data->Im) )
+                        free(complex_data->Im);
+                    else
+                        Mat_Critical("Mat_VarFree: invalid complex Im pointer");
+                    free(complex_data);
+                }
             } else if ( NULL != matvar->internal->data ) {
                 free(matvar->internal->data);
             }
diff --git a/src/mat5.c b/src/mat5.c
index 2841b58..109b47d 100644
--- a/src/mat5.c
+++ b/src/mat5.c
@@ -34,6 +34,7 @@
 #include <string.h>
 #include <stdio.h>
 #include <math.h>
+#include <limits.h>
 #include <time.h>
 #if defined(_MSC_VER) || defined(__MINGW32__)
 #   define SIZE_T_FMTSTR "Iu"
@@ -53,6 +54,24 @@
 
 static mat_complex_split_t null_complex_data = {NULL,NULL};
 
+
+/* File-controlled size computations need overflow checks */
+static int
+matio_size_mul_overflow(size_t a, size_t b, size_t *out)
+{
+    if ( out == NULL )
+        return 1;
+    if ( a == 0 || b == 0 ) {
+        *out = 0;
+        return 0;
+    }
+    if ( a > SIZE_MAX / b )
+        return 1;
+    *out = a * b;
+    return 0;
+}
+
+
 /*===========================================================================
  *  Private functions
  *===========================================================================
@@ -1199,11 +1218,19 @@ ReadNextCell( mat_t *mat, matvar_t *matvar )
     int j;
     matvar_t **cells = NULL;
 
-    for ( j = 0; j < matvar->rank; j++ )
-        ncells *= matvar->dims[j];
+    for ( j = 0; j < matvar->rank; j++ ) {
+        if ( matio_size_mul_overflow(ncells, matvar->dims[j], &ncells) ) {
+            Mat_Critical("Cell element count overflow");
+            return bytesread;
+        }
+    }
     matvar->data_size = sizeof(matvar_t *);
+    if ( ncells != 0 && (size_t)matvar->data_size > SIZE_MAX / ncells ) {
+        Mat_Critical("Cell allocation overflow");
+        return bytesread;
+    }
     matvar->nbytes    = ncells*matvar->data_size;
-    matvar->data      = calloc(ncells, matvar->data_size);
+    matvar->data      = calloc(ncells, (size_t)matvar->data_size);
     if ( NULL == matvar->data ) {
         if ( NULL != matvar->name )
             Mat_Critical("Couldn't allocate memory for %s->data", matvar->name);
@@ -1484,8 +1511,12 @@ ReadNextStructField( mat_t *mat, matvar_t *matvar )
     size_t bytesread = 0, nfields, nmemb = 1, i;
     matvar_t **fields = NULL;
 
-    for ( j = 0; j < matvar->rank; j++ )
-        nmemb *= matvar->dims[j];
+    for ( j = 0; j < matvar->rank; j++ ) {
+        if ( matio_size_mul_overflow(nmemb, matvar->dims[j], &nmemb) ) {
+            Mat_Critical("Struct element count overflow");
+            return bytesread;
+        }
+    }
 
     if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {
 #if defined(HAVE_ZLIB)
@@ -1543,11 +1574,18 @@ ReadNextStructField( mat_t *mat, matvar_t *matvar )
             matvar->internal->fieldnames = NULL;
         }
 
-        matvar->nbytes = nmemb*nfields*matvar->data_size;
-        if ( !matvar->nbytes )
-            return bytesread;
-
-        matvar->data = calloc(nmemb*nfields, matvar->data_size);
+        {
+            size_t total_elems;
+            if ( matio_size_mul_overflow(nmemb, nfields, &total_elems) ||
+                 (total_elems != 0 && (size_t)matvar->data_size > SIZE_MAX / total_elems) ) {
+                Mat_Critical("Struct allocation overflow");
+                return bytesread;
+            }
+            matvar->nbytes = total_elems * (size_t)matvar->data_size;
+            if ( !matvar->nbytes )
+                return bytesread;
+            matvar->data = calloc(total_elems, (size_t)matvar->data_size);
+        }
         if ( NULL == matvar->data ) {
             Mat_Critical("Couldn't allocate memory for the data");
             return bytesread;
@@ -1725,11 +1763,18 @@ ReadNextStructField( mat_t *mat, matvar_t *matvar )
             bytesread+=8-((nfields*fieldname_size) % 8);
         }
 
-        matvar->nbytes = nmemb*nfields*matvar->data_size;
-        if ( !matvar->nbytes )
-            return bytesread;
-
-        matvar->data = malloc(matvar->nbytes);
+        {
+            size_t total_elems;
+            if ( matio_size_mul_overflow(nmemb, nfields, &total_elems) ||
+                 (total_elems != 0 && (size_t)matvar->data_size > SIZE_MAX / total_elems) ) {
+                Mat_Critical("Struct allocation overflow");
+                return bytesread;
+            }
+            matvar->nbytes = total_elems * (size_t)matvar->data_size;
+            if ( !matvar->nbytes )
+                return bytesread;
+            matvar->data = malloc(matvar->nbytes);
+        }
         if ( NULL == matvar->data )
             return bytesread;
 
@@ -5647,9 +5692,37 @@ Mat_VarReadNextInfo5( mat_t *mat )
                 /* Rank and dimension */
                 if ( uncomp_buf[0] == MAT_T_INT32 ) {
                     int i;
-                    nbytes = uncomp_buf[1];
-                    matvar->rank = nbytes / 4;
-                    matvar->dims = (size_t*)malloc(matvar->rank*sizeof(*matvar->dims));
+                    size_t dim_bytes = (size_t)uncomp_buf[1];
+                    size_t rank;
+
+                    /* uncomp_buf is 16 uint32 values: 8 bytes tag + up to 56 bytes dims */
+                    if ( dim_bytes == 0 || (dim_bytes % 4) != 0 || dim_bytes > 56 ) {
+                        Mat_Critical("Invalid dimensions byte count %u", (unsigned)uncomp_buf[1]);
+                        Mat_VarFree(matvar);
+                        matvar = NULL;
+                        break;
+                    }
+                    rank = dim_bytes / 4;
+                    if ( rank == 0 || rank > 14 ) {
+                        Mat_Critical("Invalid rank %u", (unsigned)rank);
+                        Mat_VarFree(matvar);
+                        matvar = NULL;
+                        break;
+                    }
+                    if ( rank > SIZE_MAX/sizeof(*matvar->dims) ) {
+                        Mat_Critical("Dimensions allocation overflow");
+                        Mat_VarFree(matvar);
+                        matvar = NULL;
+                        break;
+                    }
+                    matvar->rank = (int)rank;
+                    matvar->dims = (size_t*)malloc(rank*sizeof(*matvar->dims));
+                    if ( matvar->dims == NULL ) {
+                        Mat_Critical("Error allocating memory for dims");
+                        Mat_VarFree(matvar);
+                        matvar = NULL;
+                        break;
+                    }
                     if ( mat->byteswap ) {
                         for ( i = 0; i < matvar->rank; i++ )
                             matvar->dims[i] = Mat_uint32Swap(&(uncomp_buf[2+i]));