diff --git a/modules/dektec_out/dektec_video_decl.c b/modules/dektec_out/dektec_video_decl.c
index fea32e5a1..274927242 100644
--- a/modules/dektec_out/dektec_video_decl.c
+++ b/modules/dektec_out/dektec_video_decl.c
@@ -62,7 +62,7 @@ GF_FilterRegister DTOutRegister;
 GPAC_MODULE_EXPORT
 GF_FilterRegister *RegisterFilter(GF_FilterSession *session)
 #else
-GF_FilterRegister *dtout_register(GF_FilterSession *session)
+const GF_FilterRegister *dtout_register(GF_FilterSession *session)
 #endif
 {
 	memset(DTOutCaps, 0, sizeof(DTOutCaps));
diff --git a/src/filter_core/filter_pck.c b/src/filter_core/filter_pck.c
index b093e8a70..6084247b7 100644
--- a/src/filter_core/filter_pck.c
+++ b/src/filter_core/filter_pck.c
@@ -1558,10 +1558,10 @@ GF_Err gf_filter_pck_set_framing(GF_FilterPacket *pck, Bool is_start, Bool is_en
 	PCK_SETTER_CHECK("framing info")
 
 	if (is_start) pck->info.flags |= GF_PCKF_BLOCK_START;
-	else pck->info.flags &= ~GF_PCKF_BLOCK_START;
+	else pck->info.flags &= ~(u32) GF_PCKF_BLOCK_START;
 
 	if (is_end) pck->info.flags |= GF_PCKF_BLOCK_END;
-	else pck->info.flags &= ~GF_PCKF_BLOCK_END;
+	else pck->info.flags &= ~(u32) GF_PCKF_BLOCK_END;
 	return GF_OK;
 }
 
diff --git a/src/filter_core/filter_pid.c b/src/filter_core/filter_pid.c
index 6180c774c..30c6f9e8b 100644
--- a/src/filter_core/filter_pid.c
+++ b/src/filter_core/filter_pid.c
@@ -3176,7 +3176,7 @@ static void gf_filter_pid_resolve_link_dijkstra(GF_FilterPid *pid, GF_Filter *ds
 		reg_desc->cap_idx = 0;
 		reg_desc->in_edges_enabling = 0;
 		//set node distance and priority to infinity, whether we are in the final dijsktra set or not
-		reg_desc->dist = -1;
+		reg_desc->dist = 0xFFFFFFFFu;
 		reg_desc->priority = 0xFF;
 
 		//remember our source descriptor - it may be absent of the final node set in case we want reconfigurable only filters
diff --git a/src/filters/dasher.c b/src/filters/dasher.c
index 15ee85050..e0ba5e8a8 100644
--- a/src/filters/dasher.c
+++ b/src/filters/dasher.c
@@ -10190,7 +10190,8 @@ static GF_Err dasher_initialize(GF_Filter *filter)
 {
 	GF_Err e;
 	GF_DasherCtx *ctx = gf_filter_get_udta(filter);
-	gf_filter_set_max_extra_input_pids(filter, -1);
+	/* use unsigned max to indicate unlimited extra input PIDs */
+	gf_filter_set_max_extra_input_pids(filter, 0xFFFFFFFFu);
 
 	if (ctx->mname && !strcmp(ctx->mname, "m3u8")) {
 		gf_free(ctx->mname);
diff --git a/src/filters/load_text.c b/src/filters/load_text.c
index 637339822..2abf8d573 100644
--- a/src/filters/load_text.c
+++ b/src/filters/load_text.c
@@ -310,6 +310,12 @@ char *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32 unicod
 	char *sOK;
 	char szLineConv[2048];
 	unsigned short *sptr;
+	/*
+		This function is called with caller-provided buffers that may be a sub-range of a
+		larger buffer (e.g. szLine+offset, size reduced accordingly). We must therefore
+		NEVER copy more than lineSize back into szLine.
+	*/
+	if (!lineSize) return NULL;
 
 	memset(szLine, 0, sizeof(char)*lineSize);
 	sOK = gf_fgets(szLine, lineSize, txt_in);
@@ -378,7 +384,8 @@ char *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32 unicod
 			j = GF_ARRAY_LENGTH(szLineConv) -1 ;
 		}
 		szLineConv[j] = 0;
-		strcpy(szLine, szLineConv);
+		/* bounded copy into caller buffer */
+		gf_strlcpy(szLine, szLineConv, lineSize);
 		return sOK;
 	}
 
@@ -399,10 +406,12 @@ char *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32 unicod
 		}
 	}
 	sptr = (u16 *)szLine;
-	i = gf_utf8_wcstombs(szLineConv, 2048, (const unsigned short **) &sptr);
+	i = gf_utf8_wcstombs(szLineConv, GF_ARRAY_LENGTH(szLineConv)-1, (const unsigned short **) &sptr);
 	if (i == GF_UTF8_FAIL) i = 0;
+	if (i >= GF_ARRAY_LENGTH(szLineConv)) i = GF_ARRAY_LENGTH(szLineConv)-1;
 	szLineConv[i] = 0;
-	strcpy(szLine, szLineConv);
+	/* bounded copy into caller buffer */
+	gf_strlcpy(szLine, szLineConv, lineSize);
 	/*this is ugly indeed: since input is UTF16-LE, there are many chances the gf_fgets never reads the \0 after a \n*/
 	if (unicode_type==3) gf_fgetc(txt_in);
 	return sOK;
diff --git a/src/filters/mux_isom.c b/src/filters/mux_isom.c
index 29bdbb64b..45f776716 100644
--- a/src/filters/mux_isom.c
+++ b/src/filters/mux_isom.c
@@ -7594,7 +7594,8 @@ void mp4_mux_progress_cbk(void *udta, u64 done, u64 total)
 static GF_Err mp4_mux_initialize(GF_Filter *filter)
 {
 	GF_MP4MuxCtx *ctx = gf_filter_get_udta(filter);
-	gf_filter_set_max_extra_input_pids(filter, -1);
+	/* use unsigned max to indicate unlimited extra input PIDs */
+	gf_filter_set_max_extra_input_pids(filter, 0xFFFFFFFFu);
 	ctx->filter = filter;
 #ifdef GPAC_DISABLE_ISOM_FRAGMENTS
 	if (ctx->store>=MP4MX_MODE_FRAG) {
diff --git a/src/filters/reframe_h263.c b/src/filters/reframe_h263.c
index 4b9da7ed2..b8c9b00fd 100644
--- a/src/filters/reframe_h263.c
+++ b/src/filters/reframe_h263.c
@@ -109,7 +109,8 @@ GF_Err h263dmx_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remov
 #define H263_CACHE_SIZE	4096
 static u32 h263dmx_next_start_code_bs(GF_BitStream *bs)
 {
-	u32 v, bpos;
+	u32 bpos;
+	u64 v;
 	unsigned char h263_cache[H263_CACHE_SIZE];
 	u64 end, cache_start, load_size;
 	u64 start = gf_bs_get_position(bs);
@@ -120,7 +121,7 @@ static u32 h263dmx_next_start_code_bs(GF_BitStream *bs)
 	load_size = 0;
 	cache_start = 0;
 	end = 0;
-	v = 0xffffffff;
+	v = 0xffffffffULL;
 	while (!end) {
 		/*refill cache*/
 		if (bpos == (u32) load_size) {
@@ -336,7 +337,8 @@ static GFINLINE void h263dmx_update_cts(GF_H263DmxCtx *ctx)
 
 static s32 h263dmx_next_start_code(u8 *data, u32 size)
 {
-	u32 v, bpos;
+	u32 bpos;
+	u64 v;
 	s64 end;
 	s64 start = 0;
 
@@ -344,12 +346,12 @@ static s32 h263dmx_next_start_code(u8 *data, u32 size)
 	start+=2;
 	bpos = 0;
 	end = 0;
-	v = 0xffffffff;
+	v = 0xffffffffULL;
 	while (!end) {
 		if (bpos == size) return -1;
-		v = (v<<8) | data[bpos];
+		v = ((v<<8) & 0xFFFFFFFFULL) | data[bpos];
 		bpos++;
-		if ((v >> (32-22)) == 0x20) end = start + bpos - 4;
+		if ((v >> (32-22)) == 0x20ULL) end = start + bpos - 4;
 	}
 
 	return (s32) (end-start);
diff --git a/src/media_tools/av_parsers.c b/src/media_tools/av_parsers.c
index 43c3200b9..82f152fa2 100644
--- a/src/media_tools/av_parsers.c
+++ b/src/media_tools/av_parsers.c
@@ -314,7 +314,8 @@ u32 gf_m4v_parser_get_obj_type(GF_M4VParser *m4v)
 #define M4V_CACHE_SIZE		4096
 s32 M4V_LoadObject(GF_M4VParser *m4v)
 {
-	u32 v, bpos, found;
+	u32 bpos, found;
+	u64 v;
 	char m4v_cache[M4V_CACHE_SIZE];
 	u64 end, cache_start, load_size;
 	if (!m4v) return 0;
@@ -329,7 +330,7 @@ s32 M4V_LoadObject(GF_M4VParser *m4v)
 	load_size = 0;
 	end = 0;
 	cache_start = 0;
-	v = 0xffffffff;
+	v = 0xffffffffULL;
 	while (!end) {
 		/*refill cache*/
 		if (bpos == (u32)load_size) {
@@ -340,9 +341,9 @@ s32 M4V_LoadObject(GF_M4VParser *m4v)
 			cache_start = gf_bs_get_position(m4v->bs);
 			gf_bs_read_data(m4v->bs, m4v_cache, (u32)load_size);
 		}
-		v = ((v << 8) & 0xFFFFFF00) | ((u8)m4v_cache[bpos]);
+		v = ((v << 8) & 0xFFFFFFFFULL) | ((u8)m4v_cache[bpos]);
 		bpos++;
-		if ((v & 0xFFFFFF00) == 0x00000100) {
+		if (((u32)(v & 0xFFFFFF00ULL)) == 0x00000100U) {
 			end = cache_start + bpos - 4;
 			found = 1;
 			break;