diff --git a/src/kernel.c b/src/kernel.c
index 8551b50e..0b5d0bdb 100644
--- a/src/kernel.c
+++ b/src/kernel.c
@@ -279,6 +279,40 @@ static void
 init_copy(mrb_state *mrb, mrb_value dest, mrb_value obj)
 {
   switch (mrb_type(obj)) {
+    case MRB_TT_ICLASS: {
+      /* MRB_TT_ICLASS is an internal-only type used to represent included/
+         prepended modules in a class's super chain. It is not a normal Ruby
+         object and must not invoke Ruby-level initialize_copy.
+
+         When we duplicate classes/modules (e.g. via prepend), we may need to
+         duplicate these ICLASS nodes to rebuild the chain. Do the necessary
+         internal shallow copy and return early to avoid calling
+         initialize_copy on an internal object. */
+      struct RClass *dc = mrb_class_ptr(dest);
+      struct RClass *sc = mrb_class_ptr(obj);
+
+      dc->iv = sc->iv;
+      dc->super = sc->super;
+      dc->c = sc->c;
+
+      /* Only an origin ICLASS owns its method table (it holds the class's
+         original mt before prepend). Non-origin ICLASS nodes share the
+         module method table and must not free it. */
+      if (sc->flags & MRB_FLAG_IS_ORIGIN) {
+        if (sc->mt) {
+          dc->mt = kh_copy(mt, mrb, sc->mt);
+        }
+        else {
+          dc->mt = kh_init(mt, mrb);
+        }
+        dc->flags |= MRB_FLAG_IS_ORIGIN;
+      }
+      else {
+        dc->mt = sc->mt;
+      }
+      dc->flags |= sc->flags & (MRB_FLAG_IS_PREPENDED|MRB_FLAG_IS_INHERITED);
+      return;
+    }
     case MRB_TT_CLASS:
     case MRB_TT_MODULE:
       copy_class(mrb, dest, obj);