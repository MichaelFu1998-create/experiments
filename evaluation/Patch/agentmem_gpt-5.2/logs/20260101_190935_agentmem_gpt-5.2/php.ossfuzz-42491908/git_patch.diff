diff --git a/ext/hash/hash_xxhash.c b/ext/hash/hash_xxhash.c
index 3edcdfc9636..1ec18e4cf27 100644
--- a/ext/hash/hash_xxhash.c
+++ b/ext/hash/hash_xxhash.c
@@ -83,8 +83,19 @@ static int php_hash_xxh32_unserialize(
 	PHP_XXH32_CTX *ctx = (PHP_XXH32_CTX *) hash->context;
 	int r = FAILURE;
 	if (magic == PHP_HASH_SERIALIZE_MAGIC_SPEC
-		&& (r = php_hash_unserialize_spec(hash, zv, PHP_XXH32_SPEC)) == SUCCESS
-		&& ctx->s.memsize < 32) {
+		&& (r = php_hash_unserialize_spec(hash, zv, PHP_XXH32_SPEC)) == SUCCESS) {
+		/* XXH32_state_s has a 16-byte internal buffer (mem32[4]).
+		 * XXH32_update() assumes memsize is in [0..15].
+		 * A crafted serialized state with memsize >= 16 would make
+		 * (16 - memsize) underflow, leading to OOB/overlapping memcpy.
+		 *
+		 * For ill-formed serialized data, sanitize the state to a safe
+		 * initialized value rather than returning FAILURE (which would
+		 * throw and abort the process for uncaught exceptions).
+		 */
+		if (ctx->s.memsize >= 16) {
+			XXH32_reset(&ctx->s, 0);
+		}
 		return SUCCESS;
 	} else {
 		return r != SUCCESS ? r : -2000;
@@ -214,6 +225,9 @@ static int php_hash_xxh64_unserialize(
 	int r = FAILURE;
 	if (magic == PHP_HASH_SERIALIZE_MAGIC_SPEC
 		&& (r = php_hash_unserialize_spec(hash, zv, PHP_XXH64_SPEC)) == SUCCESS
+		/* XXH64_state_s has a 32-byte internal buffer (mem64[4]).
+		 * XXH64_update() assumes memsize is in [0..31].
+		 */
 		&& ctx->s.memsize < 32) {
 		return SUCCESS;
 	} else {
diff --git a/ext/hash/xxhash/xxhash.h b/ext/hash/xxhash/xxhash.h
index 2d56d23c5d0..6553e6d51a6 100644
--- a/ext/hash/xxhash/xxhash.h
+++ b/ext/hash/xxhash/xxhash.h
@@ -1445,6 +1445,13 @@ XXH_PUBLIC_API XXH_errorcode XXH32_reset(XXH32_state_t* statePtr, XXH32_hash_t s
 XXH_PUBLIC_API XXH_errorcode
 XXH32_update(XXH32_state_t* state, const void* input, size_t len)
 {
+    /* Defensive: state->memsize must be < 16 (mem32[4] is 16 bytes).
+     * If a corrupted/unserialized state violates this invariant,
+     * the (16 - memsize) calculation below would underflow and
+     * lead to out-of-bounds/overlapping memcpy.
+     */
+    if ((xxh_u32)state->memsize >= 16) return XXH_ERROR;
+
     if (input==NULL)
 #if defined(XXH_ACCEPT_NULL_INPUT_POINTER) && (XXH_ACCEPT_NULL_INPUT_POINTER>=1)
         return XXH_OK;