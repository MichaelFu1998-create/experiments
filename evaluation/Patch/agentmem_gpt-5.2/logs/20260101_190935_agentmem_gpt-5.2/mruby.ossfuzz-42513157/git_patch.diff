diff --git a/mrbgems/mruby-bigint/core/bigint.c b/mrbgems/mruby-bigint/core/bigint.c
index b7892ef21..b292f4afb 100644
--- a/mrbgems/mruby-bigint/core/bigint.c
+++ b/mrbgems/mruby-bigint/core/bigint.c
@@ -416,13 +416,40 @@ udiv(mrb_state *mrb, mpz_t *qq, mpz_t *rr, mpz_t *xx, mpz_t *yy)
 
   if (uzero(yy))
     return;
+
+  /* Fast path / safety precondition:
+   * If |xx| < |yy|, quotient is 0 and remainder is |xx|.
+   * The main long-division loop assumes xd >= yd (after normalization) and
+   * uses size_t indices; entering it with xd < yd can underflow and lead to
+   * out-of-bounds limb/half-limb accesses.
+   */
+  if (ucmp(xx, yy) < 0) {
+    /* Preserve behavior of udiv() which returns an unsigned remainder and
+     * lets callers adjust signs.
+     * Be careful with aliasing (e.g. qq may be xx).
+     */
+    if (rr) {
+      mpz_set(mrb, rr, xx);
+      rr->sn = 0;
+    }
+    if (qq) {
+      mpz_set_int(mrb, qq, 0);
+      qq->sn = 0;
+    }
+    return;
+  }
   mpz_init(mrb,&q); mpz_init(mrb,&x);mpz_init(mrb,&y);mpz_init(mrb,&r);
   mpz_realloc(mrb,&x,(size_t)((xx->sz)+1));
   yd = digits(yy);
   ns = lzb(yy->p[yd-1]);
   ulshift(mrb,&x,xx,ns);
   ulshift(mrb,&y,yy,ns);
+  /* The division core may temporarily propagate borrow/carry into the next
+   * higher limb (e.g. via x.p[(i+j)/2] after the i-loop). Ensure there is a
+   * guard limb available.
+   */
   xd = digits(&x);
+  mpz_realloc(mrb,&x,(size_t)(xd+1));
   mpz_realloc(mrb,&q,(size_t)xd);
   xd*=2; yd*=2;
   z = hd(&y,yd-1);