diff --git a/programs/escape.c b/programs/escape.c
index 1daff81d..702cc9d7 100644
--- a/programs/escape.c
+++ b/programs/escape.c
@@ -23,42 +23,113 @@
 #include "common.h"
 #include "escape.h"
 
+/* Ensure the buffer can hold `need` more bytes plus a trailing NUL. */
+static int
+ensure_capacity (char **destp, char **dp, size_t *lenp, size_t need)
+{
+  char *dest = *destp;
+  char *d = *dp;
+  size_t len = *lenp;
+  size_t off = (size_t)(d - dest);
+  size_t required = off + need + 1;
+
+  if (required <= len)
+    return 1;
+
+  /* Grow geometrically to avoid O(n^2) realloc behaviour. */
+  size_t newlen = len ? len : 16;
+  while (newlen < required)
+    newlen *= 2;
+
+  char *newdest = (char *)realloc (dest, newlen);
+  if (!newdest)
+    return 0;
+
+  *destp = newdest;
+  *dp = newdest + off;
+  *lenp = newlen;
+  return 1;
+}
+
 char * ATTRIBUTE_MALLOC
 htmlescape (const char *restrict src, const int cp)
 {
-  int len = strlen (src) + 10;
-  char *dest, *d = malloc (len);
-  unsigned char *s = (unsigned char *)src;
-  dest = d;
-  while (*s++)
+  (void)cp;
+  if (!src)
+    return NULL;
+
+  size_t len = strlen (src) + 16;
+  char *dest = (char *)malloc (len);
+  char *d;
+  const unsigned char *s = (const unsigned char *)src;
+
+  if (!dest)
+    return NULL;
+  d = dest;
+
+  /* The previous implementation used strcat() on a moving pointer into
+     freshly malloc/realloc'd memory. strcat() requires a NUL-terminated
+     destination and would read past the allocated buffer, causing the
+     ASan-reported heap-buffer-overflow.
+
+     Build the output with explicit length tracking and bounded copies. */
+  while (*s)
     {
-      const int off = d - dest;
-      if (off >= len - 8)
+      unsigned char c = *s++;
+      const char *lit = NULL;
+      size_t litlen = 0;
+
+      switch (c)
+        {
+        case '"': lit = "&quot;"; litlen = 6; break;
+        case '\'': lit = "&#39;";  litlen = 5; break;
+        case '`': lit = "&#96;";   litlen = 5; break;
+        case '&': lit = "&amp;";  litlen = 5; break;
+        case '<': lit = "&lt;";   litlen = 4; break;
+        case '>': lit = "&gt;";   litlen = 4; break;
+        case '{': lit = "&#123;"; litlen = 6; break;
+        case '}': lit = "&#125;"; litlen = 6; break;
+        default:
+          break;
+        }
+
+      if (lit)
         {
-          len += 10;
-          dest = realloc (dest, len);
-          d = dest + off;
+          if (!ensure_capacity (&dest, &d, &len, litlen))
+            {
+              free (dest);
+              return NULL;
+            }
+          memcpy (d, lit, litlen);
+          d += litlen;
         }
-      switch (*s)
+      else if (c >= 127) /* maybe encodings, no utf8 (see htmlwescape) */
         {
-        case '"': strcat (d, "&quot;"); d += 6; break;
-        case '\'': strcat (d, "&#39;"); d += 5; break;
-        case '`': strcat (d, "&#96;"); d += 5; break;
-        case '&': strcat (d, "&amp;"); d += 5; break;
-        case '<': strcat (d, "&lt;"); d += 4; break;
-        case '>': strcat (d, "&gt;"); d += 4; break;
-        case '{': strcat (d, "&#123;"); d += 6; break;
-        case '}': strcat (d, "&#125;"); d += 6; break;
-        default:
-          if (*s >= 127) // maybe encodings, no utf8 (see htmlwescape)
+          char tmp[16];
+          int n = snprintf (tmp, sizeof (tmp), "&#x%X;", c);
+          if (n > 0)
             {
-              sprintf (d, "&#x%X;", *s); // 4 + 4
-              d += strlen (d);
+              size_t nn = (size_t)n;
+              if (!ensure_capacity (&dest, &d, &len, nn))
+                {
+                  free (dest);
+                  return NULL;
+                }
+              memcpy (d, tmp, nn);
+              d += nn;
             }
-          else if (*s >= 20)
-            *d++ = *s;
+        }
+      else if (c >= 20)
+        {
+          if (!ensure_capacity (&dest, &d, &len, 1))
+            {
+              free (dest);
+              return NULL;
+            }
+          *d++ = (char)c;
         }
     }
+
   *d = 0;
   return dest;
 }
@@ -66,47 +137,80 @@ htmlescape (const char *restrict src, const int cp)
 char * ATTRIBUTE_MALLOC
 htmlwescape (BITCODE_TU wstr)
 {
-  int len = 0;
+  size_t len = 0;
   char *dest, *d;
   BITCODE_TU tmp = wstr;
   BITCODE_RS c;
 
   if (!wstr)
     return NULL;
+
   while ((c = *tmp++))
     len++;
   len += 16;
-  d = dest = malloc (len);
 
-  while (*wstr++)
+  dest = (char *)malloc (len);
+  if (!dest)
+    return NULL;
+  d = dest;
+
+  while (*wstr)
     {
-      const int off = d - dest;
-      if (off >= len - 8)
+      BITCODE_RS wc = *wstr++;
+      const char *lit = NULL;
+      size_t litlen = 0;
+
+      switch (wc)
         {
-          len += 16;
-          dest = realloc (dest, len);
-          d = dest + off;
+        case 34:  lit = "&quot;"; litlen = 6; break;
+        case 39:  lit = "&#39;";  litlen = 5; break;
+        case 38:  lit = "&amp;";  litlen = 5; break;
+        case 60:  lit = "&lt;";   litlen = 4; break;
+        case 62:  lit = "&gt;";   litlen = 4; break;
+        case 96:  lit = "&#96;";  litlen = 5; break;
+        case 123: lit = "&#123;"; litlen = 6; break;
+        case 125: lit = "&#125;"; litlen = 6; break;
+        default:
+          break;
         }
-      switch (*wstr)
+
+      if (lit)
         {
-        case 34: strcat (d, "&quot;"); d += 6; break;
-        case 39: strcat (d, "&#39;"); d += 5; break;
-        case 38: strcat (d, "&amp;"); d += 5; break;
-        case 60: strcat (d, "&lt;"); d += 4; break;
-        case 62: strcat (d, "&gt;"); d += 4; break;
-        case 96: strcat (d, "&#96;"); d += 5; break;
-        case 123: strcat (d, "&#123;"); d += 6; break;
-        case 125: strcat (d, "&#125;"); d += 6; break;
-        default:
-          if (*wstr >= 127) // utf8 encodings
+          if (!ensure_capacity (&dest, &d, &len, litlen))
+            {
+              free (dest);
+              return NULL;
+            }
+          memcpy (d, lit, litlen);
+          d += litlen;
+        }
+      else if (wc >= 127) /* utf8 encodings */
+        {
+          char tmpbuf[32];
+          int n = snprintf (tmpbuf, sizeof (tmpbuf), "&#x%X;", (unsigned)wc);
+          if (n > 0)
             {
-              sprintf (d, "&#x%X;", *wstr);
-              d += strlen (d);
+              size_t nn = (size_t)n;
+              if (!ensure_capacity (&dest, &d, &len, nn))
+                {
+                  free (dest);
+                  return NULL;
+                }
+              memcpy (d, tmpbuf, nn);
+              d += nn;
             }
-          else if (*wstr >= 20)
-            *d++ = *wstr;
+        }
+      else if (wc >= 20)
+        {
+          if (!ensure_capacity (&dest, &d, &len, 1))
+            {
+              free (dest);
+              return NULL;
+            }
+          *d++ = (char)wc;
         }
     }
+
   *d = 0;
   return dest;
 }