diff --git a/src/inflate.c b/src/inflate.c
index 5fd205a..6720709 100644
--- a/src/inflate.c
+++ b/src/inflate.c
@@ -349,7 +349,8 @@ InflateRankDims(mat_t *mat, matvar_t *matvar, void *buf, size_t nbytes, mat_uint
 {
     mat_uint8_t comp_buf[32];
     mat_int32_t tag[2];
-    int    err, rank, i;
+    int    err;
+    size_t dim_bytes, padded_dim_bytes, pad_bytes;
     size_t bytesread = 0, readresult = 1;
 
     if ( buf == NULL )
@@ -388,12 +389,20 @@ InflateRankDims(mat_t *mat, matvar_t *matvar, void *buf, size_t nbytes, mat_uint
         Mat_Critical("InflateRankDims: Reading dimensions expected type MAT_T_INT32");
         return bytesread;
     }
-    rank = tag[1];
-    if ( rank % 8 != 0 )
-        i = 8-(rank %8);
-    else
-        i = 0;
-    rank+=i;
+    if ( tag[1] < 0 ) {
+        Mat_Critical("InflateRankDims: Invalid dimensions byte count %d", tag[1]);
+        return bytesread;
+    }
+
+    /* tag[1] is the number of bytes in the (un-padded) dimensions array */
+    dim_bytes = (size_t)tag[1];
+    if ( dim_bytes % sizeof(mat_uint32_t) != 0 ) {
+        Mat_Critical("InflateRankDims: Invalid dimensions byte count %zu", (size_t)dim_bytes);
+        return bytesread;
+    }
+
+    pad_bytes = (dim_bytes % 8) ? (8 - (dim_bytes % 8)) : 0;
+    padded_dim_bytes = dim_bytes + pad_bytes;
 
     if ( !matvar->internal->z->avail_in ) {
         matvar->internal->z->avail_in = 1;
@@ -401,12 +410,14 @@ InflateRankDims(mat_t *mat, matvar_t *matvar, void *buf, size_t nbytes, mat_uint
         bytesread += fread(comp_buf,1,1,(FILE*)mat->fp);
     }
 
-    matvar->internal->z->avail_out = rank;
-    if ( sizeof(mat_uint32_t)*(rank + 2) <= nbytes ) {
+    matvar->internal->z->avail_out = padded_dim_bytes;
+    /* buf must hold 8 bytes of tag + padded dimensions data */
+    if ( 8 + padded_dim_bytes <= nbytes ) {
         matvar->internal->z->next_out = (Bytef*)((mat_int32_t *)buf+2);
     } else {
         /* Cannot use too small buf, but can allocate output buffer dims */
-        *dims = (mat_uint32_t*)calloc(rank, sizeof(mat_uint32_t));
+        size_t ndims_words = padded_dim_bytes / sizeof(mat_uint32_t);
+        *dims = (mat_uint32_t*)calloc(ndims_words, sizeof(mat_uint32_t));
         if ( NULL != *dims ) {
             matvar->internal->z->next_out = (Bytef*)*dims;
         } else {
diff --git a/src/mat5.c b/src/mat5.c
index abdb351..56e8c8e 100644
--- a/src/mat5.c
+++ b/src/mat5.c
@@ -980,9 +980,30 @@ ReadNextCell( mat_t *mat, matvar_t *matvar )
                 /* Rank and Dimension */
                 if ( uncomp_buf[0] == MAT_T_INT32 ) {
                     int j;
+                    /* uncomp_buf[1] is the number of bytes in the dimension array */
                     cells[i]->rank = uncomp_buf[1];
                     nbytes -= cells[i]->rank;
                     cells[i]->rank /= 4;
+                    if ( cells[i]->rank % 2 != 0 )
+                        nbytes -= 4;
+
+                    /* Defensive: if InflateRankDims used the small stack buffer,
+                     * ensure we never read past it. This can happen on malformed
+                     * inputs if the dimensions payload is larger than the scratch
+                     * buffer.
+                     */
+                    if ( dims == uncomp_buf + 2 &&
+                         cells[i]->rank > (int)(sizeof(uncomp_buf)/sizeof(uncomp_buf[0]) - 2) ) {
+                        Mat_Critical("Invalid rank %d for cell: dimensions do not fit scratch buffer", cells[i]->rank);
+                        if ( do_clean )
+                            free(dims);
+                        /* Skip the remaining data for this element to keep parsing aligned */
+                        bytesread += InflateSkip(mat, matvar->internal->z, nbytes);
+                        Mat_VarFree(cells[i]);
+                        cells[i] = NULL;
+                        continue;
+                    }
+
                     cells[i]->dims = (size_t*)malloc(cells[i]->rank*sizeof(*cells[i]->dims));
                     if ( mat->byteswap ) {
                         for ( j = 0; j < cells[i]->rank; j++ )
@@ -991,8 +1012,6 @@ ReadNextCell( mat_t *mat, matvar_t *matvar )
                         for ( j = 0; j < cells[i]->rank; j++ )
                             cells[i]->dims[j] = dims[j];
                     }
-                    if ( cells[i]->rank % 2 != 0 )
-                        nbytes -= 4;
                 }
                 if ( do_clean )
                     free(dims);
@@ -1356,9 +1375,27 @@ ReadNextStructField( mat_t *mat, matvar_t *matvar )
                 /* Rank and dimension */
                 if ( uncomp_buf[0] == MAT_T_INT32 ) {
                     int j;
+                    /* uncomp_buf[1] is the number of bytes in the dimension array */
                     fields[i]->rank = uncomp_buf[1];
                     nbytes -= fields[i]->rank;
                     fields[i]->rank /= 4;
+                    if ( fields[i]->rank % 2 != 0 )
+                        nbytes -= 4;
+
+                    /* Defensive: if InflateRankDims used the small stack buffer,
+                     * ensure we never read past it.
+                     */
+                    if ( dims == uncomp_buf + 2 &&
+                         fields[i]->rank > (int)(sizeof(uncomp_buf)/sizeof(uncomp_buf[0]) - 2) ) {
+                        Mat_Critical("Invalid rank %d for struct field: dimensions do not fit scratch buffer", fields[i]->rank);
+                        if ( do_clean )
+                            free(dims);
+                        bytesread += InflateSkip(mat, matvar->internal->z, nbytes);
+                        Mat_VarFree(fields[i]);
+                        fields[i] = NULL;
+                        continue;
+                    }
+
                     fields[i]->dims = (size_t*)malloc(fields[i]->rank*
                                              sizeof(*fields[i]->dims));
                     if ( mat->byteswap ) {
@@ -1368,8 +1405,6 @@ ReadNextStructField( mat_t *mat, matvar_t *matvar )
                         for ( j = 0; j < fields[i]->rank; j++ )
                             fields[i]->dims[j] = dims[j];
                     }
-                    if ( fields[i]->rank % 2 != 0 )
-                        nbytes -= 4;
                 }
                 if ( do_clean )
                     free(dims);