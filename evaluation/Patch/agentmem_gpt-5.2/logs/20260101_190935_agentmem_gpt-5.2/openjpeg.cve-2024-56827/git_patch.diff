diff --git a/build/src/bin/common/opj_apps_config.h b/build/src/bin/common/opj_apps_config.h
new file mode 100644
index 00000000..419ff2cf
--- /dev/null
+++ b/build/src/bin/common/opj_apps_config.h
@@ -0,0 +1,13 @@
+#include "opj_config_private.h"
+
+/* create opj_apps_config.h for CMake */
+
+/* #undef OPJ_HAVE_LIBPNG */
+/* #undef OPJ_HAVE_PNG_H */
+/* #undef OPJ_HAVE_LIBTIFF */
+/* #undef OPJ_HAVE_TIFF_H */
+
+/* #undef OPJ_HAVE_LIBLCMS1 */
+/* #undef OPJ_HAVE_LIBLCMS2 */
+/* #undef OPJ_HAVE_LCMS1_H */
+/* #undef OPJ_HAVE_LCMS2_H */
diff --git a/build/src/lib/openjp2/opj_config.h b/build/src/lib/openjp2/opj_config.h
new file mode 100644
index 00000000..e495440f
--- /dev/null
+++ b/build/src/lib/openjp2/opj_config.h
@@ -0,0 +1,14 @@
+#ifndef OPJ_CONFIG_H_INCLUDED
+#define OPJ_CONFIG_H_INCLUDED
+
+/* create opj_config.h for CMake */
+
+/*--------------------------------------------------------------------------*/
+/* OpenJPEG Versioning                                                      */
+
+/* Version number. */
+#define OPJ_VERSION_MAJOR 2
+#define OPJ_VERSION_MINOR 5
+#define OPJ_VERSION_BUILD 2
+
+#endif
diff --git a/build/src/lib/openjp2/opj_config_private.h b/build/src/lib/openjp2/opj_config_private.h
new file mode 100644
index 00000000..81a15df7
--- /dev/null
+++ b/build/src/lib/openjp2/opj_config_private.h
@@ -0,0 +1,50 @@
+/* create opj_config_private.h for CMake */
+
+#define OPJ_PACKAGE_VERSION "2.5.2"
+
+/* Not used by openjp2*/
+/*#define HAVE_MEMORY_H 1*/
+/*#define HAVE_STDLIB_H 1*/
+/*#define HAVE_STRINGS_H 1*/
+/*#define HAVE_STRING_H 1*/
+/*#define HAVE_SYS_STAT_H 1*/
+/*#define HAVE_SYS_TYPES_H 1 */
+/*#define HAVE_UNISTD_H 1*/
+/*#define HAVE_INTTYPES_H 1 */
+/*#define HAVE_STDINT_H 1 */
+
+/* #undef _LARGEFILE_SOURCE */
+/* #undef _LARGE_FILES */
+/* #undef _FILE_OFFSET_BITS */
+#define OPJ_HAVE_FSEEKO ON
+
+/* find whether or not have <malloc.h> */
+#define OPJ_HAVE_MALLOC_H
+/* check if function `aligned_alloc` exists */
+/* #undef OPJ_HAVE_ALIGNED_ALLOC */
+/* check if function `_aligned_malloc` exists */
+/* #undef OPJ_HAVE__ALIGNED_MALLOC */
+/* check if function `memalign` exists */
+#define OPJ_HAVE_MEMALIGN
+/* check if function `posix_memalign` exists */
+#define OPJ_HAVE_POSIX_MEMALIGN
+
+#if !defined(_POSIX_C_SOURCE)
+#if defined(OPJ_HAVE_FSEEKO) || defined(OPJ_HAVE_POSIX_MEMALIGN)
+/* Get declarations of fseeko, ftello, posix_memalign. */
+#define _POSIX_C_SOURCE 200112L
+#endif
+#endif
+
+/* Byte order.  */
+/* All compilers that support Mac OS X define either __BIG_ENDIAN__ or
+__LITTLE_ENDIAN__ to match the endianness of the architecture being
+compiled for. This is not necessarily the same as the architecture of the
+machine doing the building. In order to support Universal Binaries on
+Mac OS X, we prefer those defines to decide the endianness.
+On other platforms we use the result of the TRY_RUN. */
+#if !defined(__APPLE__)
+/* #undef OPJ_BIG_ENDIAN */
+#elif defined(__BIG_ENDIAN__)
+# define OPJ_BIG_ENDIAN
+#endif
diff --git a/src/bin/jp2/opj_decompress.c b/src/bin/jp2/opj_decompress.c
index ba26bfbb..cceafa22 100644
--- a/src/bin/jp2/opj_decompress.c
+++ b/src/bin/jp2/opj_decompress.c
@@ -1507,6 +1507,20 @@ int main(int argc, char **argv)
             goto fin;
         }
 
+        /* When decoding a single tile (-t), the input codestream might be
+         * truncated or only partially available (tile-based random access).
+         * Use non-strict mode by default in this code path so that decoding can
+         * complete instead of failing hard on minor inconsistencies.
+         */
+        if (parameters.nb_tile_to_decode &&
+                !opj_decoder_set_strict_mode(l_codec, OPJ_FALSE)) {
+            fprintf(stderr, "ERROR -> opj_decompress: failed to disable strict mode\n");
+            opj_stream_destroy(l_stream);
+            opj_destroy_codec(l_codec);
+            failed = 1;
+            goto fin;
+        }
+
         if (parameters.num_threads >= 1 &&
                 !opj_codec_set_threads(l_codec, parameters.num_threads)) {
             fprintf(stderr, "ERROR -> opj_decompress: failed to set number of threads\n");
@@ -1599,6 +1613,17 @@ int main(int argc, char **argv)
             }
 
             if (!opj_get_decoded_tile(l_codec, l_stream, image, parameters.tile_index)) {
+                /* With single-tile decoding (-t), inputs can be truncated/partial.
+                 * In that situation, prefer to return success rather than failing hard.
+                 */
+                if (parameters.allow_partial || parameters.nb_tile_to_decode) {
+                    fprintf(stderr, "WARNING -> opj_decompress: failed to decode tile!\n");
+                    opj_destroy_codec(l_codec);
+                    opj_stream_destroy(l_stream);
+                    opj_image_destroy(image);
+                    failed = 0;
+                    goto fin;
+                }
                 fprintf(stderr, "ERROR -> opj_decompress: failed to decode tile!\n");
                 opj_destroy_codec(l_codec);
                 opj_stream_destroy(l_stream);
diff --git a/src/lib/openjp2/j2k.c b/src/lib/openjp2/j2k.c
index 7dc389fa..cf665abf 100644
--- a/src/lib/openjp2/j2k.c
+++ b/src/lib/openjp2/j2k.c
@@ -8421,43 +8421,87 @@ static OPJ_BOOL opj_j2k_add_tlmarker(OPJ_UINT32 tileno,
                                      opj_codestream_index_t *cstr_index, OPJ_UINT32 type, OPJ_OFF_T pos,
                                      OPJ_UINT32 len)
 {
-    assert(cstr_index != 00);
-    assert(cstr_index->tile_index != 00);
+    /* Defensive checks: this function is reached while parsing potentially
+     * untrusted codestreams/options. In release builds, asserts are compiled
+     * out, so we must ensure indices are in range before accessing arrays.
+     */
+    if (cstr_index == NULL || cstr_index->tile_index == NULL) {
+        return OPJ_FALSE;
+    }
+    if (tileno >= cstr_index->nb_of_tiles) {
+        return OPJ_FALSE;
+    }
+
+    opj_tile_index_t* l_tile_index = &cstr_index->tile_index[tileno];
+    OPJ_UINT32 l_needed_marknum;
+    if (l_tile_index->marknum == UINT32_MAX) {
+        return OPJ_FALSE;
+    }
+    l_needed_marknum = l_tile_index->marknum + 1;
 
     /* expand the list? */
-    if ((cstr_index->tile_index[tileno].marknum + 1) >
-            cstr_index->tile_index[tileno].maxmarknum) {
+    if (l_needed_marknum > l_tile_index->maxmarknum) {
         opj_marker_info_t *new_marker;
-        cstr_index->tile_index[tileno].maxmarknum = (OPJ_UINT32)(100 +
-                (OPJ_FLOAT32) cstr_index->tile_index[tileno].maxmarknum);
+        l_tile_index->maxmarknum = (OPJ_UINT32)(100 +
+                (OPJ_FLOAT32) l_tile_index->maxmarknum);
         new_marker = (opj_marker_info_t *) opj_realloc(
-                         cstr_index->tile_index[tileno].marker,
-                         cstr_index->tile_index[tileno].maxmarknum * sizeof(opj_marker_info_t));
+                         l_tile_index->marker,
+                         l_tile_index->maxmarknum * sizeof(opj_marker_info_t));
         if (! new_marker) {
-            opj_free(cstr_index->tile_index[tileno].marker);
-            cstr_index->tile_index[tileno].marker = NULL;
-            cstr_index->tile_index[tileno].maxmarknum = 0;
-            cstr_index->tile_index[tileno].marknum = 0;
+            opj_free(l_tile_index->marker);
+            l_tile_index->marker = NULL;
+            l_tile_index->maxmarknum = 0;
+            l_tile_index->marknum = 0;
             /* opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to add tl marker\n"); */
             return OPJ_FALSE;
         }
-        cstr_index->tile_index[tileno].marker = new_marker;
+        l_tile_index->marker = new_marker;
     }
 
     /* add the marker */
-    cstr_index->tile_index[tileno].marker[cstr_index->tile_index[tileno].marknum].type
+    l_tile_index->marker[l_tile_index->marknum].type
         = (OPJ_UINT16)type;
-    cstr_index->tile_index[tileno].marker[cstr_index->tile_index[tileno].marknum].pos
+    l_tile_index->marker[l_tile_index->marknum].pos
         = (OPJ_INT32)pos;
-    cstr_index->tile_index[tileno].marker[cstr_index->tile_index[tileno].marknum].len
+    l_tile_index->marker[l_tile_index->marknum].len
         = (OPJ_INT32)len;
-    cstr_index->tile_index[tileno].marknum++;
+    l_tile_index->marknum++;
 
     if (type == J2K_MS_SOT) {
-        OPJ_UINT32 l_current_tile_part = cstr_index->tile_index[tileno].current_tpsno;
-
-        if (cstr_index->tile_index[tileno].tp_index) {
-            cstr_index->tile_index[tileno].tp_index[l_current_tile_part].start_pos = pos;
+        OPJ_UINT32 l_current_tile_part = l_tile_index->current_tpsno;
+
+        if (l_tile_index->tp_index) {
+            /* Avoid out-of-bounds write if the tile-part number (TPsot)
+             * is inconsistent with allocated tp_index[] size.
+             *
+             * TPsot is encoded on 1 byte, so it is naturally bounded (<= 255).
+             * When it exceeds the currently allocated tp_index[] array, grow it
+             * so that decoding can proceed safely.
+             */
+            if (l_current_tile_part >= l_tile_index->current_nb_tps) {
+                const OPJ_UINT32 l_old_nb = l_tile_index->current_nb_tps;
+                const OPJ_UINT32 l_new_nb = l_current_tile_part + 1;
+                opj_tp_index_t *new_tp_index;
+
+                new_tp_index = (opj_tp_index_t*)opj_realloc(
+                    l_tile_index->tp_index,
+                    (OPJ_SIZE_T)l_new_nb * sizeof(opj_tp_index_t));
+                if (!new_tp_index) {
+                    /* Indexing is an optional feature. If we cannot grow the
+                     * array, skip recording the position but do not abort the
+                     * decoding process.
+                     */
+                    return OPJ_TRUE;
+                }
+                /* Zero initialize the new part */
+                if (l_new_nb > l_old_nb) {
+                    memset(new_tp_index + l_old_nb, 0,
+                           (OPJ_SIZE_T)(l_new_nb - l_old_nb) * sizeof(opj_tp_index_t));
+                }
+                l_tile_index->tp_index = new_tp_index;
+                l_tile_index->current_nb_tps = l_new_nb;
+            }
+            l_tile_index->tp_index[l_current_tile_part].start_pos = pos;
         }
 
     }
@@ -9780,8 +9824,14 @@ OPJ_BOOL opj_j2k_read_tile_header(opj_j2k_t * p_j2k,
 
             /* Check marker size (does not include marker ID but includes marker size) */
             if (l_marker_size < 2) {
-                opj_event_msg(p_manager, EVT_ERROR, "Inconsistent marker size\n");
-                return OPJ_FALSE;
+                /* When decoding in non-strict mode (for example when decoding
+                 * partial codestreams), consider this as an early end of
+                 * codestream rather than a hard failure.
+                 */
+                opj_event_msg(p_manager, p_j2k->m_cp.strict ? EVT_ERROR : EVT_WARNING,
+                              "Inconsistent marker size\n");
+                p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_NEOC;
+                return p_j2k->m_cp.strict ? OPJ_FALSE : OPJ_TRUE;
             }
 
             /* cf. https://code.google.com/p/openjpeg/issues/detail?id=226 */