diff --git a/src/mms/iso_acse/acse.c b/src/mms/iso_acse/acse.c
index 60b0f53..27eedec 100644
--- a/src/mms/iso_acse/acse.c
+++ b/src/mms/iso_acse/acse.c
@@ -420,6 +420,16 @@ AcseConnection_parseMessage(AcseConnection* self, ByteBuffer* message)
 {
     AcseIndication indication = ACSE_ERROR;
 
+    /* Defensive checks: this function is called with user-controlled network data.
+     * In case of malformed/empty PDUs the ByteBuffer can be NULL/empty.
+     * Prevent NULL dereference and out-of-bounds reads (ASan crash at buffer[0]).
+     */
+    if ((message == NULL) || (message->buffer == NULL) || (message->size < 1)) {
+        if (DEBUG_ACSE)
+            printf("ACSE: AcseConnection_parseMessage: invalid ACSE message!\n");
+        return ACSE_ERROR;
+    }
+
     uint8_t* buffer = message->buffer;
 
     int messageSize = message->size;
@@ -428,6 +438,19 @@ AcseConnection_parseMessage(AcseConnection* self, ByteBuffer* message)
 
     uint8_t messageType = buffer[bufPos++];
 
+    /* Need at least one more byte for the BER length field */
+    if (messageSize < 2) {
+        if (DEBUG_ACSE)
+            printf("ACSE: AcseConnection_parseMessage: invalid ACSE message!\n");
+        return ACSE_ERROR;
+    }
+
+    /* 0x00 is used as an end-of-contents tag with indefinite length BER.
+     * It doesn't represent a valid ACSE PDU here.
+     */
+    if (messageType == 0x00)
+        return ACSE_ERROR;
+
     int len;
 
     bufPos = BerDecoder_decodeLength(buffer, &len, bufPos, messageSize);