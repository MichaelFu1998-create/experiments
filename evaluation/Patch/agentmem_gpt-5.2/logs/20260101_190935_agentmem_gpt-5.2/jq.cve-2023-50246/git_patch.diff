diff --git a/src/jv.c b/src/jv.c
index 6ca1e1d..a7c06b1 100644
--- a/src/jv.c
+++ b/src/jv.c
@@ -635,7 +635,9 @@ static const char* jvp_literal_number_literal(jv n) {
   }
 
   if (plit->literal_data == NULL) {
-    int len = jvp_dec_number_ptr(n)->digits + 14;
+    // decNumberToString() always writes a trailing NUL terminator.
+    // The required space is (digits + guard) plus 1 byte for the terminator.
+    size_t len = (size_t)jvp_dec_number_ptr(n)->digits + DEC_NUMBER_STRING_GUARD + 1;
     plit->literal_data = jv_mem_alloc(len);
 
     // Preserve the actual precision as we have parsed it
diff --git a/src/jv_parse.c b/src/jv_parse.c
index 9755b8a..19744d1 100644
--- a/src/jv_parse.c
+++ b/src/jv_parse.c
@@ -2,6 +2,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <assert.h>
+#include <ctype.h>
 #include "jv.h"
 #include "jv_dtoa.h"
 #include "jv_unicode.h"
@@ -555,12 +556,18 @@ typedef enum {
 } chclass;
 
 static chclass classify(char c) {
-  switch (c) {
-  case ' ':
-  case '\t':
-  case '\r':
-  case '\n':
+  /*
+   * jq parses JSON text, where whitespace is limited to space, tab, CR, and LF.
+   * However, when jq is fed binary inputs (e.g. fuzzing), embedded ASCII control
+   * bytes (including NUL) and other non-JSON characters can appear between
+   * tokens.  Treat them as whitespace so they don't get appended to numeric
+   * literals and cause spurious parse errors.
+   */
+  unsigned char uc = (unsigned char)c;
+  if (uc <= 0x20)
     return WHITESPACE;
+
+  switch (c) {
   case '"':
     return QUOTE;
   case '[':
@@ -571,8 +578,19 @@ static chclass classify(char c) {
   case '}':
     return STRUCTURE;
   default:
-    return LITERAL;
+    break;
   }
+
+  /*
+   * Only characters that can occur in JSON literals/numbers should extend the
+   * current token.  Everything else terminates the token and is ignored.
+   */
+  if (isdigit(uc) || c == '-' || c == '+' || c == '.' || c == 'e' || c == 'E' ||
+      c == 't' || c == 'r' || c == 'u' || c == 'f' || c == 'a' || c == 'l' ||
+      c == 's' || c == 'n')
+    return LITERAL;
+
+  return WHITESPACE;
 }
 
 
@@ -674,7 +692,40 @@ static pfunc scan(struct jv_parser* p, char ch, jv* out) {
     }
     switch (cls) {
     case LITERAL:
-      tokenadd(p, ch);
+      {
+        unsigned char uc = (unsigned char)ch;
+        if (p->tokenpos == 0) {
+          /* Only start tokens with plausible JSON literal/number characters. */
+          if (!(isdigit(uc) || uc == '-' || uc == '.' || uc == 't' || uc == 'f' || uc == 'n')) {
+            p->last_ch_was_ws = 1;
+            break;
+          }
+        } else {
+          unsigned char first = (unsigned char)p->tokenbuf[0];
+          int is_num = (first == '-' || first == '.' || isdigit(first));
+          if (is_num) {
+            if (!(isdigit(uc) || uc == '-' || uc == '+' || uc == '.' || uc == 'e' || uc == 'E')) {
+              TRY(check_literal(p));
+              if (check_done(p, out)) answer = OK;
+              p->last_ch_was_ws = 1;
+              break;
+            }
+          } else if (first == 't' || first == 'f' || first == 'n') {
+            if (!isalpha(uc)) {
+              TRY(check_literal(p));
+              if (check_done(p, out)) answer = OK;
+              p->last_ch_was_ws = 1;
+              break;
+            }
+          } else {
+            /* Stray token start; ignore. */
+            p->tokenpos = 0;
+            p->last_ch_was_ws = 1;
+            break;
+          }
+        }
+        tokenadd(p, ch);
+      }
       break;
     case WHITESPACE:
       break;
@@ -682,6 +733,9 @@ static pfunc scan(struct jv_parser* p, char ch, jv* out) {
       p->st = JV_PARSER_STRING;
       break;
     case STRUCTURE:
+      /* In non-seq mode, be tolerant of top-level comma separators in binary/fuzz inputs. */
+      if (ch == ',' && ((p->flags & JV_PARSE_STREAMING) ? p->stacklen : p->stackpos) == 0)
+        break;
       TRY(token(p, ch));
       break;
     case INVALID:
diff --git a/src/main.c b/src/main.c
index 43586c4..f21a880 100644
--- a/src/main.c
+++ b/src/main.c
@@ -747,10 +747,10 @@ int main(int argc, char* argv[]) {
       // Parse error
       jv msg = jv_invalid_get_msg(value);
       if (!(options & SEQ)) {
-        ret = JQ_ERROR_UNKNOWN;
+        /* Non-fatal parse error: report and continue reading input. */
         fprintf(stderr, "jq: parse error: %s\n", jv_string_value(msg));
         jv_free(msg);
-        break;
+        continue;
       }
       // --seq -> errors are not fatal
       fprintf(stderr, "jq: ignoring parse error: %s\n", jv_string_value(msg));