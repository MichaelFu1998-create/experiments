diff --git a/src/mat5.c b/src/mat5.c
index 2841b58..1b90c90 100644
--- a/src/mat5.c
+++ b/src/mat5.c
@@ -111,8 +111,13 @@ GetTypeBufSize(matvar_t *matvar)
     int    j;
 
     /* Add rank and dimensions, padded to an 8 byte block */
-    for ( j = 0; j < matvar->rank; j++ )
+    for ( j = 0; j < matvar->rank; j++ ) {
+        if ( 0 != matvar->dims[j] && nmemb > SIZE_MAX / matvar->dims[j] ) {
+            Mat_Critical("Dimensions are too large");
+            return 0;
+        }
         nmemb *= matvar->dims[j];
+    }
     if ( matvar->rank % 2 )
         nBytes += tag_size + matvar->rank*4 + 4;
     else
@@ -1482,10 +1487,16 @@ ReadNextStructField( mat_t *mat, matvar_t *matvar )
 {
     int fieldname_size, j;
     size_t bytesread = 0, nfields, nmemb = 1, i;
+    size_t nstruct_elems = 0;
     matvar_t **fields = NULL;
 
-    for ( j = 0; j < matvar->rank; j++ )
+    for ( j = 0; j < matvar->rank; j++ ) {
+        if ( 0 != matvar->dims[j] && nmemb > SIZE_MAX / matvar->dims[j] ) {
+            Mat_Critical("Struct dimensions are too large");
+            return bytesread;
+        }
         nmemb *= matvar->dims[j];
+    }
 
     if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {
 #if defined(HAVE_ZLIB)
@@ -1519,13 +1530,33 @@ ReadNextStructField( mat_t *mat, matvar_t *matvar )
         nfields = uncomp_buf[1];
         nfields = nfields / fieldname_size;
         matvar->data_size = sizeof(matvar_t *);
-
-        if ( nfields*fieldname_size % 8 != 0 )
-            i = 8-(nfields*fieldname_size % 8);
-        else
-            i = 0;
+        /* Protect against integer overflows when computing buffer sizes */
+        {
+            size_t fnbytes;
+            if ( nfields > SIZE_MAX / (size_t)fieldname_size ) {
+                Mat_Critical("Too many struct fields");
+                return bytesread;
+            }
+            fnbytes = nfields * (size_t)fieldname_size;
+            if ( fnbytes % 8 != 0 )
+                i = 8 - (fnbytes % 8);
+            else
+                i = 0;
+        }
         if ( nfields ) {
-            char *ptr = (char*)malloc(nfields*fieldname_size+i);
+            size_t fnbytes;
+            char *ptr = NULL;
+
+            fnbytes = nfields * (size_t)fieldname_size;
+            if ( fnbytes > SIZE_MAX - i ) {
+                Mat_Critical("Too many struct fields");
+                return bytesread;
+            }
+            ptr = (char*)malloc(fnbytes + i);
+            if ( NULL == ptr ) {
+                Mat_Critical("Couldn't allocate memory");
+                return bytesread;
+            }
             bytesread += InflateFieldNames(mat,matvar,ptr,nfields,fieldname_size,i);
             matvar->internal->num_fields = nfields;
             matvar->internal->fieldnames =
@@ -1542,12 +1573,22 @@ ReadNextStructField( mat_t *mat, matvar_t *matvar )
             matvar->internal->num_fields = 0;
             matvar->internal->fieldnames = NULL;
         }
-
-        matvar->nbytes = nmemb*nfields*matvar->data_size;
+        /* Guard against size_t overflow leading to under-allocation */
+        if ( 0 == nmemb || 0 == nfields )
+            return bytesread;
+        if ( nmemb > SIZE_MAX / nfields ) {
+            Mat_Critical("Too many struct elements");
+            return bytesread;
+        }
+        nstruct_elems = nmemb * nfields;
+        if ( nstruct_elems > SIZE_MAX / matvar->data_size ) {
+            Mat_Critical("Too many struct elements");
+            return bytesread;
+        }
+        matvar->nbytes = nstruct_elems * matvar->data_size;
         if ( !matvar->nbytes )
             return bytesread;
-
-        matvar->data = calloc(nmemb*nfields, matvar->data_size);
+        matvar->data = calloc(nstruct_elems, matvar->data_size);
         if ( NULL == matvar->data ) {
             Mat_Critical("Couldn't allocate memory for the data");
             return bytesread;
@@ -1561,8 +1602,7 @@ ReadNextStructField( mat_t *mat, matvar_t *matvar )
                 fields[i*nfields+k]->name = strdup(matvar->internal->fieldnames[k]);
             }
         }
-
-        for ( i = 0; i < nmemb*nfields; i++ ) {
+        for ( i = 0; i < nstruct_elems; i++ ) {
             /* Read variable tag for struct field */
             bytesread += InflateVarTag(mat,matvar,uncomp_buf);
             if ( mat->byteswap ) {
@@ -1615,17 +1655,43 @@ ReadNextStructField( mat_t *mat, matvar_t *matvar )
                 }
                 /* Rank and dimension */
                 if ( uncomp_buf[0] == MAT_T_INT32 ) {
+                    size_t dim_bytes = uncomp_buf[1];
+                    size_t rank;
+
+                    if ( 0 != (dim_bytes % 4) ) {
+                        Mat_Critical("Invalid dimensions size");
+                        bytesread += InflateSkip(mat,matvar->internal->z,nbytes);
+                        continue;
+                    }
+                    rank = dim_bytes / 4;
+                    /* uncomp_buf has room for 14 dimension values (16-2) */
+                    if ( rank > (sizeof(uncomp_buf)/sizeof(uncomp_buf[0]) - 2) ) {
+                        Mat_Critical("Rank too large for struct field");
+                        bytesread += InflateSkip(mat,matvar->internal->z,nbytes);
+                        continue;
+                    }
+
                     j = 0;
-                    fields[i]->rank = uncomp_buf[1];
-                    nbytes -= fields[i]->rank;
-                    fields[i]->rank /= 4;
+                    fields[i]->rank = rank;
+                    /* Subtract payload bytes for dimensions */
+                    if ( (size_t)nbytes < dim_bytes ) {
+                        Mat_Critical("Invalid struct field size");
+                        bytesread += InflateSkip(mat,matvar->internal->z,nbytes);
+                        continue;
+                    }
+                    nbytes -= (int)dim_bytes;
                     fields[i]->dims = (size_t*)malloc(fields[i]->rank*
                                              sizeof(*fields[i]->dims));
+                    if ( NULL == fields[i]->dims ) {
+                        Mat_Critical("Couldn't allocate memory");
+                        bytesread += InflateSkip(mat,matvar->internal->z,nbytes);
+                        continue;
+                    }
                     if ( mat->byteswap ) {
-                        for ( j = 0; j < fields[i]->rank; j++ )
+                        for ( j = 0; j < (int)fields[i]->rank; j++ )
                             fields[i]->dims[j] = Mat_uint32Swap(uncomp_buf+2+j);
                     } else {
-                        for ( j = 0; j < fields[i]->rank; j++ )
+                        for ( j = 0; j < (int)fields[i]->rank; j++ )
                             fields[i]->dims[j] = uncomp_buf[2+j];
                     }
                     if ( fields[i]->rank % 2 != 0 )
@@ -1719,17 +1785,35 @@ ReadNextStructField( mat_t *mat, matvar_t *matvar )
             matvar->internal->num_fields = 0;
             matvar->internal->fieldnames = NULL;
         }
-
-        if ( (nfields*fieldname_size) % 8 ) {
-            (void)fseek((FILE*)mat->fp,8-((nfields*fieldname_size) % 8),SEEK_CUR);
-            bytesread+=8-((nfields*fieldname_size) % 8);
+        {
+            size_t fnbytes;
+            if ( nfields > SIZE_MAX / (size_t)fieldname_size ) {
+                Mat_Critical("Too many struct fields");
+                return bytesread;
+            }
+            fnbytes = nfields * (size_t)fieldname_size;
+            if ( fnbytes % 8 ) {
+                size_t pad = 8 - (fnbytes % 8);
+                (void)fseek((FILE*)mat->fp,(long)pad,SEEK_CUR);
+                bytesread += pad;
+            }
         }
-
-        matvar->nbytes = nmemb*nfields*matvar->data_size;
+        /* Guard against size_t overflow leading to under-allocation */
+        if ( 0 == nmemb || 0 == nfields )
+            return bytesread;
+        if ( nmemb > SIZE_MAX / nfields ) {
+            Mat_Critical("Too many struct elements");
+            return bytesread;
+        }
+        nstruct_elems = nmemb * nfields;
+        if ( nstruct_elems > SIZE_MAX / matvar->data_size ) {
+            Mat_Critical("Too many struct elements");
+            return bytesread;
+        }
+        matvar->nbytes = nstruct_elems * matvar->data_size;
         if ( !matvar->nbytes )
             return bytesread;
-
-        matvar->data = malloc(matvar->nbytes);
+        matvar->data = calloc(nstruct_elems, matvar->data_size);
         if ( NULL == matvar->data )
             return bytesread;
 
@@ -1741,8 +1825,7 @@ ReadNextStructField( mat_t *mat, matvar_t *matvar )
                 fields[i*nfields+k]->name = strdup(matvar->internal->fieldnames[k]);
             }
         }
-
-        for ( i = 0; i < nmemb*nfields; i++ ) {
+        for ( i = 0; i < nstruct_elems; i++ ) {
             /* Read variable tag for struct field */
             bytesread += fread(buf,4,2,(FILE*)mat->fp);
             if ( mat->byteswap ) {