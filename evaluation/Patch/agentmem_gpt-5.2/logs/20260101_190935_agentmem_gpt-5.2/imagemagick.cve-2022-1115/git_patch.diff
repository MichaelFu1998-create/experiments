diff --git a/coders/tiff.c b/coders/tiff.c
index 31839f67e..a14ec7253 100644
--- a/coders/tiff.c
+++ b/coders/tiff.c
@@ -1182,11 +1182,54 @@ static void TIFFReadPhotoshopLayers(const ImageInfo *image_info,Image *image,
 }
 #endif
 
+
+/*
+  Return the minimum number of bytes required to import a single row of pixels
+  for the given quantum type. The quantum import routines advance the source
+  pointer based on quantum_info->depth/pack and also add quantum_info->pad bytes
+  per pixel.
+*/
+static inline size_t GetQuantumRowExtent(const QuantumInfo *quantum_info,
+  const QuantumType quantum_type,const size_t columns)
+{
+  size_t
+    extent,
+    packet_size;
+
+  packet_size=1;
+  switch (quantum_type)
+  {
+    case GrayAlphaQuantum: packet_size=2; break;
+    case IndexAlphaQuantum: packet_size=2; break;
+    case RGBQuantum: packet_size=3; break;
+    case BGRQuantum: packet_size=3; break;
+    case RGBAQuantum: packet_size=4; break;
+    case RGBOQuantum: packet_size=4; break;
+    case BGRAQuantum: packet_size=4; break;
+    case CMYKQuantum: packet_size=4; break;
+    case CMYKAQuantum: packet_size=5; break;
+    case CbYCrAQuantum: packet_size=4; break;
+    case CbYCrQuantum: packet_size=3; break;
+    case CbYCrYQuantum: packet_size=4; break;
+    default: break;
+  }
+  if (quantum_info->pack == MagickFalse)
+    extent=(size_t) (packet_size*columns*((quantum_info->depth+7)/8));
+  else
+    extent=(size_t) ((packet_size*columns*quantum_info->depth+7)/8);
+  extent+=(size_t) columns*quantum_info->pad;
+  return(extent);
+}
+
 static Image *ReadTIFFImage(const ImageInfo *image_info,
   ExceptionInfo *exception)
 {
 #define ThrowTIFFException(severity,message) \
 { \
+  if (tile_pixels != (unsigned char *) NULL) \
+    tile_pixels=(unsigned char *) RelinquishMagickMemory(tile_pixels); \
+  if (strip_pixels != (unsigned char *) NULL) \
+    strip_pixels=(unsigned char *) RelinquishMagickMemory(strip_pixels); \
   if (pixel_info != (MemoryInfo *) NULL) \
     pixel_info=RelinquishVirtualMemory(pixel_info); \
   if (quantum_info != (QuantumInfo *) NULL) \
@@ -1260,7 +1303,9 @@ static Image *ReadTIFFImage(const ImageInfo *image_info,
     width;
 
   unsigned char
-    *pixels;
+    *pixels,
+    *strip_pixels = (unsigned char *) NULL,
+    *tile_pixels = (unsigned char *) NULL;
 
   void
     *sans[8] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };
@@ -1881,9 +1926,6 @@ static Image *ReadTIFFImage(const ImageInfo *image_info,
         tsize_t
           strip_size;
 
-        unsigned char
-          *strip_pixels;
-
         /*
           Convert stripped TIFF image.
         */
@@ -1921,6 +1963,18 @@ static Image *ReadTIFFImage(const ImageInfo *image_info,
             case 4: quantum_type=AlphaQuantum; break;
             default: break;
           }
+          size_t
+            quantum_extent;
+
+          unsigned char
+            *quantum_pixels;
+
+          quantum_extent=GetQuantumRowExtent(quantum_info,quantum_type,
+            (size_t) image->columns);
+          quantum_pixels=(unsigned char *) AcquireQuantumMemory(quantum_extent,
+            sizeof(*quantum_pixels));
+          if (quantum_pixels == (unsigned char *) NULL)
+            ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
           rows_remaining=0;
           for (y=0; y < (ssize_t) image->rows; y++)
           {
@@ -1943,8 +1997,25 @@ static Image *ReadTIFFImage(const ImageInfo *image_info,
                 p=strip_pixels;
                 strip_id++;
               }
-            (void) ImportQuantumPixels(image,(CacheView *) NULL,
-              quantum_info,quantum_type,p,exception);
+            {
+              size_t
+                available,
+                bytes_to_copy,
+                offset;
+
+              offset=(size_t) (p-strip_pixels);
+              available=offset < extent ? extent-offset : 0;
+              bytes_to_copy=(size_t) stride;
+              if (bytes_to_copy > quantum_extent)
+                bytes_to_copy=quantum_extent;
+              if (bytes_to_copy > available)
+                bytes_to_copy=available;
+              (void) memset(quantum_pixels,0,quantum_extent*sizeof(*quantum_pixels));
+              if (bytes_to_copy != 0)
+                (void) memcpy(quantum_pixels,p,bytes_to_copy*sizeof(*quantum_pixels));
+              (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
+                quantum_type,quantum_pixels,exception);
+            }
             p+=stride;
             rows_remaining--;
             if (SyncAuthenticPixels(image,exception) == MagickFalse)
@@ -1975,9 +2046,6 @@ static Image *ReadTIFFImage(const ImageInfo *image_info,
           columns,
           rows;
 
-        unsigned char
-          *tile_pixels;
-
         /*
           Convert tiled TIFF image.
         */
@@ -2049,9 +2117,46 @@ static Image *ReadTIFFImage(const ImageInfo *image_info,
                   exception);
                 if (q == (Quantum *) NULL)
                   break;
-                (void) ImportQuantumPixels(image,(CacheView *) NULL,
-                  quantum_info,quantum_type,p,exception);
-                p+=TIFFTileRowSize(tiff);
+                {
+                  unsigned char
+                    *quantum_pixels;
+
+                  size_t
+                    quantum_extent,
+                    bytes_to_copy,
+                    offset,
+                    row_size;
+
+                  row_size=(size_t) TIFFTileRowSize(tiff);
+                  quantum_extent=GetQuantumRowExtent(quantum_info,quantum_type,
+                    (size_t) columns_remaining);
+                  bytes_to_copy=row_size;
+                  if (bytes_to_copy > quantum_extent)
+                    bytes_to_copy=quantum_extent;
+                  offset=(size_t) (p-tile_pixels);
+                  if (offset < extent)
+                    {
+                      size_t
+                        available;
+
+                      available=extent-offset;
+                      if (bytes_to_copy > available)
+                        bytes_to_copy=available;
+                    }
+                  else
+                    bytes_to_copy=0;
+                  quantum_pixels=(unsigned char *) AcquireQuantumMemory(quantum_extent,
+                    sizeof(*quantum_pixels));
+                  if (quantum_pixels == (unsigned char *) NULL)
+                    ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
+                  (void) memset(quantum_pixels,0,quantum_extent*sizeof(*quantum_pixels));
+                  if (bytes_to_copy != 0)
+                    (void) memcpy(quantum_pixels,p,bytes_to_copy*sizeof(*quantum_pixels));
+                  (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
+                    quantum_type,quantum_pixels,exception);
+                  quantum_pixels=(unsigned char *) RelinquishMagickMemory(quantum_pixels);
+                  p+=row_size;
+                }
                 if (SyncAuthenticPixels(image,exception) == MagickFalse)
                   break;
               }
@@ -3339,7 +3444,9 @@ static MagickBooleanType WriteTIFFImage(const ImageInfo *image_info,
     predictor;
 
   unsigned char
-    *pixels;
+    *pixels,
+    *strip_pixels = (unsigned char *) NULL,
+    *tile_pixels = (unsigned char *) NULL;
 
   void
     *sans[2] = { NULL, NULL };