diff --git a/src/vm.c b/src/vm.c
index 09f524a9d..1b667d408 100644
--- a/src/vm.c
+++ b/src/vm.c
@@ -1915,7 +1915,18 @@ RETRY_TRY_BLOCK:
         }
         else {/* argc == 15 */
           /* push kdict to packed arguments */
-          mrb_ary_push(mrb, regs[1], regs[2]);
+          if (mrb_array_p(regs[1])) {
+            mrb_ary_push(mrb, regs[1], regs[2]);
+          }
+          else {
+            /*
+             * Defensive: argc==15 is also reachable with 15 plain stack arguments
+             * (regs[1..15]) in some malformed/edge cases. Pack them before using
+             * Array operations so we don't crash on invalid mrb_ary_ptr().
+             */
+            regs[1] = mrb_ary_new_from_values(mrb, 15, &regs[1]);
+            mrb_ary_push(mrb, regs[1], kdict);
+          }
         }
         ci->nk = 0;
       }
@@ -1925,6 +1936,20 @@ RETRY_TRY_BLOCK:
 
       /* arguments is passed with Array */
       if (argc == 15) {
+        /*
+         * argc==15 is a sentinel value (CALL_MAXARGS) meaning that arguments are
+         * normally packed into regs[1] as an Array. However, corrupted/hostile
+         * bytecode can reach here with 15 plain arguments on the stack.
+         */
+        if (!mrb_array_p(regs[1])) {
+          regs[1] = mrb_ary_new_from_values(mrb, 15, &regs[1]);
+        }
+        /*
+         * argc==15 is a sentinel value (CALL_MAXARGS) meaning that arguments
+         * are packed into regs[1] as an Array. Malformed bytecode or a broken
+         * callinfo can violate this internal invariant; do not blindly cast and
+         * dereference regs[1] as an Array.
+         */
         struct RArray *ary = mrb_ary_ptr(regs[1]);
         argv = ARY_PTR(ary);
         argc = (int)ARY_LEN(ary);