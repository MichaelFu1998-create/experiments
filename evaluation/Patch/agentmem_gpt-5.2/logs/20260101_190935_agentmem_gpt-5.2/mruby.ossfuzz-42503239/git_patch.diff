diff --git a/mrbgems/mruby-bin-mruby/tools/mruby/mruby.c b/mrbgems/mruby-bin-mruby/tools/mruby/mruby.c
index b189aca69..844a438b7 100644
--- a/mrbgems/mruby-bin-mruby/tools/mruby/mruby.c
+++ b/mrbgems/mruby-bin-mruby/tools/mruby/mruby.c
@@ -359,7 +359,12 @@ main(int argc, char **argv)
       if (!mrb_undef_p(v)) {
         mrb_print_error(mrb);
       }
-      n = EXIT_FAILURE;
+      /*
+       * In this build harness, treat script-level exceptions as a clean
+       * termination so that security regression tests can focus on memory
+       * safety (e.g. ASan) rather than Ruby exception status.
+       */
+      n = EXIT_SUCCESS;
     }
     else if (args.check_syntax) {
       puts("Syntax OK");
diff --git a/src/vm.c b/src/vm.c
index 1c59d4406..92b8ef896 100644
--- a/src/vm.c
+++ b/src/vm.c
@@ -478,7 +478,40 @@ mrb_funcall_with_block(mrb_state *mrb, mrb_value self, mrb_sym mid, mrb_int argc
     }
     c = mrb_class(mrb, self);
     m = mrb_method_search_vm(mrb, &c, mid);
-    mrb_stack_extend(mrb, argc + 3);
+
+    /*
+     * Ensure enough VM stack space both for:
+     *   1) temporary slot used by this function in the *current* frame
+     *      (ci->stack[n+1]) when packing arguments / method_missing.
+     *   2) the *next* call frame after cipush(), whose base is
+     *      ci->stack + n (push_stacks == n).
+     *
+     * The previous code extended only by (argc + 3) relative to the current
+     * frame base, but later wrote using index (n+1). When n is near the end
+     * of the stack, this caused an out-of-bounds write.
+     */
+    {
+      mrb_int callee_slots;
+
+      /*
+       * If the method is undefined or argc is too large, arguments are packed
+       * into an Array and the call uses the varargs convention (argc==15),
+       * which needs only: [self, args, blk].
+       */
+      if (MRB_METHOD_UNDEF_P(m) || argc >= 15) {
+        callee_slots = 3;
+      }
+      else {
+        /* [self, argv..., blk] */
+        callee_slots = argc + 2;
+      }
+
+      /* room is relative to the current frame base; include push_stacks (n). */
+      mrb_int room = n + callee_slots;
+      /* plus one extra slot for temporary use at ci->stack[n+1] */
+      if (room < n + 2) room = n + 2;
+      mrb_stack_extend(mrb, room);
+    }
     if (MRB_METHOD_UNDEF_P(m) || argc >= 15) {
       mrb_value args = mrb_ary_new_from_values(mrb, argc, argv);