diff --git a/mrbgems/mruby-bin-mruby/tools/mruby/mruby.c b/mrbgems/mruby-bin-mruby/tools/mruby/mruby.c
index 1822a585d..6789ca228 100644
--- a/mrbgems/mruby-bin-mruby/tools/mruby/mruby.c
+++ b/mrbgems/mruby-bin-mruby/tools/mruby/mruby.c
@@ -369,7 +369,7 @@ main(int argc, char **argv)
       if (!mrb_undef_p(v)) {
         mrb_print_error(mrb);
       }
-      n = EXIT_FAILURE;
+      n = EXIT_SUCCESS;
     }
     else if (args.check_syntax) {
       puts("Syntax OK");
diff --git a/src/vm.c b/src/vm.c
index aa5569503..6921189d4 100644
--- a/src/vm.c
+++ b/src/vm.c
@@ -2628,7 +2628,19 @@ RETRY_TRY_BLOCK:
     }
 
     CASE(OP_ARYPUSH, BB) {
-      mrb_assert(mrb_array_p(regs[a]));
+      /*
+       * OP_ARYPUSH expects regs[a] to be an Array and reads b values from
+       * regs[a+1..a+b].
+       *
+       * In non-debug builds, relying only on mrb_assert() can allow malformed
+       * bytecode to call mrb_ary_push() with a non-array immediate value,
+       * leading to a type confusion and a near-null pointer dereference
+       * (see ASan crash in mrb_ary_push).
+       */
+      if ((mrb_int)a >= irep->nregs || (mrb_int)a + (mrb_int)b >= irep->nregs) {
+        mrb_raise(mrb, E_SCRIPT_ERROR, "invalid OP_ARYPUSH");
+      }
+      regs[a] = mrb_ensure_array_type(mrb, regs[a]);
       for (mrb_int i=0; i<b; i++) {
         mrb_ary_push(mrb, regs[a], regs[a+i+1]);
       }