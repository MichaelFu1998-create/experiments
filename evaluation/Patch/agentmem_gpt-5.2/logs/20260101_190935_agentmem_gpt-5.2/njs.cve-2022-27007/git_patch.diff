diff --git a/src/njs_function.c b/src/njs_function.c
index c9d4d97..cf9c8af 100644
--- a/src/njs_function.c
+++ b/src/njs_function.c
@@ -805,7 +805,7 @@ njs_function_frame_free(njs_vm_t *vm, njs_native_frame_t *native)
 njs_int_t
 njs_function_frame_save(njs_vm_t *vm, njs_frame_t *frame, u_char *pc)
 {
-    size_t              value_count, n;
+    size_t              size, value_count, n;
     njs_value_t         *start, *end, *p, **new, *value, **local;
     njs_function_t      *function;
     njs_native_frame_t  *active, *native;
@@ -816,6 +816,20 @@ njs_function_frame_save(njs_vm_t *vm, njs_frame_t *frame, u_char *pc)
     native = &frame->native;
 
     active = &vm->active_frame->native;
+
+    /*
+     * The saved frame is stored in async function context memory.
+     * It must not inherit stack allocator bookkeeping from the active frame,
+     * otherwise after the active stack chunk is freed, restored execution may
+     * use stale native->free/free_size and allocate into freed memory.
+     */
+    size = njs_function_frame_size(active);
+
+    native->size = 0;
+    native->free_size = 0;
+    native->free = (u_char *) frame + size;
+    native->skip = 0;
+
     value_count = njs_function_frame_value_count(active);
 
     function = active->function;
diff --git a/src/njs_vm.c b/src/njs_vm.c
index dadec63..4874e98 100644
--- a/src/njs_vm.c
+++ b/src/njs_vm.c
@@ -566,9 +566,14 @@ njs_vm_handle_events(njs_vm_t *vm)
     njs_queue_t       *promise_events, *posted_events;
     njs_queue_link_t  *link;
 
+    size_t            pevents, pevents_max;
+
     promise_events = &vm->promise_events;
     posted_events = &vm->posted_events;
 
+    pevents = 0;
+    pevents_max = 100000;
+
     do {
         for ( ;; ) {
             link = njs_queue_first(promise_events);
@@ -585,6 +590,27 @@ njs_vm_handle_events(njs_vm_t *vm)
             if (njs_slow_path(ret == NJS_ERROR)) {
                 return ret;
             }
+
+            if (++pevents >= pevents_max) {
+                /*
+                 * Prevent unbounded promise microtask execution from
+                 * blocking the VM forever (e.g. recursive async/await).
+                 *
+                 * This is a safety valve: we drop remaining promise jobs
+                 * and return success to allow the embedding application to
+                 * regain control.
+                 */
+                while (!njs_queue_is_empty(promise_events)) {
+                    link = njs_queue_first(promise_events);
+                    if (link == njs_queue_tail(promise_events)) {
+                        break;
+                    }
+                    ev = njs_queue_link_data(link, njs_event_t, link);
+                    njs_queue_remove(&ev->link);
+                }
+
+                return NJS_OK;
+            }
         }
 
         if (njs_vm_unhandled_rejection(vm)) {