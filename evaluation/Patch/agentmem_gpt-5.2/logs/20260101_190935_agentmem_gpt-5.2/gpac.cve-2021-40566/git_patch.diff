diff --git a/src/filters/reframe_mpgvid.c b/src/filters/reframe_mpgvid.c
index 308546f28..09574131f 100644
--- a/src/filters/reframe_mpgvid.c
+++ b/src/filters/reframe_mpgvid.c
@@ -27,6 +27,7 @@
 #include <gpac/constants.h>
 #include <gpac/filters.h>
 #include <gpac/internal/media_dev.h>
+#include <stddef.h>
 
 #ifndef GPAC_DISABLE_AV_PARSERS
 
@@ -521,6 +522,7 @@ GF_Err mpgviddmx_process(GF_Filter *filter)
 	s64 vosh_end = -1;
 	GF_Err e;
 	char *data;
+	Bool data_in_hdr_store = GF_FALSE;
 	u8 *start;
 	u32 pck_size;
 	s32 remain;
@@ -593,6 +595,7 @@ GF_Err mpgviddmx_process(GF_Filter *filter)
 		ctx->hdr_store_size += pck_size;
 		start = data = ctx->hdr_store;
 		remain = pck_size = ctx->hdr_store_size;
+		data_in_hdr_store = GF_TRUE;
 	}
 
 	if (ctx->resume_from) {
@@ -604,6 +607,7 @@ GF_Err mpgviddmx_process(GF_Filter *filter)
 			assert(ctx->resume_from <= ctx->hdr_store_size);
 			start = data = ctx->hdr_store + ctx->resume_from;
 			remain = pck_size = ctx->hdr_store_size - ctx->resume_from;
+			data_in_hdr_store = GF_TRUE;
 		} else {
 			assert(remain >= (s32) ctx->resume_from);
 			start += ctx->resume_from;
@@ -804,12 +808,21 @@ GF_Err mpgviddmx_process(GF_Filter *filter)
 				e = gf_m4v_parse_config(ctx->vparser, &ctx->dsi);
 				//not enough data, accumulate until we can parse the full header
 				if (e==GF_EOS) {
+					char *old_store = ctx->hdr_store;
+					ptrdiff_t data_off = 0;
+					if (data_in_hdr_store && old_store) {
+						data_off = data - old_store;
+					}
 					if (vosh_start<0) vosh_start = 0;
 					if (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {
 						ctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - vosh_start);
 						ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);
+						if (!ctx->hdr_store) return GF_OUT_OF_MEM;
+					}
+					if (data_in_hdr_store && old_store) {
+						data = ctx->hdr_store + data_off;
 					}
-					memcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );
+					memmove(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );
 					ctx->hdr_store_size += pck_size - (u32) vosh_start;
 					gf_filter_pid_drop_packet(ctx->ipid);
 					return GF_OK;
@@ -843,12 +856,21 @@ GF_Err mpgviddmx_process(GF_Filter *filter)
 				ctx->dsi.VideoPL = PL;
 				//not enough data, accumulate until we can parse the full header
 				if (e==GF_EOS) {
+					char *old_store = ctx->hdr_store;
+					ptrdiff_t data_off = 0;
+					if (data_in_hdr_store && old_store) {
+						data_off = data - old_store;
+					}
 					if (vosh_start<0) vosh_start = 0;
 					if (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {
 						ctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - (u32) vosh_start);
 						ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);
+						if (!ctx->hdr_store) return GF_OUT_OF_MEM;
+					}
+					if (data_in_hdr_store && old_store) {
+						data = ctx->hdr_store + data_off;
 					}
-					memcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );
+					memmove(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );
 					ctx->hdr_store_size += pck_size - (u32) vosh_start;
 					gf_filter_pid_drop_packet(ctx->ipid);
 					return GF_OK;