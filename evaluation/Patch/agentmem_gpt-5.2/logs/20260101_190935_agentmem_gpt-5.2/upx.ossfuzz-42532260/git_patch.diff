diff --git a/src/p_lx_elf.cpp b/src/p_lx_elf.cpp
index a3178d18..737b4154 100644
--- a/src/p_lx_elf.cpp
+++ b/src/p_lx_elf.cpp
@@ -2351,9 +2351,34 @@ char const *PackLinuxElf64::get_str_name(unsigned st_name, unsigned symnum) cons
             "bad .st_name %#x in DT_SYMTAB[%d]", st_name, symnum);
         throwCantPack(msg);
     }
-    return &dynstr[st_name];
+    // dynstr points into the mapped/loaded ELF image. Do not assume strings are
+    // NUL-terminated: crafted/malformed DT_STRTAB/DT_STRSZ data can otherwise
+    // make strcmp/strlen scan past the end of the file buffer.
+    char const *const p = &dynstr[st_name];
+    char const *const base = (char const *)(void const *)file_image;
+    char const *const end  = base + (size_t)file_size;
+    if (p < base || end <= p) {
+        char msg[90]; snprintf(msg, sizeof(msg),
+            "bad DT_STRTAB/.st_name %#x in DT_SYMTAB[%d]", st_name, symnum);
+        throwCantPack(msg);
+    }
+    size_t const max_len = (size_t)(strtab_end - st_name);
+    size_t const avail   = (size_t)(end - p);
+    if (avail < max_len) {
+        char msg[90]; snprintf(msg, sizeof(msg),
+            "bad DT_STRTAB/DT_STRSZ %#x at .st_name %#x", strtab_end, st_name);
+        throwCantPack(msg);
+    }
+    if (nullptr == memchr(p, '\0', max_len)) {
+        char msg[90]; snprintf(msg, sizeof(msg),
+            "unterminated dynstr at .st_name %#x in DT_SYMTAB[%d]", st_name, symnum);
+        throwCantPack(msg);
+    }
+    return p;
+
 }
 
+
 char const *PackLinuxElf64::get_dynsym_name(unsigned symnum, unsigned relnum) const
 {
     if (symnum_end <= symnum) {
@@ -2388,9 +2413,34 @@ char const *PackLinuxElf32::get_str_name(unsigned st_name, unsigned symnum) cons
             "bad .st_name %#x in DT_SYMTAB[%d]\n", st_name, symnum);
         throwCantPack(msg);
     }
-    return &dynstr[st_name];
+    // dynstr points into the mapped/loaded ELF image. Do not assume strings are
+    // NUL-terminated: crafted/malformed DT_STRTAB/DT_STRSZ data can otherwise
+    // make strcmp/strlen scan past the end of the file buffer.
+    char const *const p = &dynstr[st_name];
+    char const *const base = (char const *)(void const *)file_image;
+    char const *const end  = base + (size_t)file_size;
+    if (p < base || end <= p) {
+        char msg[90]; snprintf(msg, sizeof(msg),
+            "bad DT_STRTAB/.st_name %#x in DT_SYMTAB[%d]", st_name, symnum);
+        throwCantPack(msg);
+    }
+    size_t const max_len = (size_t)(strtab_end - st_name);
+    size_t const avail   = (size_t)(end - p);
+    if (avail < max_len) {
+        char msg[90]; snprintf(msg, sizeof(msg),
+            "bad DT_STRTAB/DT_STRSZ %#x at .st_name %#x", strtab_end, st_name);
+        throwCantPack(msg);
+    }
+    if (nullptr == memchr(p, '\0', max_len)) {
+        char msg[90]; snprintf(msg, sizeof(msg),
+            "unterminated dynstr at .st_name %#x in DT_SYMTAB[%d]\n", st_name, symnum);
+        throwCantPack(msg);
+    }
+    return p;
+
 }
 
+
 char const *PackLinuxElf32::get_dynsym_name(unsigned symnum, unsigned relnum) const
 {
     if (symnum_end <= symnum) {
diff --git a/src/util/util.cpp b/src/util/util.cpp
index 507195ac..36253056 100644
--- a/src/util/util.cpp
+++ b/src/util/util.cpp
@@ -278,7 +278,7 @@ void upx_memswap(void *a, void *b, size_t n) {
 
 // much better memswap(), optimized for our use case in sort functions below
 static void memswap_no_overlap(byte *a, byte *b, size_t n) {
-#if defined(__clang__) && __clang_major__ < 15
+#if defined(__clang__)
     // work around a clang < 15 ICE (Internal Compiler Error)
     // @COMPILER_BUG @CLANG_BUG
     upx_memswap(a, b, n);