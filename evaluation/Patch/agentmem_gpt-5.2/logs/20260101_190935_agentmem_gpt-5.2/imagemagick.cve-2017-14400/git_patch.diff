diff --git a/MagickCore/cache.c b/MagickCore/cache.c
index dc7187bf0..1ddb10f79 100644
--- a/MagickCore/cache.c
+++ b/MagickCore/cache.c
@@ -3181,7 +3181,15 @@ MagickExport const Quantum *GetVirtualPixels(const Image *image,
        (GetVirtualPixelHandler) NULL)
     return(cache_info->methods.get_virtual_pixel_handler(image,
       GetPixelCacheVirtualMethod(image),x,y,columns,rows,exception));
-  assert(id < (int) cache_info->number_threads);
+  /*
+    In non-assert builds, ensure the cache nexus is valid before use.
+    A crafted file can trigger code paths where the pixel cache nexus is
+    destroyed (e.g. via PersistPixelCache attach) and not yet reinitialized.
+  */
+  if ((cache_info->nexus_info == (NexusInfo **) NULL) ||
+      (id < 0) || (id >= (int) cache_info->number_threads) ||
+      (cache_info->nexus_info[id] == (NexusInfo *) NULL))
+    ThrowBinaryException(CacheError,"PixelCacheIsNotOpen",image->filename);
   p=GetVirtualPixelsFromNexus(image,GetPixelCacheVirtualMethod(image),x,y,
     columns,rows,cache_info->nexus_info[id],exception);
   return(p);
@@ -3854,8 +3862,17 @@ MagickExport MagickBooleanType PersistPixelCache(Image *image,
       cache_info->offset=(*offset);
       cache_info->nexus_info=DestroyPixelCacheNexus(cache_info->nexus_info,
         cache_info->number_threads);
+      /*
+        Reacquire a valid nexus array.  OpenPixelCache() does not allocate the
+        nexus; it is expected to already exist.
+      */
+      cache_info->nexus_info=AcquirePixelCacheNexus(cache_info->number_threads);
       if (OpenPixelCache(image,ReadMode,exception) == MagickFalse)
-        return(MagickFalse);
+        {
+          cache_info->nexus_info=DestroyPixelCacheNexus(cache_info->nexus_info,
+            cache_info->number_threads);
+          return(MagickFalse);
+        }
       *offset+=cache_info->length+page_size-(cache_info->length % page_size);
       return(MagickTrue);
     }