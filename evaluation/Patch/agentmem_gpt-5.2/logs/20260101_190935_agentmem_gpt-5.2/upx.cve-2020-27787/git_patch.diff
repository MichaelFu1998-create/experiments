diff --git a/src/p_lx_elf.cpp b/src/p_lx_elf.cpp
index 96f5838d..ddd3b70b 100644
--- a/src/p_lx_elf.cpp
+++ b/src/p_lx_elf.cpp
@@ -1568,13 +1568,48 @@ PackLinuxElf64arm::buildLoader(const Filter *ft)
 void
 PackLinuxElf32::invert_pt_dynamic(Elf32_Dyn const *dynp)
 {
+    // Defensive: dynp must point into a currently valid buffer (file_image or ibuf).
+    // Malformed input can otherwise create an invalid Dyn* and crash in get_te32().
+    if (dynp) {
+        upx_uint64_t maxlen = sz_dynseg;
+        bool ok = false;
+        unsigned char const *p = (unsigned char const *)(void const *)dynp;
+        if (file_image) {
+            unsigned char const *base = (unsigned char const *)file_image;
+            unsigned char const *end  = base + file_image.getSize();
+            if (p >= base && p < end) {
+                upx_uint64_t avail = (upx_uint64_t)(end - p);
+                if (avail >= sizeof(*dynp)) {
+                    if (maxlen > avail) maxlen = avail;
+                    ok = true;
+                }
+            }
+        }
+        if (!ok) {
+            unsigned char const *base = (unsigned char const *)ibuf.getVoidPtr();
+            unsigned char const *end  = base + ibuf.getSize();
+            if (base && p >= base && p < end) {
+                upx_uint64_t avail = (upx_uint64_t)(end - p);
+                if (avail >= sizeof(*dynp)) {
+                    if (maxlen > avail) maxlen = avail;
+                    ok = true;
+                }
+            }
+        }
+        if (!ok) {
+            throwCantPack("bad PT_DYNAMIC");
+        }
+        sz_dynseg = (unsigned)maxlen;
+    }
+
     if (dt_table[Elf32_Dyn::DT_NULL]) {
         return;  // not 1st time; do not change upx_dt_init
     }
     Elf32_Dyn const *const dynp0 = dynp;
     unsigned ndx = 1+ 0;
     if (dynp)
-    for (; ; ++ndx, ++dynp) {
+    for (; (upx_uint64_t)((char const *)dynp - (char const *)dynp0) + sizeof(*dynp) <= sz_dynseg
+            ; ++ndx, ++dynp) {
         unsigned const d_tag = get_te32(&dynp->d_tag);
         if (d_tag < DT_NUM) {
             if (Elf32_Dyn::DT_NEEDED != d_tag
@@ -1592,6 +1627,9 @@ PackLinuxElf32::invert_pt_dynamic(Elf32_Dyn const *dynp)
             break;  // check here so that dt_table[DT_NULL] is set
         }
     }
+    if (!dt_table[Elf32_Dyn::DT_NULL]) {
+        throwCantPack("bad PT_DYNAMIC: missing DT_NULL");
+    }
     upx_dt_init = 0;
          if (dt_table[Elf32_Dyn::DT_INIT])          upx_dt_init = Elf32_Dyn::DT_INIT;
     else if (dt_table[Elf32_Dyn::DT_PREINIT_ARRAY]) upx_dt_init = Elf32_Dyn::DT_PREINIT_ARRAY;
@@ -4486,7 +4524,15 @@ void PackLinuxElf64::unpack(OutputFile *fo)
 
         // The first PT_LOAD.  Part is not compressed (for benefit of rtld.)
         fi->seek(0, SEEK_SET);
-        fi->readx(ibuf, get_te64(&dynhdr->p_offset) + get_te64(&dynhdr->p_filesz));
+        {
+            upx_uint64_t const t_len = get_te64(&dynhdr->p_offset) + get_te64(&dynhdr->p_filesz);
+            if (t_len < get_te64(&dynhdr->p_offset)
+            ||  t_len > (upx_uint64_t)ibuf.getSize()
+            ||  t_len > (upx_uint64_t)0x7fffffffUL) {
+                throwCantUnpack("bad PT_DYNAMIC");
+            }
+            fi->readx(ibuf, (int)t_len);
+        }
         overlay_offset -= sizeof(linfo);
         xct_off = overlay_offset;
         e_shoff = get_te64(&ehdri.e_shoff);
@@ -4644,7 +4690,12 @@ void PackLinuxElf64::unpack(OutputFile *fo)
                 load_off = get_te64(&phdr->p_offset);
                 load_va = get_te64(&phdr->p_vaddr);
                 fi->seek(old_data_off, SEEK_SET);
-                fi->readx(ibuf, old_data_len);
+                if (old_data_len == 0
+                ||  old_data_len > (upx_uint64_t)ibuf.getSize()
+                ||  old_data_len > (upx_uint64_t)0x7fffffffUL) {
+                    throwCantUnpack("bad PT_LOAD");
+                }
+                fi->readx(ibuf, (int)old_data_len);
                 total_in  += old_data_len;
                 total_out += old_data_len;
 
@@ -4658,9 +4709,21 @@ void PackLinuxElf64::unpack(OutputFile *fo)
                     if (dyn_off < load_off) {
                         continue;  // Oops.  Not really is_shlib ?  [built by 'rust' ?]
                     }
-                    Elf64_Dyn *dyn = (Elf64_Dyn *)((unsigned char *)ibuf +
-                        (dyn_off - load_off));
-                    dynseg = dyn; invert_pt_dynamic(dynseg);
+                    // dyn points into ibuf[] which contains old_data_len bytes from the
+                    // PT_LOAD image starting at load_off. Validate dyn_off/dyn_len
+                    // before dereferencing dyn entries (crafted input can otherwise
+                    // cause OOB reads and SEGV in get_te64()).
+                    upx_uint64_t const dyn_rel = dyn_off - load_off;
+                    if (dyn_len < sizeof(Elf64_Dyn)
+                    ||  dyn_rel > (upx_uint64_t)old_data_len
+                    ||  dyn_len > (upx_uint64_t)old_data_len - dyn_rel) {
+                        throwCantUnpack("bad PT_DYNAMIC");
+                    }
+                    if (dyn_rel > 0xffffffffu || dyn_len > 0xffffffffu) {
+                        throwCantUnpack("bad PT_DYNAMIC");
+                    }
+                    Elf64_Dyn *dyn = (Elf64_Dyn *)ibuf.subref("bad PT_DYNAMIC", (unsigned)dyn_rel, (unsigned)dyn_len);
+                    dynseg = dyn; sz_dynseg = dyn_len; invert_pt_dynamic(dynseg);
                     for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {
                         upx_uint64_t const tag = get_te64(&dyn->d_tag);
                         upx_uint64_t       val = get_te64(&dyn->d_val);
@@ -4930,8 +4993,11 @@ PackLinuxElf32::elf_has_dynamic(unsigned int key) const
 {
     Elf32_Dyn const *dynp= dynseg;
     if (dynp)
-    for (; Elf32_Dyn::DT_NULL!=dynp->d_tag; ++dynp) if (get_te32(&dynp->d_tag)==key) {
-        return dynp;
+    for (; (upx_uint64_t)((char const *)dynp - (char const *)dynseg) < sz_dynseg
+            && Elf32_Dyn::DT_NULL!=dynp->d_tag; ++dynp) {
+        if (get_te32(&dynp->d_tag)==key) {
+            return dynp;
+        }
     }
     return 0;
 }
@@ -4939,11 +5005,12 @@ PackLinuxElf32::elf_has_dynamic(unsigned int key) const
 unsigned  // checked .p_offset; sz_dynseg set
 PackLinuxElf32::check_pt_dynamic(Elf32_Phdr const *const phdr)
 {
-    unsigned t = get_te32(&phdr->p_offset), s = sizeof(Elf32_Dyn) + t;
+    unsigned t = get_te32(&phdr->p_offset);
     unsigned vaddr = get_te32(&phdr->p_vaddr);
     unsigned filesz = get_te32(&phdr->p_filesz), memsz = get_te32(&phdr->p_memsz);
     unsigned align = get_te32(&phdr->p_align);
-    if (s < t || (u32_t)file_size < s
+    unsigned const end = t + filesz;
+    if (end < t || (u32_t)file_size < end
     ||  (3 & t) || (7 & (filesz | memsz))  // .balign 4; 8==sizeof(Elf32_Dyn)
     ||  (-1+ align) & (t ^ vaddr)
     ||  filesz < sizeof(Elf32_Dyn)
@@ -4953,7 +5020,8 @@ PackLinuxElf32::check_pt_dynamic(Elf32_Phdr const *const phdr)
             (unsigned)(phdr - phdri));
         throwCantPack(msg);
     }
-    sz_dynseg = memsz;
+    // Bound DT_* scanning by the bytes actually present in the file.
+    sz_dynseg = filesz;
     return t;
 }
 
@@ -4962,7 +5030,7 @@ PackLinuxElf32::elf_find_dynamic(unsigned int key) const
 {
     Elf32_Dyn const *dynp= dynseg;
     if (dynp)
-    for (; (unsigned)((char const *)dynp - (char const *)dynseg) < sz_dynseg
+    for (; (upx_uint64_t)((char const *)dynp - (char const *)dynseg) < sz_dynseg
             && Elf32_Dyn::DT_NULL!=dynp->d_tag; ++dynp) if (get_te32(&dynp->d_tag)==key) {
         unsigned const t= elf_get_offset_from_address(get_te32(&dynp->d_val));
         if (t && t < (unsigned)file_size) {
@@ -4978,7 +5046,7 @@ PackLinuxElf32::elf_unsigned_dynamic(unsigned int key) const
 {
     Elf32_Dyn const *dynp= dynseg;
     if (dynp)
-    for (; (unsigned)((char const *)dynp - (char const *)dynseg) < sz_dynseg
+    for (; (upx_uint64_t)((char const *)dynp - (char const *)dynseg) < sz_dynseg
             && Elf32_Dyn::DT_NULL!=dynp->d_tag; ++dynp) if (get_te32(&dynp->d_tag)==key) {
         return get_te32(&dynp->d_val);
     }
@@ -5031,8 +5099,11 @@ PackLinuxElf64::elf_has_dynamic(unsigned int key) const
 {
     Elf64_Dyn const *dynp= dynseg;
     if (dynp)
-    for (; Elf64_Dyn::DT_NULL!=dynp->d_tag; ++dynp) if (get_te64(&dynp->d_tag)==key) {
-        return dynp;
+    for (; (upx_uint64_t)((char const *)dynp - (char const *)dynseg) < sz_dynseg
+            && Elf64_Dyn::DT_NULL!=dynp->d_tag; ++dynp) {
+        if (get_te64(&dynp->d_tag)==key) {
+            return dynp;
+        }
     }
     return 0;
 }
@@ -5040,11 +5111,12 @@ PackLinuxElf64::elf_has_dynamic(unsigned int key) const
 upx_uint64_t  // checked .p_offset; sz_dynseg set
 PackLinuxElf64::check_pt_dynamic(Elf64_Phdr const *const phdr)
 {
-    upx_uint64_t t = get_te64(&phdr->p_offset), s = sizeof(Elf64_Dyn) + t;
+    upx_uint64_t t = get_te64(&phdr->p_offset);
     upx_uint64_t vaddr = get_te64(&phdr->p_vaddr);
     upx_uint64_t filesz = get_te64(&phdr->p_filesz), memsz = get_te64(&phdr->p_memsz);
     upx_uint64_t align = get_te64(&phdr->p_align);
-    if (s < t || (upx_uint64_t)file_size < s
+    upx_uint64_t const end = t + filesz;
+    if (end < t || (upx_uint64_t)file_size < end
     ||  (7 & t) || (0xf & (filesz | memsz))  // .balign 8; 16==sizeof(Elf64_Dyn)
     ||  (-1+ align) & (t ^ vaddr)
     ||  filesz < sizeof(Elf64_Dyn)
@@ -5054,20 +5126,56 @@ PackLinuxElf64::check_pt_dynamic(Elf64_Phdr const *const phdr)
             (unsigned)(phdr - phdri));
         throwCantPack(msg);
     }
-    sz_dynseg = memsz;
+    // Bound DT_* scanning by the bytes actually present in the file.
+    sz_dynseg = filesz;
     return t;
 }
 
 void
 PackLinuxElf64::invert_pt_dynamic(Elf64_Dyn const *dynp)
 {
+    // Defensive: dynp must point into a currently valid buffer (file_image or ibuf).
+    // Malformed input can otherwise create an invalid Dyn* and crash in get_te64().
+    if (dynp) {
+        upx_uint64_t maxlen = sz_dynseg;
+        bool ok = false;
+        unsigned char const *p = (unsigned char const *)(void const *)dynp;
+        if (file_image) {
+            unsigned char const *base = (unsigned char const *)file_image;
+            unsigned char const *end  = base + file_image.getSize();
+            if (p >= base && p < end) {
+                upx_uint64_t avail = (upx_uint64_t)(end - p);
+                if (avail >= sizeof(*dynp)) {
+                    if (maxlen > avail) maxlen = avail;
+                    ok = true;
+                }
+            }
+        }
+        if (!ok) {
+            unsigned char const *base = (unsigned char const *)ibuf.getVoidPtr();
+            unsigned char const *end  = base + ibuf.getSize();
+            if (base && p >= base && p < end) {
+                upx_uint64_t avail = (upx_uint64_t)(end - p);
+                if (avail >= sizeof(*dynp)) {
+                    if (maxlen > avail) maxlen = avail;
+                    ok = true;
+                }
+            }
+        }
+        if (!ok) {
+            throwCantPack("bad PT_DYNAMIC");
+        }
+        sz_dynseg = maxlen;
+    }
+
     if (dt_table[Elf64_Dyn::DT_NULL]) {
         return;  // not 1st time; do not change upx_dt_init
     }
     Elf64_Dyn const *const dynp0 = dynp;
     unsigned ndx = 1+ 0;
     if (dynp)
-    for (; ; ++ndx, ++dynp) {
+    for (; (unsigned)((char const *)dynp - (char const *)dynp0) + sizeof(*dynp) <= sz_dynseg
+            ; ++ndx, ++dynp) {
         upx_uint64_t const d_tag = get_te64(&dynp->d_tag);
         if (d_tag>>32) { // outrageous
             char msg[50]; snprintf(msg, sizeof(msg),
@@ -5090,6 +5198,9 @@ PackLinuxElf64::invert_pt_dynamic(Elf64_Dyn const *dynp)
             break;  // check here so that dt_table[DT_NULL] is set
         }
     }
+    if (!dt_table[Elf64_Dyn::DT_NULL]) {
+        throwCantPack("bad PT_DYNAMIC: missing DT_NULL");
+    }
     upx_dt_init = 0;
          if (dt_table[Elf64_Dyn::DT_INIT])          upx_dt_init = Elf64_Dyn::DT_INIT;
     else if (dt_table[Elf64_Dyn::DT_PREINIT_ARRAY]) upx_dt_init = Elf64_Dyn::DT_PREINIT_ARRAY;
@@ -5204,7 +5315,7 @@ PackLinuxElf64::elf_find_dynamic(unsigned int key) const
 {
     Elf64_Dyn const *dynp= dynseg;
     if (dynp)
-    for (; (unsigned)((char const *)dynp - (char const *)dynseg) < sz_dynseg
+    for (; (upx_uint64_t)((char const *)dynp - (char const *)dynseg) < sz_dynseg
             && Elf64_Dyn::DT_NULL!=dynp->d_tag; ++dynp) if (get_te64(&dynp->d_tag)==key) {
         upx_uint64_t const t= elf_get_offset_from_address(get_te64(&dynp->d_val));
         if (t && t < (upx_uint64_t)file_size) {
@@ -5220,7 +5331,7 @@ PackLinuxElf64::elf_unsigned_dynamic(unsigned int key) const
 {
     Elf64_Dyn const *dynp= dynseg;
     if (dynp)
-    for (; (unsigned)((char const *)dynp - (char const *)dynseg) < sz_dynseg
+    for (; (upx_uint64_t)((char const *)dynp - (char const *)dynseg) < sz_dynseg
             && Elf64_Dyn::DT_NULL!=dynp->d_tag; ++dynp) if (get_te64(&dynp->d_tag)==key) {
         return get_te64(&dynp->d_val);
     }
@@ -5439,7 +5550,15 @@ void PackLinuxElf32::unpack(OutputFile *fo)
 
         // The first PT_LOAD.  Part is not compressed (for benefit of rtld.)
         fi->seek(0, SEEK_SET);
-        fi->readx(ibuf, get_te32(&dynhdr->p_offset) + get_te32(&dynhdr->p_filesz));
+        {
+            unsigned const t_len = get_te32(&dynhdr->p_offset) + get_te32(&dynhdr->p_filesz);
+            if (t_len < get_te32(&dynhdr->p_offset)
+            ||  t_len > (unsigned)ibuf.getSize()
+            ||  t_len > 0x7fffffffU) {
+                throwCantUnpack("bad PT_DYNAMIC");
+            }
+            fi->readx(ibuf, (int)t_len);
+        }
         overlay_offset -= sizeof(linfo);
         xct_off = overlay_offset;
         e_shoff = get_te32(&ehdri.e_shoff);
@@ -5597,7 +5716,12 @@ void PackLinuxElf32::unpack(OutputFile *fo)
                 load_off = get_te32(&phdr->p_offset);
                 load_va  = get_te32(&phdr->p_vaddr);
                 fi->seek(old_data_off, SEEK_SET);
-                fi->readx(ibuf, old_data_len);
+                if (old_data_len == 0
+                ||  old_data_len > (unsigned)ibuf.getSize()
+                ||  old_data_len > 0x7fffffffU) {
+                    throwCantUnpack("bad PT_LOAD");
+                }
+                fi->readx(ibuf, (int)old_data_len);
                 total_in  += old_data_len;
                 total_out += old_data_len;
 
@@ -5611,9 +5735,21 @@ void PackLinuxElf32::unpack(OutputFile *fo)
                     if (dyn_off < load_off) {
                         continue;  // Oops.  Not really is_shlib ?  [built by 'rust' ?]
                     }
-                    Elf32_Dyn *dyn = (Elf32_Dyn *)((unsigned char *)ibuf +
-                        (dyn_off - load_off));
-                    dynseg = dyn; invert_pt_dynamic(dynseg);
+                    // dyn points into ibuf[] which contains old_data_len bytes from the
+                    // PT_LOAD image starting at load_off. Validate dyn_off/dyn_len
+                    // before dereferencing dyn entries (crafted input can otherwise
+                    // cause OOB reads and SEGV in get_te32()).
+                    unsigned const dyn_rel = dyn_off - load_off;
+                    if (dyn_len < sizeof(Elf32_Dyn)
+                    ||  dyn_rel > (unsigned)old_data_len
+                    ||  dyn_len > (unsigned)old_data_len - dyn_rel) {
+                        throwCantUnpack("bad PT_DYNAMIC");
+                    }
+                    if (dyn_rel > 0xffffffffu) {
+                        throwCantUnpack("bad PT_DYNAMIC");
+                    }
+                    Elf32_Dyn *dyn = (Elf32_Dyn *)ibuf.subref("bad PT_DYNAMIC", (unsigned)dyn_rel, (unsigned)dyn_len);
+                    dynseg = dyn; sz_dynseg = dyn_len; invert_pt_dynamic(dynseg);
                     for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {
                         unsigned const tag = get_te32(&dyn->d_tag);
                         unsigned       val = get_te32(&dyn->d_val);