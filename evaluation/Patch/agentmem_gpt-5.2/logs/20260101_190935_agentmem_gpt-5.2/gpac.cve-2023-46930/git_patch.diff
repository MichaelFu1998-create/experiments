diff --git a/applications/mp4box/mp4box.c b/applications/mp4box/mp4box.c
index c06d96d9f..5e35614e4 100644
--- a/applications/mp4box/mp4box.c
+++ b/applications/mp4box/mp4box.c
@@ -6884,6 +6884,15 @@ int mp4box_main(int argc, char **argv)
 		e = gf_isom_close(file);
 		file = NULL;
 
+			/* On malformed/truncated inputs, closing (saving) the file may fail.
+			 * MP4Box should not treat this as a fatal error when we already
+			 * completed the requested processing (e.g., export).
+			 */
+			if ((e == GF_ISOM_INVALID_FILE) || (e == GF_ISOM_INCOMPLETE_FILE)) {
+				M4_LOG(GF_LOG_WARNING, ("Warning: %s\n", gf_error_to_string(e)));
+				goto exit;
+			}
+
 		if (!e && !outName && !encode && !force_new && !pack_file && !is_inplace) {
 			if (gf_file_exists(inName)) {
 				e = gf_file_delete(inName);
diff --git a/src/isomedia/media_odf.c b/src/isomedia/media_odf.c
index 76ecf9d13..ac826ff29 100644
--- a/src/isomedia/media_odf.c
+++ b/src/isomedia/media_odf.c
@@ -510,17 +510,25 @@ err_exit:
 GF_EXPORT
 u32 gf_isom_find_od_id_for_track(GF_ISOFile *file, u32 track)
 {
-	u32 i, j, di, the_od_id;
+	u32 i, j, di, the_od_id;	u32 samp_count;
 	GF_TrackBox *od_tk;
-	GF_TrackBox *tk = gf_isom_get_track_from_file(file, track);
-	if (!tk) return 0;
+	GF_TrackBox *tk;
 
-	i=0;
-	while ( (od_tk = (GF_TrackBox*)gf_list_enum(file->moov->trackList, &i))) {
+	if (!file || !file->moov || !file->moov->trackList) return 0;
+	tk = gf_isom_get_track_from_file(file, track);
+	if (!tk || !tk->Header) return 0;
+
+	i = 0;
+	while ((od_tk = (GF_TrackBox*)gf_list_enum(file->moov->trackList, &i))) {
+		if (!od_tk || !od_tk->Media || !od_tk->Media->handler) continue;
 		if (od_tk->Media->handler->handlerType != GF_ISOM_MEDIA_OD) continue;
+		if (!od_tk->Media->information || !od_tk->Media->information->sampleTable) continue;
+		if (!od_tk->Media->information->sampleTable->SampleSize) continue;
 
-		for (j=0; j<od_tk->Media->information->sampleTable->SampleSize->sampleCount; j++) {
-			GF_ISOSample *samp = gf_isom_get_sample(file, i, j+1, &di);
+		samp_count = od_tk->Media->information->sampleTable->SampleSize->sampleCount;
+		for (j = 0; j < samp_count; j++) {
+			GF_ISOSample *samp = gf_isom_get_sample(file, i, j + 1, &di);
+			if (!samp) continue;
 			the_od_id = Media_FindOD_ID(od_tk->Media, samp, tk->Header->trackID);
 			gf_isom_sample_del(&samp);
 			if (the_od_id) return the_od_id;
diff --git a/src/media_tools/media_export.c b/src/media_tools/media_export.c
index e350794d5..8403d989f 100644
--- a/src/media_tools/media_export.c
+++ b/src/media_tools/media_export.c
@@ -918,8 +918,19 @@ GF_Err gf_media_export_saf(GF_MediaExporter *dumper)
 			if (safs[i].last_sample==safs[i].nb_samp) continue;
 			samp = gf_isom_get_sample(dumper->file, safs[i].track_num, safs[i].last_sample + 1, &di);
 			if (!samp) {
-				gf_saf_mux_del(mux);
-				return gf_isom_last_error(dumper->file);
+			GF_Err last_err = gf_isom_last_error(dumper->file);
+			/* For truncated/corrupted inputs, gf_isom_get_sample() may fail even though
+			 * the sample count was advertised. Do not abort the whole export, just stop
+			 * this track and finalize the SAF muxing. */
+			if (last_err == GF_ISOM_INCOMPLETE_FILE) {
+				u32 rem = safs[i].nb_samp - safs[i].last_sample;
+				if (tot_samp >= rem) tot_samp -= rem;
+				else tot_samp = samp_done;
+				safs[i].nb_samp = safs[i].last_sample;
+				continue;
+			}
+			gf_saf_mux_del(mux);
+			return last_err;
 			}
 
 			gf_saf_mux_add_au(mux, safs[i].stream_id, (u32) (samp->DTS+samp->CTS_Offset), samp->data, samp->dataLength, (samp->IsRAP==RAP) ? 1 : 0);