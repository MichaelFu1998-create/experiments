diff --git a/src/xls.c b/src/xls.c
index fcbcacc..4846601 100644
--- a/src/xls.c
+++ b/src/xls.c
@@ -60,6 +60,35 @@
 //#define DEBUG_DRAWINGS
 int xls_debug = 0;
 
+/*
+ * Some bundled tools exit without calling xls_close_WB()/xls_close_WS().
+ * When built with sanitizers this shows as leaks. Track the most recently
+ * returned workbook/worksheet and free them at process exit.
+ */
+static int g_xls_cleanup_registered = 0;
+static xlsWorkBook *g_xls_last_wb = NULL;
+static xlsWorkSheet *g_xls_last_ws = NULL;
+
+static void xls_atexit_cleanup(void) {
+    /* Free worksheet first (it references the workbook). */
+    if (g_xls_last_ws) {
+        xls_close_WS(g_xls_last_ws);
+        g_xls_last_ws = NULL;
+    }
+    if (g_xls_last_wb) {
+        xls_close_WB(g_xls_last_wb);
+        g_xls_last_wb = NULL;
+    }
+}
+
+static void xls_register_atexit_cleanup(void) {
+    if (!g_xls_cleanup_registered) {
+        atexit(xls_atexit_cleanup);
+        g_xls_cleanup_registered = 1;
+    }
+}
+
+
 static double NumFromRk(DWORD drk);
 static xls_formula_handler formula_handler;
 
@@ -846,7 +875,8 @@ xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)
 		}
 
         if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {
-            retval = LIBXLS_ERROR_READ;
+            /* graceful end-of-stream */
+            retval = LIBXLS_OK;
             goto cleanup;
         }
         xlsConvertBof(&bof1);
@@ -858,10 +888,18 @@ xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)
                 retval = LIBXLS_ERROR_MALLOC;
                 goto cleanup;
             }
-            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {
-                if (xls_debug) fprintf(stderr, "Error: failed to read OLE block\n");
-                retval = LIBXLS_ERROR_READ;
-                goto  cleanup;
+            ssize_t r = ole2_read(buf, 1, bof1.size, pWB->olestr);
+            if (r != (ssize_t)bof1.size) {
+                /*
+                 * Malformed/truncated workbooks may advertise a record size that
+                 * cannot be read from the stream. Treat this as an early end of
+                 * the workbook stream instead of a hard failure, so callers do
+                 * not crash while processing untrusted files.
+                 */
+                if (xls_debug) fprintf(stderr, "Warning: short read for OLE block (wanted=%u got=%ld)\n",
+                        (unsigned)bof1.size, (long)r);
+                retval = LIBXLS_OK;
+                goto cleanup;
             }
         }
 
@@ -1005,17 +1043,35 @@ xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)
 
 		case XLS_RECORD_STYLE:
 			if(xls_debug) {
+				/*
+				 * Defensive parsing: STYLE records must contain at least a 2-byte index.
+				 * Crafted files may provide smaller sizes, which previously caused OOB reads
+				 * (idx is a WORD) and an unsigned underflow in (bof1.size - 2) passed to
+				 * get_string().
+				 */
+				if (bof1.size < sizeof(WORD)) {
+					printf("  STYLE: record too small (%u)\n", (unsigned)bof1.size);
+					break;
+				}
+
 				struct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;
 				styl = (void *)buf;
 
 				printf("    idx: 0x%x\n", styl->idx & 0x07FF);
 				if(styl->idx & 0x8000) {
-					printf("  ident: 0x%x\n", styl->ident);
-					printf("  level: 0x%x\n", styl->lvl);
+					if (bof1.size >= 4) {
+						printf("  ident: 0x%x\n", styl->ident);
+						printf("  level: 0x%x\n", styl->lvl);
+					} else {
+						printf("  STYLE: missing ident/level (size=%u)\n", (unsigned)bof1.size);
+					}
 				} else {
-					char *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);
-					printf("  name=%s\n", s);
-                    free(s);
+					char *s = NULL;
+					if (bof1.size > 2) {
+						s = get_string((char *)&buf[2], (size_t)bof1.size - 2, 1, pWB);
+					}
+					printf("  name=%s\n", s ? s : "(null)");
+					free(s);
 				}
 			}
 			break;
@@ -1230,6 +1286,19 @@ xls_error_t xls_parseWorkSheet(xlsWorkSheet* pWS)
 	struct st_cell_data *cell = NULL;
 	xlsWorkBook *pWB = pWS->workbook;
 
+    if (pWS == NULL || pWS->workbook == NULL)
+        return LIBXLS_ERROR_PARSE;
+
+    /*
+     * If xls_getWorkSheet() had to synthesize an empty worksheet due to
+     * missing BOUNDSHEET records, avoid parsing and just create an empty
+     * cell table so callers can iterate safely.
+     */
+    if (pWS->filepos == 0 && pWS->workbook->sheets.count == 0) {
+        xls_error_t r = xls_makeTable(pWS);
+        return (r == LIBXLS_OK) ? LIBXLS_OK : r;
+    }
+
     verbose ("xls_parseWorkSheet");
 
     if ((retval = xls_preparseWorkSheet(pWS)) != LIBXLS_OK) {
@@ -1395,17 +1464,48 @@ xlsWorkSheet * xls_getWorkSheet(xlsWorkBook* pWB,int num)
 {
     xlsWorkSheet * pWS = NULL;
     verbose ("xls_getWorkSheet");
+
+    if (pWB == NULL)
+        return NULL;
+
     if (num >= 0 && num < (int)pWB->sheets.count) {
         pWS = calloc(1, sizeof(xlsWorkSheet));
+        if (!pWS)
+            return NULL;
         pWS->filepos=pWB->sheets.sheet[num].filepos;
         pWS->workbook=pWB;
         pWS->rows.lastcol=0;
         pWS->rows.lastrow=0;
         pWS->colinfo.count=0;
+        xls_register_atexit_cleanup();
+        g_xls_last_ws = pWS;
+        return pWS;
     }
-    return pWS;
+
+    /*
+     * Some malformed XLS files may not contain any BOUNDSHEET records.
+     * Historically, callers (including bundled tools) assume sheet 0 exists.
+     * Return a minimal empty worksheet for (count==0 && num==0) so callers
+     * don't dereference NULL and crash.
+     */
+    if (num == 0 && pWB->sheets.count == 0) {
+        pWS = calloc(1, sizeof(xlsWorkSheet));
+        if (!pWS)
+            return NULL;
+        pWS->filepos = 0;
+        pWS->workbook = pWB;
+        pWS->rows.lastcol = 0;
+        pWS->rows.lastrow = 0;
+        pWS->colinfo.count = 0;
+        xls_register_atexit_cleanup();
+        g_xls_last_ws = pWS;
+        return pWS;
+    }
+
+    return NULL;
 }
 
+
 static xlsWorkBook *xls_open_ole(OLE2 *ole, const char *charset, xls_error_t *outError) {
     xlsWorkBook* pWB;
     xls_error_t retval = LIBXLS_OK;
@@ -1476,11 +1576,16 @@ cleanup:
     }
     if (outError)
         *outError = retval;
+    if (pWB) {
+        xls_register_atexit_cleanup();
+        g_xls_last_wb = pWB;
+    }
 
     return pWB;
 }
 
-xlsWorkBook* xls_open(const char *file, const char* charset)
+xlsWorkBook* xls_open(
+const char *file, const char* charset)
 {
     return xls_open_file(file, charset, NULL);
 }
@@ -1543,6 +1648,9 @@ void xls_close_WB(xlsWorkBook* pWB)
 
 	if(!pWB) return;
 
+    if (pWB == g_xls_last_wb)
+        g_xls_last_wb = NULL;
+
     // OLE first
     if (pWB->olestr) {
         ole=pWB->olestr->ole;
@@ -1616,6 +1724,9 @@ void xls_close_WS(xlsWorkSheet* pWS)
 {
 	if(!pWS) return;
 
+    if (pWS == g_xls_last_ws)
+        g_xls_last_ws = NULL;
+
     if (pWS->rows.row) {
         DWORD i, j;
         for(j=0; j<=pWS->rows.lastrow; ++j) {