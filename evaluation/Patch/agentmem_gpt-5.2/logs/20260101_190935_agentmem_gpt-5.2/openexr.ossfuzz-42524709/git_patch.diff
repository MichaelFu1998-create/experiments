diff --git a/src/lib/OpenEXRCore/compression.c b/src/lib/OpenEXRCore/compression.c
index 1d2eaea5..2d55260d 100644
--- a/src/lib/OpenEXRCore/compression.c
+++ b/src/lib/OpenEXRCore/compression.c
@@ -10,6 +10,8 @@
 
 #include <libdeflate.h>
 
+#include <string.h>
+
 #if (                                                                          \
     LIBDEFLATE_VERSION_MAJOR > 1 ||                                            \
     (LIBDEFLATE_VERSION_MAJOR == 1 && LIBDEFLATE_VERSION_MINOR > 18))
@@ -119,6 +121,8 @@ exr_uncompress_buffer (
     enum libdeflate_result              res;
     size_t                              actual_in_bytes;
     const struct _internal_exr_context* pctxt = EXR_CCTXT (ctxt);
+    void*                               padded_in = NULL;
+    const void*                         inptr     = in;
 #ifdef EXR_USE_CONFIG_DEFLATE_STRUCT
     struct libdeflate_options opt = {
         .sizeof_options = sizeof (struct libdeflate_options),
@@ -135,9 +139,45 @@ exr_uncompress_buffer (
 
     if (decomp)
     {
+        /* Defensive hardening: libdeflate's zlib wrapper may do unaligned
+         * 16-bit reads when parsing malformed/truncated input.
+         * Ensure there are always at least 2 readable bytes past the logical
+         * end of the input buffer to prevent OOB reads.
+         */
+        if (in_bytes < 2)
+        {
+            libdeflate_free_decompressor (decomp);
+            if (actual_out) *actual_out = 0;
+            return EXR_ERR_CORRUPT_CHUNK;
+        }
+
+        /* Allocate a padded copy so any read-ahead stays in-bounds even when
+         * the compressed stream is corrupt.
+         */
+        if (in && in_bytes > 0)
+        {
+            size_t padded_bytes = in_bytes + 2;
+            if (padded_bytes < in_bytes)
+            {
+                libdeflate_free_decompressor (decomp);
+                if (actual_out) *actual_out = 0;
+                return EXR_ERR_OUT_OF_MEMORY;
+            }
+            padded_in = (pctxt ? pctxt->alloc_fn : internal_exr_alloc) (
+                padded_bytes);
+            if (!padded_in)
+            {
+                libdeflate_free_decompressor (decomp);
+                if (actual_out) *actual_out = 0;
+                return EXR_ERR_OUT_OF_MEMORY;
+            }
+            memcpy (padded_in, in, in_bytes);
+            memset (((unsigned char*) padded_in) + in_bytes, 0, 2);
+            inptr = padded_in;
+        }
         res = libdeflate_zlib_decompress_ex (
             decomp,
-            in,
+            inptr,
             in_bytes,
             out,
             out_bytes_avail,
@@ -146,6 +186,9 @@ exr_uncompress_buffer (
 
         libdeflate_free_decompressor (decomp);
 
+        if (padded_in)
+            (pctxt ? pctxt->free_fn : internal_exr_free) (padded_in);
+
         if (res == LIBDEFLATE_SUCCESS)
         {
             if (in_bytes == actual_in_bytes) return EXR_ERR_SUCCESS;
diff --git a/src/lib/OpenEXRCore/internal_dwa_compressor.h b/src/lib/OpenEXRCore/internal_dwa_compressor.h
index 688bd51a..a24de880 100644
--- a/src/lib/OpenEXRCore/internal_dwa_compressor.h
+++ b/src/lib/OpenEXRCore/internal_dwa_compressor.h
@@ -148,9 +148,11 @@ DwaCompressor_construct (
         rv = exr_get_zip_compression_level (
             encode->context, encode->part_index, &(me->_zipLevel));
         if (rv != EXR_ERR_SUCCESS) return rv;
+
         rv = exr_get_dwa_compression_level (
             encode->context, encode->part_index, &(me->_dwaCompressionLevel));
         if (rv != EXR_ERR_SUCCESS) return rv;
+
     }
     else
     {
@@ -280,6 +282,7 @@ DwaCompressor_compress (DwaCompressor* me)
         outBufferSize);
     if (rv != EXR_ERR_SUCCESS) return rv;
 
+
     nAvail = outBufferSize;
     sizes  = (uint64_t*) me->_encode->compressed_buffer;
 
@@ -343,6 +346,7 @@ DwaCompressor_compress (DwaCompressor* me)
     rv = DwaCompressor_setupChannelData (me);
     if (rv != EXR_ERR_SUCCESS) return rv;
 
+
     //
     // Determine the start of each row in the input buffer
     // Channels are interleaved by scanline
@@ -367,6 +371,7 @@ DwaCompressor_compress (DwaCompressor* me)
                 me->alloc_fn, me->free_fn, &(cd->_dctData), inDataPtr);
             if (rv != EXR_ERR_SUCCESS) return rv;
 
+
             inDataPtr += chan->width * chan->bytes_per_element;
         }
     }
@@ -406,6 +411,7 @@ DwaCompressor_compress (DwaCompressor* me)
         me->_channelData[cset->idx[2]].processed = 1;
 
         if (rv != EXR_ERR_SUCCESS) return rv;
+
     }
 
     for (int chan = 0; chan < me->_numChannels; ++chan)
@@ -452,6 +458,7 @@ DwaCompressor_compress (DwaCompressor* me)
                     packedDcEnd += enc._numDcComp * sizeof (uint16_t);
 
                     if (rv != EXR_ERR_SUCCESS) return rv;
+
                 }
                 break;
 
@@ -532,6 +539,7 @@ DwaCompressor_compress (DwaCompressor* me)
             &outSize);
         if (rv != EXR_ERR_SUCCESS) return rv;
 
+
         outDataPtr += outSize;
         *unknownCompressedSize = outSize;
         nWritten += outSize;
@@ -594,6 +602,7 @@ DwaCompressor_compress (DwaCompressor* me)
                     &destLen);
                 if (rv != EXR_ERR_SUCCESS) return rv;
 
+
                 *acCompressedSize = destLen;
                 break;
             }
@@ -625,6 +634,7 @@ DwaCompressor_compress (DwaCompressor* me)
 
         if (rv != EXR_ERR_SUCCESS) return rv;
 
+
         internal_zip_deconstruct_bytes (
             me->_encode->scratch_buffer_1, me->_packedDcBuffer, uncompBytes);
 
@@ -639,6 +649,7 @@ DwaCompressor_compress (DwaCompressor* me)
 
         if (rv != EXR_ERR_SUCCESS) return rv;
 
+
         *dcCompressedSize = compBytes;
         outDataPtr += compBytes;
         nWritten += compBytes;
@@ -669,6 +680,7 @@ DwaCompressor_compress (DwaCompressor* me)
 
         if (rv != EXR_ERR_SUCCESS) return rv;
 
+
         *rleCompressedSize = compBytes;
         outDataPtr += compBytes;
         nWritten += compBytes;
@@ -803,10 +815,19 @@ DwaCompressor_uncompress (
 
     if (rv != EXR_ERR_SUCCESS) return rv;
 
+    /* For version >= 2, the channel rules consume bytes from dataPtr/dataLeft.
+     * The earlier iSize vs (headerSize + compressedSize) check used the
+     * pre-rule headerSize, so ensure we still have enough bytes remaining
+     * for the compressed payload before slicing buffers and decompressing.
+     */
+    if (dataLeft < compressedSize) return EXR_ERR_CORRUPT_CHUNK;
+
+
     outBufferSize = 0;
     rv            = DwaCompressor_initializeBuffers (me, &outBufferSize);
     if (rv != EXR_ERR_SUCCESS) return rv;
 
+
     //
     // Allocate _outBuffer, if we haven't done so already
     //
@@ -920,6 +941,7 @@ DwaCompressor_uncompress (
                     &destLen);
                 if (rv != EXR_ERR_SUCCESS) return rv;
 
+
                 if (totalAcUncompressedCount * sizeof (uint16_t) != destLen)
                 {
                     return EXR_ERR_CORRUPT_CHUNK;
@@ -953,6 +975,7 @@ DwaCompressor_uncompress (
 
         if (rv != EXR_ERR_SUCCESS) return rv;
 
+
         rv = exr_uncompress_buffer (
             me->_decode->context,
             compressedDcBuf,
@@ -1033,6 +1056,7 @@ DwaCompressor_uncompress (
                 me->alloc_fn, me->free_fn, &(cd->_dctData), outBufferEnd);
             if (rv != EXR_ERR_SUCCESS) return rv;
 
+
             outBufferEnd += chan->width * chan->bytes_per_element;
         }
     }
@@ -1278,6 +1302,7 @@ DwaCompressor_initializeBuffers (DwaCompressor* me, size_t* bufferSize)
     rv = DwaCompressor_classifyChannels (me);
     if (rv != EXR_ERR_SUCCESS) return rv;
 
+
     for (int c = 0; c < me->_numChannels; ++c)
     {
         const exr_coding_channel_info_t* curc = me->_channelData[c].chan;