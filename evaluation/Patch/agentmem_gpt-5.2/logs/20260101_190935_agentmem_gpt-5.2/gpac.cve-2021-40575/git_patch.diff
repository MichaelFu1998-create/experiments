diff --git a/src/filters/reframe_mpgvid.c b/src/filters/reframe_mpgvid.c
index 328db2855..3ddd18f9b 100644
--- a/src/filters/reframe_mpgvid.c
+++ b/src/filters/reframe_mpgvid.c
@@ -580,8 +580,11 @@ GF_Err mpgviddmx_process(GF_Filter *filter)
 	//we stored some data to find the complete vosh, aggregate this packet with current one
 	if (!ctx->resume_from && ctx->hdr_store_size) {
 		if (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size) {
+			char *tmp;
 			ctx->hdr_store_alloc = ctx->hdr_store_size + pck_size;
-			ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);
+			tmp = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);
+			if (!tmp) return GF_OUT_OF_MEM;
+			ctx->hdr_store = tmp;
 		}
 		memcpy(ctx->hdr_store + ctx->hdr_store_size, data, sizeof(char)*pck_size);
 		if (byte_offset != GF_FILTER_NO_BO) {
@@ -601,17 +604,31 @@ GF_Err mpgviddmx_process(GF_Filter *filter)
 
 		//resume from data copied internally
 		if (ctx->hdr_store_size) {
-			assert(ctx->resume_from <= ctx->hdr_store_size);
+			/* do not rely on asserts - crafted streams can desync resume_from */
+			if (ctx->resume_from > ctx->hdr_store_size) {
+				ctx->resume_from = 0;
+				ctx->hdr_store_size = 0;
+				return GF_NON_COMPLIANT_BITSTREAM;
+			}
 			start = data = ctx->hdr_store + ctx->resume_from;
 			remain = pck_size = ctx->hdr_store_size - ctx->resume_from;
 		} else {
-			assert(remain >= (s32) ctx->resume_from);
+			if ((s64)ctx->resume_from > (s64)remain) {
+				ctx->resume_from = 0;
+				return GF_NON_COMPLIANT_BITSTREAM;
+			}
 			start += ctx->resume_from;
-			remain -= ctx->resume_from;
+			remain -= (s32) ctx->resume_from;
 		}
 		ctx->resume_from = 0;
 	}
 
+	/* remain is a signed length used throughout this function; never allow it to go negative */
+	if (remain <= 0) {
+		gf_filter_pid_drop_packet(ctx->ipid);
+		return GF_OK;
+	}
+
 	if (!ctx->bs) {
 		ctx->bs = gf_bs_new(start, remain, GF_BITSTREAM_READ);
 	} else {
@@ -639,9 +656,11 @@ GF_Err mpgviddmx_process(GF_Filter *filter)
 		Bool copy_last_bytes = GF_FALSE;
 
 		//not enough bytes to parse start code
+		if (remain <= 0) break;
 		if (remain<5) {
-			memcpy(ctx->hdr_store, start, remain);
-			ctx->bytes_in_header = remain;
+			/* remain is signed, ensure it is always a valid length */
+			memcpy(ctx->hdr_store, start, (size_t) remain);
+			ctx->bytes_in_header = (u32) remain;
 			break;
 		}
 		current = -1;
@@ -649,9 +668,22 @@ GF_Err mpgviddmx_process(GF_Filter *filter)
 		//we have some potential bytes of a start code in the store, copy some more bytes and check if valid start code.
 		//if not, dispatch these bytes as continuation of the data
 		if (ctx->bytes_in_header) {
+			u32 needed;
 
-			memcpy(ctx->hdr_store + ctx->bytes_in_header, start, 8 - ctx->bytes_in_header);
-			current = mpgviddmx_next_start_code(ctx->hdr_store, 8);
+			if (ctx->bytes_in_header > 8) {
+				/* corrupted state, reset */
+				ctx->bytes_in_header = 0;
+			} else {
+				needed = 8 - ctx->bytes_in_header;
+				/* if we don't have enough bytes to complete the probe buffer, store what we have */
+				if ((u32) remain < needed) {
+					memcpy(ctx->hdr_store + ctx->bytes_in_header, start, (size_t) remain);
+					ctx->bytes_in_header += (u32) remain;
+					break;
+				}
+				memcpy(ctx->hdr_store + ctx->bytes_in_header, start, needed);
+				current = mpgviddmx_next_start_code(ctx->hdr_store, 8);
+			}
 
 			//no start code in stored buffer
 			if ((current<0) || (current >= (s32) ctx->bytes_in_header) )  {
@@ -1054,6 +1086,7 @@ static GF_Err mpgviddmx_initialize(GF_Filter *filter)
 	ctx->hdr_store_size = 0;
 	ctx->hdr_store_alloc = 8;
 	ctx->hdr_store = gf_malloc(sizeof(char)*8);
+	if (!ctx->hdr_store) return GF_OUT_OF_MEM;
 	return GF_OK;
 }