diff --git a/coders/pnm.c b/coders/pnm.c
index f6f69bf83..45973ae9f 100644
--- a/coders/pnm.c
+++ b/coders/pnm.c
@@ -1754,15 +1754,21 @@ static MagickBooleanType WritePNMImage(const ImageInfo *image_info,Image *image,
             break;
           for (x=0; x < (ssize_t) image->columns; x++)
           {
-            *q++=(unsigned char) (GetPixelLuma(image,p) >= (QuantumRange/2.0) ?
-              '0' : '1');
-            *q++=' ';
-            if ((q-pixels+1) >= (ssize_t) sizeof(pixels))
+            /*
+              Ensure there is enough room for the next pixel (two bytes) and
+              a possible newline.  The previous logic appended first and only
+              then checked bounds, which could make `q` one-past-the-end and
+              overflow when writing the newline.
+            */
+            if (((size_t) (q-pixels) + 3) > sizeof(pixels))
               {
                 *q++='\n';
                 (void) WriteBlob(image,q-pixels,pixels);
                 q=pixels;
               }
+            *q++=(unsigned char) (GetPixelLuma(image,p) >= (QuantumRange/2.0) ?
+              '0' : '1');
+            *q++=' ';
             p+=GetPixelChannels(image);
           }
           *q++='\n';
@@ -1824,13 +1830,26 @@ static MagickBooleanType WritePNMImage(const ImageInfo *image_info,Image *image,
                 count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,
                   "%u ",ScaleQuantumToLong(index));
             extent=(size_t) count;
-            (void) strncpy((char *) q,buffer,extent);
-            q+=extent;
-            if ((q-pixels+extent+1) >= sizeof(pixels))
+            if (extent != 0)
               {
-                *q++='\n';
-                (void) WriteBlob(image,q-pixels,pixels);
-                q=pixels;
+                /*
+                  Bounds check must happen before appending. Always keep one
+                  byte available for the newline that terminates rows / flushes.
+                */
+                if (((size_t) (q-pixels) + extent + 1) > sizeof(pixels))
+                  {
+                    *q++='\n';
+                    (void) WriteBlob(image,q-pixels,pixels);
+                    q=pixels;
+                  }
+                /* If a single formatted value is larger than our buffer, write it directly. */
+                if (extent >= sizeof(pixels))
+                  (void) WriteBlob(image,extent,(unsigned char *) buffer);
+                else
+                  {
+                    (void) memcpy(q,buffer,extent);
+                    q+=extent;
+                  }
               }
             p+=GetPixelChannels(image);
           }
@@ -1899,13 +1918,26 @@ static MagickBooleanType WritePNMImage(const ImageInfo *image_info,Image *image,
                   ScaleQuantumToLong(GetPixelGreen(image,p)),
                   ScaleQuantumToLong(GetPixelBlue(image,p)));
             extent=(size_t) count;
-            (void) strncpy((char *) q,buffer,extent);
-            q+=extent;
-            if ((q-pixels+extent+1) >= sizeof(pixels))
+            if (extent != 0)
               {
-                *q++='\n';
-                (void) WriteBlob(image,q-pixels,pixels);
-                q=pixels;
+                /*
+                  Bounds check must happen before appending. Always keep one
+                  byte available for the newline that terminates rows / flushes.
+                */
+                if (((size_t) (q-pixels) + extent + 1) > sizeof(pixels))
+                  {
+                    *q++='\n';
+                    (void) WriteBlob(image,q-pixels,pixels);
+                    q=pixels;
+                  }
+                /* If a single formatted value is larger than our buffer, write it directly. */
+                if (extent >= sizeof(pixels))
+                  (void) WriteBlob(image,extent,(unsigned char *) buffer);
+                else
+                  {
+                    (void) memcpy(q,buffer,extent);
+                    q+=extent;
+                  }
               }
             p+=GetPixelChannels(image);
           }