diff --git a/mrbgems/mruby-bigint/core/bigint.c b/mrbgems/mruby-bigint/core/bigint.c
index dd6674e1f..e0a61b24c 100644
--- a/mrbgems/mruby-bigint/core/bigint.c
+++ b/mrbgems/mruby-bigint/core/bigint.c
@@ -361,6 +361,13 @@ urshift(mrb_state *mrb, mpz_t *c1, mpz_t *a, size_t n)
 {
   mrb_assert(n < DIG_SIZE);
 
+  /* A zero bigint may be represented with sz==0 and p==NULL.
+     Guard against size_t underflow (a->sz-1) and invalid limb reads. */
+  if (a->sz == 0 || a->p == NULL) {
+    zero(c1);
+    return;
+  }
+
   if (n == 0)
     mpz_set(mrb, c1, a);
   else {
@@ -370,10 +377,9 @@ urshift(mrb_state *mrb, mpz_t *c1, mpz_t *a, size_t n)
 
     mpz_init(mrb, &c);
     mpz_realloc(mrb, &c, a->sz);
-    for (size_t i=a->sz-1;; i--) {
+    for (size_t i = a->sz; i-- > 0;) {
       c.p[i] = ((a->p[i] >> n) | cc) & DIG_MASK;
       cc = (a->p[i] & rm) << (DIG_SIZE - n);
-      if (i == 0) break;
     }
     trim(&c);
     mpz_set(mrb, c1, &c);
@@ -784,6 +790,14 @@ mpz_div_2exp(mrb_state *mrb, mpz_t *z, mpz_t *x, mrb_int e)
     size_t bs = (e % (DIG_SIZE));
     mpz_t y;
 
+    /* Shifting right by more limbs than we have yields zero.
+       Also prevents underflow in (x->sz - digs) and calling urshift()
+       with an empty mpz_t. */
+    if (digs >= x->sz) {
+      zero(z);
+      return;
+    }
+
     mpz_init(mrb, &y);
     mpz_realloc(mrb, &y, x->sz-digs);
     for (size_t i=0; i < x->sz-digs; i++)