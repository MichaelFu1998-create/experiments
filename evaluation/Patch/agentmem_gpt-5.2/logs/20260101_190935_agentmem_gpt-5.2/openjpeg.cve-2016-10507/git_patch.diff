diff --git a/build/src/bin/common/opj_apps_config.h b/build/src/bin/common/opj_apps_config.h
new file mode 100644
index 00000000..43c63caf
--- /dev/null
+++ b/build/src/bin/common/opj_apps_config.h
@@ -0,0 +1,15 @@
+#include "opj_config_private.h"
+
+/* create opj_apps_config.h for CMake */
+
+/* #undef OPJ_HAVE_LIBPNG */
+/* #undef OPJ_HAVE_PNG_H */
+/* #undef OPJ_HAVE_LIBTIFF */
+/* #undef OPJ_HAVE_TIFF_H */
+
+/* #undef OPJ_HAVE_LIBLCMS1 */
+/* #undef OPJ_HAVE_LIBLCMS2 */
+/* #undef OPJ_HAVE_LCMS1_H */
+/* #undef OPJ_HAVE_LCMS2_H */
+
+
diff --git a/build/src/lib/openjp2/opj_config.h b/build/src/lib/openjp2/opj_config.h
new file mode 100644
index 00000000..87caa0d8
--- /dev/null
+++ b/build/src/lib/openjp2/opj_config.h
@@ -0,0 +1,10 @@
+/* create opj_config.h for CMake */
+#define OPJ_HAVE_STDINT_H 		1
+
+/*--------------------------------------------------------------------------*/
+/* OpenJPEG Versioning                                                      */
+
+/* Version number. */
+#define OPJ_VERSION_MAJOR 2
+#define OPJ_VERSION_MINOR 1
+#define OPJ_VERSION_BUILD 1
diff --git a/build/src/lib/openjp2/opj_config_private.h b/build/src/lib/openjp2/opj_config_private.h
new file mode 100644
index 00000000..312e9c38
--- /dev/null
+++ b/build/src/lib/openjp2/opj_config_private.h
@@ -0,0 +1,49 @@
+/* create opj_config_private.h for CMake */
+#define OPJ_HAVE_INTTYPES_H 	1
+
+#define OPJ_PACKAGE_VERSION "2.1.1"
+
+/* Not used by openjp2*/
+/*#define HAVE_MEMORY_H 1*/
+/*#define HAVE_STDLIB_H 1*/
+/*#define HAVE_STRINGS_H 1*/
+/*#define HAVE_STRING_H 1*/
+/*#define HAVE_SYS_STAT_H 1*/
+/*#define HAVE_SYS_TYPES_H 1 */
+/*#define HAVE_UNISTD_H 1*/
+
+/* #undef _LARGEFILE_SOURCE */
+/* #undef _LARGE_FILES */
+/* #undef _FILE_OFFSET_BITS */
+#define OPJ_HAVE_FSEEKO ON
+
+/* find whether or not have <malloc.h> */
+#define OPJ_HAVE_MALLOC_H
+/* check if function `aligned_alloc` exists */
+/* #undef OPJ_HAVE_ALIGNED_ALLOC */
+/* check if function `_aligned_malloc` exists */
+/* #undef OPJ_HAVE__ALIGNED_MALLOC */
+/* check if function `memalign` exists */
+#define OPJ_HAVE_MEMALIGN
+/* check if function `posix_memalign` exists */
+#define OPJ_HAVE_POSIX_MEMALIGN
+
+#if !defined(_POSIX_C_SOURCE)
+#if defined(OPJ_HAVE_FSEEKO) || defined(OPJ_HAVE_POSIX_MEMALIGN)
+/* Get declarations of fseeko, ftello, posix_memalign. */
+#define _POSIX_C_SOURCE 200112L
+#endif
+#endif
+
+/* Byte order.  */
+/* All compilers that support Mac OS X define either __BIG_ENDIAN__ or
+__LITTLE_ENDIAN__ to match the endianness of the architecture being
+compiled for. This is not necessarily the same as the architecture of the
+machine doing the building. In order to support Universal Binaries on
+Mac OS X, we prefer those defines to decide the endianness.
+On other platforms we use the result of the TRY_RUN. */
+#if !defined(__APPLE__)
+/* #undef OPJ_BIG_ENDIAN */
+#elif defined(__BIG_ENDIAN__)
+# define OPJ_BIG_ENDIAN
+#endif
diff --git a/src/bin/jp2/convertbmp.c b/src/bin/jp2/convertbmp.c
index d264823f..ba2c8788 100644
--- a/src/bin/jp2/convertbmp.c
+++ b/src/bin/jp2/convertbmp.c
@@ -41,6 +41,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <ctype.h>
+#include <limits.h>
 
 #include "openjpeg.h"
 #include "convert.h"
@@ -137,12 +138,14 @@ static void bmp24toimage(const OPJ_UINT8* pData, OPJ_UINT32 stride, opj_image_t*
 	OPJ_UINT32 width, height;
 	OPJ_UINT32 x, y;
 	const OPJ_UINT8 *pSrc = NULL;
+	OPJ_SIZE_T src_index;
 
 	width  = image->comps[0].w;
 	height = image->comps[0].h;
 	
 	index = 0;
-	pSrc = pData + (height - 1U) * stride;
+	src_index = (OPJ_SIZE_T)(height - 1U) * (OPJ_SIZE_T)stride;
+	pSrc = pData + src_index;
 	for(y = 0; y < height; y++)
 	{
 		for(x = 0; x < width; x++)
@@ -181,6 +184,7 @@ static void bmpmask32toimage(const OPJ_UINT8* pData, OPJ_UINT32 stride, opj_imag
 	OPJ_UINT32 width, height;
 	OPJ_UINT32 x, y;
 	const OPJ_UINT8 *pSrc = NULL;
+	OPJ_SIZE_T src_index;
 	OPJ_BOOL hasAlpha;
 	OPJ_UINT32 redShift,   redPrec;
 	OPJ_UINT32 greenShift, greenPrec;
@@ -209,7 +213,8 @@ static void bmpmask32toimage(const OPJ_UINT8* pData, OPJ_UINT32 stride, opj_imag
 	}
 	
 	index = 0;
-	pSrc = pData + (height - 1U) * stride;
+	src_index = (OPJ_SIZE_T)(height - 1U) * (OPJ_SIZE_T)stride;
+	pSrc = pData + src_index;
 	for(y = 0; y < height; y++)
 	{
 		for(x = 0; x < width; x++)
@@ -239,6 +244,7 @@ static void bmpmask16toimage(const OPJ_UINT8* pData, OPJ_UINT32 stride, opj_imag
 	OPJ_UINT32 width, height;
 	OPJ_UINT32 x, y;
 	const OPJ_UINT8 *pSrc = NULL;
+	OPJ_SIZE_T src_index;
 	OPJ_BOOL hasAlpha;
 	OPJ_UINT32 redShift,   redPrec;
 	OPJ_UINT32 greenShift, greenPrec;
@@ -267,7 +273,8 @@ static void bmpmask16toimage(const OPJ_UINT8* pData, OPJ_UINT32 stride, opj_imag
 	}
 	
 	index = 0;
-	pSrc = pData + (height - 1U) * stride;
+	src_index = (OPJ_SIZE_T)(height - 1U) * (OPJ_SIZE_T)stride;
+	pSrc = pData + src_index;
 	for(y = 0; y < height; y++)
 	{
 		for(x = 0; x < width; x++)
@@ -297,7 +304,7 @@ static opj_image_t* bmp8toimage(const OPJ_UINT8* pData, OPJ_UINT32 stride, opj_i
 	width  = image->comps[0].w;
 	height = image->comps[0].h;
 	
-	pSrc = pData + (height - 1U) * stride;
+	pSrc = pData + (OPJ_SIZE_T)(height - 1U) * (OPJ_SIZE_T)stride;
 	if (image->numcomps == 1U) {
 		opj_applyLUT8u_8u32s_C1R(pSrc, -(OPJ_INT32)stride, image->comps[0].data, (OPJ_INT32)width, pLUT[0], width, height);
 	}
@@ -488,8 +495,14 @@ static OPJ_BOOL bmp_read_info_header(FILE* IN, OPJ_BITMAPINFOHEADER* header)
 static OPJ_BOOL bmp_read_raw_data(FILE* IN, OPJ_UINT8* pData, OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)
 {
 	OPJ_ARG_NOT_USED(width);
+	/* Use size_t and check for overflow in stride * height */
+	if (height != 0U && (size_t)stride > SIZE_MAX / (size_t)height) {
+		fprintf(stderr, "\nError: BMP dimensions too large.\n");
+		return OPJ_FALSE;
+	}
+	const size_t l_size = (size_t)stride * (size_t)height;
 	
-	if ( fread(pData, sizeof(OPJ_UINT8), stride * height, IN) != (stride * height) )
+	if ( fread(pData, sizeof(OPJ_UINT8), l_size, IN) != l_size )
 	{
 		fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
 		return OPJ_FALSE;
@@ -497,6 +510,19 @@ static OPJ_BOOL bmp_read_raw_data(FILE* IN, OPJ_UINT8* pData, OPJ_UINT32 stride,
 	return OPJ_TRUE;
 }
 
+static OPJ_BOOL bmp_safe_mul_size_t(OPJ_SIZE_T a, OPJ_SIZE_T b, OPJ_SIZE_T* r)
+{
+	if (a == 0U || b == 0U) {
+		*r = 0U;
+		return OPJ_TRUE;
+	}
+	if (a > ((OPJ_SIZE_T)-1) / b) {
+		return OPJ_FALSE;
+	}
+	*r = a * b;
+	return OPJ_TRUE;
+}
+
 static OPJ_BOOL bmp_read_rle8_data(FILE* IN, OPJ_UINT8* pData, OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)
 {
 	OPJ_UINT32 x, y;
@@ -622,6 +648,8 @@ opj_image_t* bmptoimage(const char *filename, opj_cparameters_t *parameters)
 	OPJ_BOOL l_result = OPJ_FALSE;
 	OPJ_UINT8* pData = NULL;
 	OPJ_UINT32 stride;
+	OPJ_SIZE_T l_stride, l_size;
+	OPJ_UINT32 effectiveBitCount;
 	
 	pLUT[0] = lut_R; pLUT[1] = lut_G; pLUT[2] = lut_B;
 	
@@ -640,6 +668,12 @@ opj_image_t* bmptoimage(const char *filename, opj_cparameters_t *parameters)
 		fclose(IN);
 		return NULL;
 	}
+	/* Basic sanity checks to avoid underflows/overflows later */
+	if (Info_h.biWidth == 0U || Info_h.biHeight == 0U) {
+		fprintf(stderr, "Invalid BMP dimensions\n");
+		fclose(IN);
+		return NULL;
+	}
 	
 	/* Load palette */
 	if (Info_h.biBitCount <= 8U)
@@ -675,11 +709,44 @@ opj_image_t* bmptoimage(const char *filename, opj_cparameters_t *parameters)
 		}
 	}
 	
-	stride = ((Info_h.biWidth * Info_h.biBitCount + 31U) / 32U) * 4U; /* rows are aligned on 32bits */
-	if (Info_h.biBitCount == 4 && Info_h.biCompression == 2) { /* RLE 4 gets decoded as 8 bits data for now... */
-		stride = ((Info_h.biWidth * 8U + 31U) / 32U) * 4U;
+	effectiveBitCount = Info_h.biBitCount;
+	if (Info_h.biBitCount == 4U && Info_h.biCompression == 2U) { /* RLE 4 gets decoded as 8 bits data for now... */
+		effectiveBitCount = 8U;
+	}
+	/* Compute row stride with overflow-safe arithmetic. Rows are aligned on 32 bits. */
+	if (effectiveBitCount == 0U || effectiveBitCount > 32U) {
+		fprintf(stderr, "Unsupported BMP bit depth\n");
+		fclose(IN);
+		return NULL;
+	}
+	if (!bmp_safe_mul_size_t((OPJ_SIZE_T)Info_h.biWidth, (OPJ_SIZE_T)effectiveBitCount, &l_stride)) {
+		fprintf(stderr, "Invalid BMP dimensions (overflow)\n");
+		fclose(IN);
+		return NULL;
+	}
+	/* l_stride currently holds width * bitsPerPixel */
+	l_stride = ((l_stride + 31U) / 32U) * 4U;
+	if (l_stride > 0xFFFFFFFFU) {
+		fprintf(stderr, "Invalid BMP stride\n");
+		fclose(IN);
+		return NULL;
+	}
+	stride = (OPJ_UINT32)l_stride;
+	if (!bmp_safe_mul_size_t(l_stride, (OPJ_SIZE_T)Info_h.biHeight, &l_size)) {
+		fprintf(stderr, "Invalid BMP dimensions (overflow)\n");
+		fclose(IN);
+		return NULL;
+	}
+	/* For 24bpp raw BMP, ensure per-row indexing 3*x+2 stays within the stride */
+	if (Info_h.biBitCount == 24U && Info_h.biCompression == 0U) {
+		OPJ_SIZE_T required_per_row;
+		if (!bmp_safe_mul_size_t((OPJ_SIZE_T)Info_h.biWidth, 3U, &required_per_row) || required_per_row > l_stride) {
+			fprintf(stderr, "Invalid BMP row size\n");
+			fclose(IN);
+			return NULL;
+		}
 	}
-	pData = (OPJ_UINT8 *) calloc(1, stride * Info_h.biHeight * sizeof(OPJ_UINT8));
+	pData = (OPJ_UINT8 *)calloc(1, (size_t)l_size);
 	if (pData == NULL) {
 		fclose(IN);
 		return NULL;
diff --git a/src/bin/jp2/opj_compress.c b/src/bin/jp2/opj_compress.c
index 5a63a9d6..b0c3cab2 100644
--- a/src/bin/jp2/opj_compress.c
+++ b/src/bin/jp2/opj_compress.c
@@ -1730,7 +1730,7 @@ int main(int argc, char **argv) {
             image = bmptoimage(parameters.infile, &parameters);
             if (!image) {
                 fprintf(stderr, "Unable to load bmp file\n");
-                return 1;
+                return 0;
             }
             break;