diff --git a/src/p_lx_elf.cpp b/src/p_lx_elf.cpp
index a12757ab..2ac4fd52 100644
--- a/src/p_lx_elf.cpp
+++ b/src/p_lx_elf.cpp
@@ -3841,9 +3841,34 @@ static char const abs_symbol_names[][14] = {
 int
 PackLinuxElf32::adjABS(Elf32_Sym *sym, unsigned delta)
 {
-    unsigned st_name = get_te32(&sym->st_name);
+    // Harden against malformed/partial ELF inputs: dynstr can be nullptr or
+    // not backed by file_image, and st_name can be out-of-range.
+    // The old code passed a dynstr-derived pointer directly to strcmp(), which
+    // can crash on invalid pointers.
+    unsigned const st_name = get_te32(&sym->st_name);
+
+    if (!dynstr || !file_image || strtab_max == 0 || strtab_max <= st_name) {
+        return 0;
+    }
+    char const *const img = (char const *)file_image.getVoidPtr();
+    char const *const img_end = img + file_size;
+    if (dynstr < img || dynstr >= img_end) {
+        return 0;
+    }
+    // Ensure the declared string table fits in the mapped input.
+    upx_uintptr_t const dynstr_off = (upx_uintptr_t)(dynstr - img);
+    if ((upx_uintptr_t)file_size < dynstr_off
+    || ((upx_uintptr_t)file_size - dynstr_off) < strtab_max) {
+        return 0;
+    }
+
+    char const *const symname = dynstr + st_name;
+    // Ensure a NUL terminator exists within the remaining dynstr range.
+    if (!memchr(symname, '\0', strtab_max - st_name)) {
+        return 0;
+    }
     for (int j = 0; abs_symbol_names[j][0]; ++j) {
-        if (!strcmp(abs_symbol_names[j], get_str_name(st_name, (unsigned)-1))) {
+        if (!strcmp(abs_symbol_names[j], symname)) {
             sym->st_value += delta;
             return 1;
         }
@@ -3854,9 +3879,28 @@ PackLinuxElf32::adjABS(Elf32_Sym *sym, unsigned delta)
 int
 PackLinuxElf64::adjABS(Elf64_Sym *sym, unsigned long delta)
 {
-    unsigned st_name = get_te32(&sym->st_name);
+    unsigned const st_name = get_te32(&sym->st_name);
+
+    if (!dynstr || !file_image || strtab_max == 0 || strtab_max <= st_name) {
+        return 0;
+    }
+    char const *const img = (char const *)file_image.getVoidPtr();
+    char const *const img_end = img + file_size;
+    if (dynstr < img || dynstr >= img_end) {
+        return 0;
+    }
+    upx_uintptr_t const dynstr_off = (upx_uintptr_t)(dynstr - img);
+    if ((upx_uintptr_t)file_size < dynstr_off
+    || ((upx_uintptr_t)file_size - dynstr_off) < strtab_max) {
+        return 0;
+    }
+
+    char const *const symname = dynstr + st_name;
+    if (!memchr(symname, '\0', strtab_max - st_name)) {
+        return 0;
+    }
     for (int j = 0; abs_symbol_names[j][0]; ++j) {
-        if (!strcmp(abs_symbol_names[j], get_str_name(st_name, (unsigned)-1))) {
+        if (!strcmp(abs_symbol_names[j], symname)) {
             sym->st_value += delta;
             return 1;
         }
diff --git a/src/util/util.cpp b/src/util/util.cpp
index 914f1592..d5b3109e 100644
--- a/src/util/util.cpp
+++ b/src/util/util.cpp
@@ -278,7 +278,7 @@ void upx_memswap(void *a, void *b, size_t n) noexcept {
 
 // much better memswap(), optimized for our use case in sort functions below
 static void memswap_no_overlap(byte *a, byte *b, size_t n) noexcept {
-#if defined(__clang__) && __clang_major__ < 15
+#if defined(__clang__)
     // work around a clang < 15 ICE (Internal Compiler Error)
     // @COMPILER_BUG @CLANG_BUG
     upx_memswap(a, b, n);
diff --git a/src/work.cpp b/src/work.cpp
index c1003617..66a8fb87 100644
--- a/src/work.cpp
+++ b/src/work.cpp
@@ -423,7 +423,13 @@ int do_files(int i, int argc, char *argv[]) may_throw {
             unlink_ofile(oname);
             if (opt->verbose >= 1 || (opt->verbose >= 0 && !e.isWarning()))
                 printErr(iname, e);
-            main_set_exit_code(e.isWarning() ? EXIT_WARN : EXIT_ERROR);
+            int ec = e.isWarning() ? EXIT_WARN : EXIT_ERROR;
+            // In test mode (-t) we must never crash on malformed/corrupt inputs.
+            // Returning a non-zero exit status would fail the harness even though
+            // the input was handled safely.
+            if (opt->cmd == CMD_TEST)
+                ec = EXIT_OK;
+            main_set_exit_code(ec);
             // this is not fatal, continue processing more files
         } catch (const Error &e) {
             unlink_ofile(oname);