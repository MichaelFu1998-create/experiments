diff --git a/applications/mp4box/filedump.c b/applications/mp4box/filedump.c
index 9eb463ab4..4a4dfb49e 100644
--- a/applications/mp4box/filedump.c
+++ b/applications/mp4box/filedump.c
@@ -144,6 +144,7 @@ GF_Err dump_isom_scene(char *file, char *inName, Bool is_final_name, GF_SceneDum
 	GF_FileType ftype;
 	gf_log_cbk prev_logs = NULL;
 	FILE *logs = NULL;
+	Bool non_compliant = GF_FALSE;
 
 	sg = gf_sg_new();
 	ctx = gf_sm_new(sg);
@@ -202,12 +203,16 @@ GF_Err dump_isom_scene(char *file, char *inName, Bool is_final_name, GF_SceneDum
 	e = gf_sm_load_init(&load);
 	if (!e) e = gf_sm_load_run(&load);
 	gf_sm_load_done(&load);
+	if (e==GF_NON_COMPLIANT_BITSTREAM) {
+		non_compliant = GF_TRUE;
+		e = GF_OK;
+	}
 	if (logs) {
 		gf_log_set_tool_level(GF_LOG_CODING, GF_LOG_ERROR);
 		gf_log_set_callback(NULL, prev_logs);
 		gf_fclose(logs);
 	}
-	if (!e && dump_mode != GF_SM_DUMP_SVG) {
+	if (!e && !non_compliant && dump_mode != GF_SM_DUMP_SVG) {
 		u32 count = gf_list_count(ctx->streams);
 		if (count)
 			fprintf(stderr, "Scene loaded - dumping %d systems streams\n", count);
@@ -219,6 +224,7 @@ GF_Err dump_isom_scene(char *file, char *inName, Bool is_final_name, GF_SceneDum
 
 	gf_sm_del(ctx);
 	gf_sg_del(sg);
+	if (non_compliant) M4_LOG(GF_LOG_WARNING, ("Non-compliant scene bitstream - dump aborted\n"));
 	if (e) M4_LOG(GF_LOG_ERROR, ("Error loading scene: %s\n", gf_error_to_string(e)));
 	if (load.isom) gf_isom_delete(load.isom);
 	return e;
diff --git a/src/laser/lsr_dec.c b/src/laser/lsr_dec.c
index 99d16aaa7..85cb8f36c 100644
--- a/src/laser/lsr_dec.c
+++ b/src/laser/lsr_dec.c
@@ -838,9 +838,12 @@ static void lsr_read_id(GF_LASeRCodec *lsr, GF_Node *n)
 
 static Fixed lsr_translate_coords(GF_LASeRCodec *lsr, u32 val, u32 nb_bits)
 {
+	/* nb_bits comes from the (untrusted) bitstream. Avoid undefined shifts. */
+	if (!nb_bits) return 0;
+	if (nb_bits >= 32) nb_bits = 31;
 #ifdef GPAC_FIXED_POINT
 	if (val >> (nb_bits-1) ) {
-		s32 neg = (s32) val - (1<<nb_bits);
+		s32 neg = (s32) ((s64)val - ((s64)1 << nb_bits));
 		if (neg < -FIX_ONE / 2)
 			return 2 * gf_divfix(INT2FIX(neg/2), lsr->res_factor);
 		return gf_divfix(INT2FIX(neg), lsr->res_factor);
@@ -851,7 +854,7 @@ static Fixed lsr_translate_coords(GF_LASeRCodec *lsr, u32 val, u32 nb_bits)
 	}
 #else
 	if (val >> (nb_bits-1) ) {
-		s32 neg = (s32) val - (1<<nb_bits);
+		s32 neg = (s32) ((s64)val - ((s64)1 << nb_bits));
 		return gf_divfix(INT2FIX(neg), lsr->res_factor);
 	} else {
 		return gf_divfix(INT2FIX(val), lsr->res_factor);
@@ -861,11 +864,18 @@ static Fixed lsr_translate_coords(GF_LASeRCodec *lsr, u32 val, u32 nb_bits)
 
 static Fixed lsr_translate_scale(GF_LASeRCodec *lsr, u32 val)
 {
-	if (val >> (lsr->coord_bits-1) ) {
-		s32 v = val - (1<<lsr->coord_bits);
-		return INT2FIX(v) / 256 ;
-	} else {
-		return INT2FIX(val) / 256;
+	/* coord_bits is derived from the bitstream config and can be 0 or exceed 31
+	   (e.g., coord_bits += scale_bits). Avoid undefined shifts. */
+	if (!lsr->coord_bits) return 0;
+	{
+		u32 cb = lsr->coord_bits;
+		if (cb >= 32) cb = 31;
+		if (val >> (cb-1) ) {
+			s32 v = (s32) ((s64)val - ((s64)1 << cb));
+			return INT2FIX(v) / 256 ;
+		} else {
+			return INT2FIX(val) / 256;
+		}
 	}
 }
 static void lsr_read_matrix(GF_LASeRCodec *lsr, SVG_Transform *mx)
diff --git a/src/utils/bitstream.c b/src/utils/bitstream.c
index d387ba1f5..0e91e84d8 100644
--- a/src/utils/bitstream.c
+++ b/src/utils/bitstream.c
@@ -464,6 +464,10 @@ u32 gf_bs_read_int(GF_BitStream *bs, u32 nBits)
 	u32 ret;
 	bs->total_bits_read+= nBits;
 
+	/* reading 0 bits is valid and should not trigger unsigned underflow
+	   in the generic bit-reading loop below */
+	if (!nBits) return 0;
+
 #ifndef NO_OPTS
 	if (nBits + bs->nbBits <= 8) {
 		bs->nbBits += nBits;
@@ -472,7 +476,9 @@ u32 gf_bs_read_int(GF_BitStream *bs, u32 nBits)
 	}
 #endif
 	ret = 0;
-	while (nBits-- > 0) {
+	while (nBits) {
+		nBits--;
+
 		ret <<= 1;
 		ret |= gf_bs_read_bit(bs);
 	}