diff --git a/src/filter_core/filter_pck.c b/src/filter_core/filter_pck.c
index b093e8a70..f2927a754 100644
--- a/src/filter_core/filter_pck.c
+++ b/src/filter_core/filter_pck.c
@@ -105,6 +105,14 @@ static GF_FilterPacket *gf_filter_pck_new_alloc_internal(GF_FilterPid *pid, u32
 	GF_FilterPacket *closest=NULL;
 	u32 count, max_reservoir_size;
 
+	/* Defensive: callers may pass a NULL PID on error paths.
+	 * PID_IS_INPUT(pid) dereferences pid, so validate early.
+	 */
+	if (!pid || !pid->filter) {
+		GF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, ("Attempt to allocate a packet with a NULL PID\n"));
+		return NULL;
+	}
+
 	if (PID_IS_INPUT(pid)) {
 		GF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, ("Attempt to allocate a packet on an input PID in filter %s\n", pid->filter->name));
 		return NULL;
@@ -116,6 +124,8 @@ static GF_FilterPacket *gf_filter_pck_new_alloc_internal(GF_FilterPid *pid, u32
 		//don't let reservoir grow too large (may happen if burst of packets are stored/consumed in the upper chain)
 		while (count>30) {
 			GF_FilterPacket *head_pck = gf_fq_pop(pid->filter->pcks_alloc_reservoir);
+			if (!head_pck)
+				break;
 			gf_free(head_pck->data);
 			gf_free(head_pck);
 			count--;
@@ -173,6 +183,10 @@ static GF_FilterPacket *gf_filter_pck_new_alloc_internal(GF_FilterPid *pid, u32
 		//were added to the list
 
 		GF_FilterPacket *head_pck = gf_fq_pop(pid->filter->pcks_alloc_reservoir);
+		if (!head_pck) {
+			GF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, ("Packet reservoir inconsistency in filter %s (NULL pop)\n", pid->filter->name));
+			return NULL;
+		}
 		char *pck_data = pck->data;
 		u32 alloc_size = pck->alloc_size;
 		pck->data = head_pck->data;
diff --git a/src/filters/reframe_rawpcm.c b/src/filters/reframe_rawpcm.c
index 37decc00e..c71360b8d 100644
--- a/src/filters/reframe_rawpcm.c
+++ b/src/filters/reframe_rawpcm.c
@@ -394,6 +394,18 @@ GF_Err pcmreframe_process(GF_Filter *filter)
 
 	byte_offset+= ctx->wav_hdr_size;
 
+	/* If PID configuration failed (eg missing SR/CH on raw PCM),
+	 * ctx->opid may never have been created. Avoid passing NULL to
+	 * packet allocation and terminate processing cleanly.
+	 */
+	if (!ctx->opid) {
+		GF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, ("[PCMReframe] Output PID not configured, aborting\n"));
+		gf_filter_pid_set_discard(ctx->ipid, GF_TRUE);
+		gf_filter_pid_drop_packet(ctx->ipid);
+		ctx->done = GF_TRUE;
+		return GF_EOS;
+	}
+
 	while (pck_size) {
 		if (!ctx->out_pck) {
 			ctx->out_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->frame_size, &ctx->out_data);