diff --git a/src/futils.cpp b/src/futils.cpp
index d1427188..7c8343ee 100644
--- a/src/futils.cpp
+++ b/src/futils.cpp
@@ -53,7 +53,7 @@ EXIV2_RCSID("@(#) $Id$")
 # ifdef EXV_STRERROR_R_CHAR_P
 extern char *strerror_r(int errnum, char *buf, size_t n);
 # else
-extern int strerror_r(int errnum, char *buf, size_t n);
+extern char *strerror_r(int errnum, char *buf, size_t n);
 # endif
 #endif
 
@@ -241,8 +241,8 @@ namespace Exiv2 {
     Protocol fileProtocol(const std::string& path) {
         Protocol result = pFile ;
         struct {
-        	std::string name ;
-        	Protocol    prot ;
+                std::string name ;
+                Protocol    prot ;
         } prots[] =
         { { "http://"   ,pHttp     }
         , { "https://"  ,pHttps    }
@@ -254,8 +254,8 @@ namespace Exiv2 {
         , { "-"         ,pStdin    }
         };
         for ( size_t i = 0 ; result == pFile && i < sizeof(prots)/sizeof(prots[0]) ; i ++ )
-        	if ( path.find(prots[i].name) == 0 )
-        		result = prots[i].prot;
+                if ( path.find(prots[i].name) == 0 )
+                        result = prots[i].prot;
 
         return result;
     } // fileProtocol
@@ -263,8 +263,8 @@ namespace Exiv2 {
     Protocol fileProtocol(const std::wstring& wpath) {
         Protocol result = pFile ;
         struct {
-        	std::wstring wname ;
-        	Protocol      prot ;
+                std::wstring wname ;
+                Protocol      prot ;
         } prots[] =
         { { L"http://"   ,pHttp     }
         , { L"https://"  ,pHttps    }
@@ -276,21 +276,21 @@ namespace Exiv2 {
         , { L"-"         ,pStdin    }
         };
         for ( size_t i = 0 ; result == pFile && i < sizeof(prots)/sizeof(prots[0]) ; i ++ )
-        	if ( wpath.find(prots[i].wname) == 0 )
-        		result = prots[i].prot;
+                if ( wpath.find(prots[i].wname) == 0 )
+                        result = prots[i].prot;
 
         return result;
     } // fileProtocol
 #endif
     bool fileExists(const std::string& path, bool ct)
     {
-		// special case: accept "-" (means stdin)
+                // special case: accept "-" (means stdin)
         if (path.compare("-") == 0 || fileProtocol(path)) {
-			return true;
+                        return true;
         }
 
         struct stat buf;
-		int ret = ::stat(path.c_str(), &buf);
+                int ret = ::stat(path.c_str(), &buf);
         if (0 != ret)                    return false;
         if (ct && !S_ISREG(buf.st_mode)) return false;
         return true;
@@ -299,9 +299,9 @@ namespace Exiv2 {
 #ifdef EXV_UNICODE_PATH
     bool fileExists(const std::wstring& wpath, bool ct)
     {
-		// special case: accept "-" (means stdin)
+                // special case: accept "-" (means stdin)
         if (wpath.compare(L"-") == 0 || fileProtocol(wpath)) {
-			return true;
+                        return true;
         }
 
         struct _stat buf;
diff --git a/src/tiffvisitor.cpp b/src/tiffvisitor.cpp
index 4ab733d4..c00d7521 100644
--- a/src/tiffvisitor.cpp
+++ b/src/tiffvisitor.cpp
@@ -1494,46 +1494,63 @@ namespace Exiv2 {
         }
         p += 4;
         uint32_t isize= 0; // size of Exif.Sony1.PreviewImage
-        uint32_t size = typeSize * count;
-        uint32_t offset = getLong(p, byteOrder());
-        byte* pData = p;
-        if (   size > 4
-            && (   baseOffset() + offset >= size_
-                || static_cast<int32_t>(baseOffset()) + offset <= 0)) {
-                // #1143
-                if ( object->tag() == 0x2001 && std::string(groupName(object->group())) == "Sony1" ) {
-                	isize=size;
-                } else {
-#ifndef SUPPRESS_WARNINGS
-            EXV_ERROR << "Offset of directory " << groupName(object->group())
+        uint64_t size64 = static_cast<uint64_t>(typeSize) * static_cast<uint64_t>(count);
+        if (size64 > 0xffffffffULL) {
+        #ifndef SUPPRESS_WARNINGS
+            EXV_ERROR << "Directory " << groupName(object->group())
                       << ", entry 0x" << std::setw(4)
                       << std::setfill('0') << std::hex << object->tag()
-                      << " is out of bounds: "
-                      << "Offset = 0x" << std::setw(8)
-                      << std::setfill('0') << std::hex << offset
-                      << "; truncating the entry\n";
-#endif
-				}
-                size = 0;
+                      << " has invalid size "
+                      << std::dec << count << "*" << typeSize
+                      << "; skipping entry\n";
+        #endif
+            return;
         }
+        uint32_t size = static_cast<uint32_t>(size64);
+        const int32_t soffset = getLong(p, byteOrder());
+        uint32_t offset = static_cast<uint32_t>(soffset);
+        byte* pData = p;
         if (size > 4) {
-            pData = const_cast<byte*>(pData_) + baseOffset() + offset;
-            if (size > static_cast<uint32_t>(pLast_ - pData)) {
-#ifndef SUPPRESS_WARNINGS
-                EXV_ERROR << "Upper boundary of data for "
-                          << "directory " << groupName(object->group())
-                          << ", entry 0x" << std::setw(4)
-                          << std::setfill('0') << std::hex << object->tag()
-                          << " is out of bounds: "
-                          << "Offset = 0x" << std::setw(8)
-                          << std::setfill('0') << std::hex << offset
-                          << ", size = " << std::dec << size
-                          << ", exceeds buffer size by "
-                          // cast to make MSVC happy
-                          << static_cast<uint32_t>(pData + size - pLast_)
-                          << " Bytes; truncating the entry\n";
-#endif
+            // Validate offsets using 64-bit arithmetic before forming pointers.
+            if (soffset < 0) {
+                // #1143
+                if ( object->tag() == 0x2001 && std::string(groupName(object->group())) == "Sony1" ) {
+                    isize = size;
+                } else {
+        #ifndef SUPPRESS_WARNINGS
+                    EXV_ERROR << "Offset of directory " << groupName(object->group())
+                              << ", entry 0x" << std::setw(4)
+                              << std::setfill('0') << std::hex << object->tag()
+                              << " is out of bounds: "
+                              << "Offset = 0x" << std::setw(8)
+                              << std::setfill('0') << std::hex << offset
+                              << "; truncating the entry\n";
+        #endif
+                }
                 size = 0;
+            } else {
+                const uint64_t dataPos = static_cast<uint64_t>(baseOffset()) + static_cast<uint64_t>(offset);
+                if (dataPos >= size_ || dataPos + static_cast<uint64_t>(size) > size_) {
+                    // #1143
+                    if ( object->tag() == 0x2001 && std::string(groupName(object->group())) == "Sony1" ) {
+                        isize = size;
+                    } else {
+        #ifndef SUPPRESS_WARNINGS
+                        EXV_ERROR << "Upper boundary of data for "
+                                  << "directory " << groupName(object->group())
+                                  << ", entry 0x" << std::setw(4)
+                                  << std::setfill('0') << std::hex << object->tag()
+                                  << " is out of bounds: "
+                                  << "Offset = 0x" << std::setw(8)
+                                  << std::setfill('0') << std::hex << offset
+                                  << ", size = " << std::dec << size
+                                  << "; truncating the entry\n";
+        #endif
+                    }
+                    size = 0;
+                } else {
+                    pData = const_cast<byte*>(pData_) + dataPos;
+                }
             }
         }
         Value::AutoPtr v = Value::create(typeId);
diff --git a/src/types.cpp b/src/types.cpp
index 3d539908..cea1b775 100644
--- a/src/types.cpp
+++ b/src/types.cpp
@@ -243,12 +243,16 @@ namespace Exiv2 {
     uint32_t getULong(const byte* buf, ByteOrder byteOrder)
     {
         if (byteOrder == littleEndian) {
-            return   (byte)buf[3] << 24 | (byte)buf[2] << 16
-                   | (byte)buf[1] <<  8 | (byte)buf[0];
+            return   (static_cast<uint32_t>(buf[3]) << 24)
+                   | (static_cast<uint32_t>(buf[2]) << 16)
+                   | (static_cast<uint32_t>(buf[1]) <<  8)
+                   |  static_cast<uint32_t>(buf[0]);
         }
         else {
-            return   (byte)buf[0] << 24 | (byte)buf[1] << 16
-                   | (byte)buf[2] <<  8 | (byte)buf[3];
+            return   (static_cast<uint32_t>(buf[0]) << 24)
+                   | (static_cast<uint32_t>(buf[1]) << 16)
+                   | (static_cast<uint32_t>(buf[2]) <<  8)
+                   |  static_cast<uint32_t>(buf[3]);
         }
     }
 
@@ -288,12 +292,18 @@ namespace Exiv2 {
     int32_t getLong(const byte* buf, ByteOrder byteOrder)
     {
         if (byteOrder == littleEndian) {
-            return   (byte)buf[3] << 24 | (byte)buf[2] << 16
-                   | (byte)buf[1] <<  8 | (byte)buf[0];
+            return static_cast<int32_t>(
+                (static_cast<uint32_t>(buf[3]) << 24)
+              | (static_cast<uint32_t>(buf[2]) << 16)
+              | (static_cast<uint32_t>(buf[1]) <<  8)
+              |  static_cast<uint32_t>(buf[0]));
         }
         else {
-            return   (byte)buf[0] << 24 | (byte)buf[1] << 16
-                   | (byte)buf[2] <<  8 | (byte)buf[3];
+            return static_cast<int32_t>(
+                (static_cast<uint32_t>(buf[0]) << 24)
+              | (static_cast<uint32_t>(buf[1]) << 16)
+              | (static_cast<uint32_t>(buf[2]) <<  8)
+              |  static_cast<uint32_t>(buf[3]));
         }
     }
 
diff --git a/src/value.cpp b/src/value.cpp
index d5189263..420d4a8f 100644
--- a/src/value.cpp
+++ b/src/value.cpp
@@ -299,7 +299,18 @@ namespace Exiv2 {
     int StringValueBase::read(const byte* buf, long len, ByteOrder /*byteOrder*/)
     {
         // byteOrder not needed
-        if (buf) value_ = std::string(reinterpret_cast<const char*>(buf), len);
+        if (!buf) {
+            value_.clear();
+            return 0;
+        }
+        // Defensive: avoid negative lengths and avoid implicit signed->unsigned
+        // conversion when constructing std::string.
+        if (len <= 0) {
+            value_.clear();
+            return 0;
+        }
+
+        value_ = std::string(reinterpret_cast<const char*>(buf), static_cast<size_t>(len));
         return 0;
     }