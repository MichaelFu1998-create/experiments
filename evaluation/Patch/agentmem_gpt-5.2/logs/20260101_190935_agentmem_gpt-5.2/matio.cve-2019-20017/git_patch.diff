diff --git a/src/mat5.c b/src/mat5.c
index abdb351..0b54741 100644
--- a/src/mat5.c
+++ b/src/mat5.c
@@ -967,6 +967,7 @@ ReadNextCell( mat_t *mat, matvar_t *matvar )
             if ( cells[i]->class_type != MAT_C_OPAQUE ) {
                 mat_uint32_t* dims = NULL;
                 int do_clean = 0;
+                const size_t max_stack_rank = (sizeof(uncomp_buf)/sizeof(uncomp_buf[0])) - 2;
                 bytesread += InflateRankDims(mat,matvar,uncomp_buf,sizeof(uncomp_buf),&dims);
                 if ( NULL == dims )
                     dims = uncomp_buf + 2;
@@ -1343,6 +1344,7 @@ ReadNextStructField( mat_t *mat, matvar_t *matvar )
             if ( fields[i]->class_type != MAT_C_OPAQUE ) {
                 mat_uint32_t* dims = NULL;
                 int do_clean = 0;
+                const size_t max_stack_rank = (sizeof(uncomp_buf)/sizeof(uncomp_buf[0])) - 2;
                 bytesread += InflateRankDims(mat,matvar,uncomp_buf,sizeof(uncomp_buf),&dims);
                 if ( NULL == dims )
                     dims = uncomp_buf + 2;
@@ -4833,6 +4835,7 @@ Mat_VarReadNextInfo5( mat_t *mat )
             if ( matvar->class_type != MAT_C_OPAQUE ) {
                 mat_uint32_t* dims = NULL;
                 int do_clean = 0;
+                const size_t max_stack_rank = (sizeof(uncomp_buf)/sizeof(uncomp_buf[0])) - 2;
                 bytesread += InflateRankDims(mat,matvar,uncomp_buf,sizeof(uncomp_buf),&dims);
                 if ( NULL == dims )
                     dims = uncomp_buf + 2;
@@ -4847,7 +4850,34 @@ Mat_VarReadNextInfo5( mat_t *mat )
                     int j;
                     nbytes = uncomp_buf[1];
                     matvar->rank = nbytes / 4;
+
+                    /*
+                     * If InflateRankDims didn't allocate a separate dimensions buffer,
+                     * dims points into uncomp_buf+2 which can hold only 14 uint32_t
+                     * entries (16 words total minus 2 tag words).
+                     *
+                     * Malformed/crafted files can claim a larger rank and trigger a
+                     * stack out-of-bounds read when copying dims.
+                     */
+                    if ( !do_clean && (size_t)matvar->rank > max_stack_rank ) {
+                        Mat_Critical("Invalid rank %d (max %lu)", matvar->rank,
+                                     (unsigned long)max_stack_rank);
+                        Mat_VarFree(matvar);
+                        matvar = NULL;
+                        (void)fseek((FILE*)mat->fp,nBytes+8+fpos,SEEK_SET);
+                        break;
+                    }
+
                     matvar->dims = (size_t*)malloc(matvar->rank*sizeof(*matvar->dims));
+                    if ( NULL == matvar->dims && matvar->rank > 0 ) {
+                        Mat_Critical("Couldn't allocate memory for dims");
+                        if ( do_clean )
+                            free(dims);
+                        Mat_VarFree(matvar);
+                        matvar = NULL;
+                        (void)fseek((FILE*)mat->fp,nBytes+8+fpos,SEEK_SET);
+                        break;
+                    }
                     if ( mat->byteswap ) {
                         for ( j = 0; j < matvar->rank; j++ )
                             matvar->dims[j] = Mat_uint32Swap(dims + j);