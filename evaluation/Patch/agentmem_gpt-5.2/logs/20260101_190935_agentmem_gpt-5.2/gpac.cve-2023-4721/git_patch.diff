diff --git a/src/media_tools/mpeg2_ps.c b/src/media_tools/mpeg2_ps.c
index 0af7a31f3..e29d04cbe 100644
--- a/src/media_tools/mpeg2_ps.c
+++ b/src/media_tools/mpeg2_ps.c
@@ -263,24 +263,34 @@ int MPEG12_ParseSeqHdr(unsigned char *pbuffer, u32 buflen, s32 *have_mpeg2, u32
 	u32 framerate_code;
 	u32 bitrate_int;
 	u32 bitrate_ext;
-	u32 scode, ix;
+	u32 scode;
 	s32 found = -1;
+	u8 *end;
+	u8 *cur;
+
 	*have_mpeg2 = 0;
-	buflen -= 6;
+	if (!pbuffer || (buflen < 4))
+		return found;
+	end = pbuffer + buflen;
+
 	bitrate_int = 0;
-	for (ix = 0; ix < buflen; ix++, pbuffer++) {
-		scode = ((u32)pbuffer[0] << 24) | (pbuffer[1] << 16) | (pbuffer[2] << 8) |
-		        pbuffer[3];
+	cur = pbuffer;
+	while (cur + 4 <= end) {
+		scode = ((u32)cur[0] << 24) | ((u32)cur[1] << 16) | ((u32)cur[2] << 8) | (u32)cur[3];
 
 		if (scode == MPEG12_SEQUENCE_START_CODE) {
-			pbuffer += sizeof(u32);
-			*width = (pbuffer[0]);
+			/* Need 7 bytes after the 4-byte start code to parse sequence header fields */
+			u8 *seq = cur + sizeof(u32);
+			if (seq + 7 > end)
+				break;
+
+			*width = (u32)seq[0];
 			*width <<= 4;
-			*width |= ((pbuffer[1] >> 4) &0xf);
-			*height = (pbuffer[1] & 0xf);
+			*width |= ((seq[1] >> 4) & 0xf);
+			*height = (u32)(seq[1] & 0xf);
 			*height <<= 8;
-			*height |= pbuffer[2];
-			aspect_code = (pbuffer[3] >> 4) & 0xf;
+			*height |= (u32)seq[2];
+			aspect_code = (seq[3] >> 4) & 0xf;
 			if (aspect_ratio != NULL) {
 				u32 par = 0;
 				switch (aspect_code) {
@@ -306,31 +316,34 @@ int MPEG12_ParseSeqHdr(unsigned char *pbuffer, u32 buflen, s32 *have_mpeg2, u32
 				*aspect_ratio = par;
 			}
 
-
-			framerate_code = pbuffer[3] & 0xf;
+			framerate_code = seq[3] & 0xf;
 			*frame_rate = mpeg12_frame_rate_table[framerate_code];
 			// 18 bits
-			bitrate_int = (pbuffer[4] << 10) |
-			              (pbuffer[5] << 2) |
-			              ((pbuffer[6] >> 6) & 0x3);
+			bitrate_int = ((u32)seq[4] << 10) |
+			              ((u32)seq[5] << 2) |
+			              (((u32)seq[6] >> 6) & 0x3);
 			*bitrate = bitrate_int;
 			*bitrate *= 400.0;
-			ix += sizeof(u32) + 7;
-			pbuffer += 7;
 			found = 0;
+
+			/* Skip parsed fields */
+			cur = seq + 7;
+			continue;
 		} else if (found == 0) {
 			if (scode == MPEG12_EXT_START_CODE) {
-				pbuffer += sizeof(u32);
-				ix += sizeof(u32);
-				switch ((pbuffer[0] >> 4) & 0xf) {
+				u8 *ext = cur + sizeof(u32);
+				/* We access ext[0..3] below */
+				if (ext + 4 > end)
+					break;
+				switch ((ext[0] >> 4) & 0xf) {
 				case SEQ_ID:
 					*have_mpeg2 = 1;
-					*height = ((pbuffer[1] & 0x1) << 13) |
-					          ((pbuffer[2] & 0x80) << 5) |
+					*height = ((ext[1] & 0x1) << 13) |
+					          ((ext[2] & 0x80) << 5) |
 					          (*height & 0x0fff);
-					*width = (((pbuffer[2] >> 5) & 0x3) << 12) | (*width & 0x0fff);
-					bitrate_ext = (pbuffer[2] & 0x1f) << 7;
-					bitrate_ext |= (pbuffer[3] >> 1) & 0x7f;
+					*width = (((ext[2] >> 5) & 0x3) << 12) | (*width & 0x0fff);
+					bitrate_ext = (ext[2] & 0x1f) << 7;
+					bitrate_ext |= (ext[3] >> 1) & 0x7f;
 					bitrate_int |= (bitrate_ext << 18);
 					*bitrate = bitrate_int;
 					*bitrate *= 400.0;
@@ -338,17 +351,20 @@ int MPEG12_ParseSeqHdr(unsigned char *pbuffer, u32 buflen, s32 *have_mpeg2, u32
 				default:
 					break;
 				}
-				pbuffer++;
-				ix++;
+				/* Skip extension start code and one byte as in legacy logic */
+				cur = ext + 1;
+				continue;
 			} else if (scode == MPEG12_PICTURE_START_CODE) {
 				return found;
 			}
 		}
+		cur++;
 	}
 	return found;
 }
 
 
+
 s32 MPEG12_PictHdrType (unsigned char *pbuffer)
 {
 	pbuffer += sizeof(u32);