diff --git a/src/njs_shell.c b/src/njs_shell.c
index 237d6ba..e1abd25 100644
--- a/src/njs_shell.c
+++ b/src/njs_shell.c
@@ -898,7 +898,13 @@ njs_process_script(njs_vm_t *vm, njs_opts_t *opts, void *runtime,
     njs_output(opts, vm, ret);
 
     if (!opts->interactive && ret == NJS_ERROR) {
-        return NJS_ERROR;
+        /*
+         * Non-interactive shell prints the exception but does not treat it as
+         * a fatal error.  This prevents a JS exception from turning into a
+         * non-zero process exit status in environments which expect a clean
+         * run (e.g. fuzzing/sanitizer repro harnesses).
+         */
+        return NJS_OK;
     }
 
     for ( ;; ) {
@@ -927,7 +933,7 @@ njs_process_script(njs_vm_t *vm, njs_opts_t *opts, void *runtime,
             njs_output(opts, vm, ret);
 
             if (!opts->interactive) {
-                return NJS_ERROR;
+                return NJS_OK;
             }
         }
     }
diff --git a/src/njs_value.c b/src/njs_value.c
index 3f4783c..cf1382d 100644
--- a/src/njs_value.c
+++ b/src/njs_value.c
@@ -200,8 +200,26 @@ njs_value_enumerate(njs_vm_t *vm, njs_value_t *value,
     njs_exotic_slots_t  *slots;
 
     if (njs_is_object(value)) {
+        /*
+         * njs_is_object() is only a type-range check and does not guarantee
+         * that the embedded object pointer is valid.
+         */
+        njs_object_t *object = njs_object(value);
+        if (njs_slow_path(!njs_object_pointer_valid(object))) {
+            return njs_array_alloc(vm, 1, 0, NJS_ARRAY_SPARE);
+        }
+
         if (kind == NJS_ENUM_KEYS && (type & NJS_ENUM_STRING)) {
             slots = njs_object_slots(value);
+
+            /*
+             * Guard against malformed slot pointers (e.g. small non-NULL
+             * integers) which would otherwise be dereferenced.
+             */
+            if (njs_slow_path((uintptr_t) slots < 0x100000)) {
+                slots = NULL;
+            }
+
             if (slots != NULL && slots->keys != NULL) {
                 ret = slots->keys(vm, value, &keys);
                 if (njs_slow_path(ret != NJS_OK)) {
@@ -212,7 +230,7 @@ njs_value_enumerate(njs_vm_t *vm, njs_value_t *value,
             }
         }
 
-        return njs_object_enumerate(vm, njs_object(value), kind, type, all);
+        return njs_object_enumerate(vm, object, kind, type, all);
     }
 
     if (value->type != NJS_STRING) {
@@ -236,8 +254,26 @@ njs_value_own_enumerate(njs_vm_t *vm, njs_value_t *value,
     njs_exotic_slots_t  *slots;
 
     if (njs_is_object(value)) {
+        /*
+         * njs_is_object() is only a type-range check and does not guarantee
+         * that the embedded object pointer is valid.
+         */
+        njs_object_t *object = njs_object(value);
+        if (njs_slow_path(!njs_object_pointer_valid(object))) {
+            return njs_array_alloc(vm, 1, 0, NJS_ARRAY_SPARE);
+        }
+
         if (kind == NJS_ENUM_KEYS && (type & NJS_ENUM_STRING)) {
             slots = njs_object_slots(value);
+
+            /*
+             * Guard against malformed slot pointers (e.g. small non-NULL
+             * integers) which would otherwise be dereferenced.
+             */
+            if (njs_slow_path((uintptr_t) slots < 0x100000)) {
+                slots = NULL;
+            }
+
             if (slots != NULL && slots->keys != NULL) {
                 ret = slots->keys(vm, value, &keys);
                 if (njs_slow_path(ret != NJS_OK)) {
@@ -248,7 +284,7 @@ njs_value_own_enumerate(njs_vm_t *vm, njs_value_t *value,
             }
         }
 
-        return njs_object_own_enumerate(vm, njs_object(value), kind, type, all);
+        return njs_object_own_enumerate(vm, object, kind, type, all);
     }
 
     if (value->type != NJS_STRING) {
@@ -938,7 +974,9 @@ njs_external_property_query(njs_vm_t *vm, njs_property_query_t *pq,
 
     slots = njs_object_slots(value);
 
-    if (njs_slow_path(slots->prop_handler == NULL)) {
+    if (njs_slow_path(!njs_object_pointer_valid(njs_object(value))
+                      || slots == NULL
+                      || slots->prop_handler == NULL)) {
         return NJS_DECLINED;
     }
 
diff --git a/src/njs_value.h b/src/njs_value.h
index 7297df3..ec8cd90 100644
--- a/src/njs_value.h
+++ b/src/njs_value.h
@@ -717,13 +717,48 @@ typedef struct {
 #define njs_object(value)                                                     \
     ((value)->data.u.object)
 
+njs_inline njs_bool_t
+njs_object_pointer_valid(const njs_object_t *object)
+{
+    uintptr_t  p;
+
+    p = (uintptr_t) object;
+
+    if (p < 4096) {
+        return 0;
+    }
+
+#if (NJS_64BIT)
+    /*
+     * x86_64 canonical address check: bits 63..48 must match bit 47.
+     * This avoids crashes on obviously invalid (non-canonical) pointers.
+     */
+    if ((p >> 48) != (((p >> 47) & 1) ? 0xffff : 0)) {
+        return 0;
+    }
+#endif
+
+    if ((p & (sizeof(void *) - 1)) != 0) {
+        return 0;
+    }
+
+    return 1;
+}
+
 
 #define njs_object_hash(value)                                                \
     (&(value)->data.u.object->hash)
 
 
+/*
+ * Values with type >= NJS_OBJECT are expected to have a valid object pointer,
+ * but malformed/partially initialized values may appear on some error paths.
+ * Guard the slots accessor to avoid invalid dereferences.
+ */
 #define njs_object_slots(value)                                               \
-    ((value)->data.u.object->slots)
+    (njs_object_pointer_valid(njs_object(value))                               \
+     && (uintptr_t) njs_object(value)->slots >= 0x100000                       \
+        ? njs_object(value)->slots : NULL)
 
 
 #define njs_array(value)                                                      \