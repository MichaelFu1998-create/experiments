diff --git a/src/decode.c b/src/decode.c
index 96b48ef4..47a01767 100644
--- a/src/decode.c
+++ b/src/decode.c
@@ -31,6 +31,7 @@
 #include <string.h>
 #include <stdbool.h>
 #include <assert.h>
+#include <limits.h>
 #ifdef HAVE_WCHAR_H
 #  include <wchar.h>
 #endif
@@ -2256,8 +2257,8 @@ read_2004_compressed_section (Bit_Chain *dat, Dwg_Data *restrict dwg,
                               Bit_Chain *sec_dat, Dwg_Section_Type type)
 {
   uint32_t address, sec_mask, initial_address;
-  uint32_t max_decomp_size;
-  long bytes_left;
+  size_t max_decomp_size;
+  size_t bytes_left;
   Dwg_Section_Info *info = NULL;
   encrypted_section_header es;
   BITCODE_RC *decomp;
@@ -2295,9 +2296,25 @@ read_2004_compressed_section (Bit_Chain *dat, Dwg_Data *restrict dwg,
                  info->compressed == 2 ? "" : "un");
     }
 
-  max_decomp_size = info->num_sections * info->max_decomp_size;
   if (info->num_sections == 0)
     return 0;
+  if (info->max_decomp_size == 0)
+    {
+      LOG_ERROR ("Invalid section %s count or max decompression size. "
+                 "Sections: %u, Max size: %u",
+                 info->name, info->num_sections, info->max_decomp_size);
+      return DWG_ERR_INVALIDDWG;
+    }
+  /* Prevent under-allocation via integer overflow. */
+  if ((size_t)info->num_sections > (SIZE_MAX / (size_t)info->max_decomp_size))
+    {
+      LOG_ERROR ("Invalid section %s count or max decompression size. "
+                 "Sections: %u, Max size: %u",
+                 info->name, info->num_sections, info->max_decomp_size);
+      return DWG_ERR_VALUEOUTOFBOUNDS;
+    }
+
+  max_decomp_size = (size_t)info->num_sections * (size_t)info->max_decomp_size;
   if (max_decomp_size == 0 || max_decomp_size > 0x2f000000) // 790Mb
     {
       LOG_ERROR ("Invalid section %s count or max decompression size. "
@@ -2305,12 +2322,14 @@ read_2004_compressed_section (Bit_Chain *dat, Dwg_Data *restrict dwg,
                  info->name, info->num_sections, info->max_decomp_size);
       return DWG_ERR_INVALIDDWG;
     }
+
   decomp = (BITCODE_RC *)calloc (max_decomp_size, sizeof (BITCODE_RC));
   if (!decomp)
     {
       LOG_ERROR ("Out of memory with %u sections", info->num_sections);
       return DWG_ERR_OUTOFMEM;
     }
+
   bytes_left = max_decomp_size;
   initial_address = info->sections[0] ? info->sections[0]->address : 0;
   sec_dat->bit = 0;
@@ -2321,11 +2340,35 @@ read_2004_compressed_section (Bit_Chain *dat, Dwg_Data *restrict dwg,
 
   for (i = 0; i < info->num_sections; ++i)
     {
+      const size_t stride = (size_t)info->max_decomp_size;
+      size_t dst_off;
+
       if (!info->sections[i])
         {
           LOG_WARN ("Skip empty section %u %s", i, info->name);
           continue;
         }
+
+      /* Destination slot bounds: output buffer is allocated as
+         num_sections * max_decomp_size, so we must also index by that stride. */
+      if (stride == 0 || (size_t)i > (SIZE_MAX / stride))
+        {
+          LOG_ERROR ("Some section size out of bounds")
+          sec_dat->chain = NULL;
+          free (decomp);
+          return type < SECTION_REVHISTORY ? DWG_ERR_INVALIDDWG
+                                           : DWG_ERR_VALUEOUTOFBOUNDS;
+        }
+      dst_off = (size_t)i * stride;
+      if (dst_off > max_decomp_size || stride > max_decomp_size - dst_off)
+        {
+          LOG_ERROR ("Some section size out of bounds")
+          sec_dat->chain = NULL;
+          free (decomp);
+          return type < SECTION_REVHISTORY ? DWG_ERR_INVALIDDWG
+                                           : DWG_ERR_VALUEOUTOFBOUNDS;
+        }
+
       address = info->sections[i]->address;
       dat->byte = address;
       bit_read_fixed (dat, es.char_data, 32);
@@ -2364,15 +2407,14 @@ read_2004_compressed_section (Bit_Chain *dat, Dwg_Data *restrict dwg,
       LOG_INSANE ("max_decomp_size:          %lu (0x%lx)\n",
                   (unsigned long)max_decomp_size,
                   (unsigned long)max_decomp_size)
-      LOG_INSANE ("bytes_left:               %ld\n", bytes_left);
+      LOG_INSANE ("bytes_left:               %lu\n",
+                  (unsigned long)bytes_left);
 
       // check if compressed at all
-      if (info->compressed == 2
-          && bytes_left > 0
-          && (i * info->max_decomp_size) <= max_decomp_size)
+      if (info->compressed == 2)
         {
           error = decompress_R2004_section (
-              dat, &decomp[i * info->max_decomp_size], // offset
+              dat, &decomp[dst_off], // offset
               info->max_decomp_size, es.fields.data_size);
           if (error > DWG_ERR_CRITICAL)
             {
@@ -2380,18 +2422,18 @@ read_2004_compressed_section (Bit_Chain *dat, Dwg_Data *restrict dwg,
               free (decomp);
               return error;
             }
-          bytes_left -= info->max_decomp_size;
+          if (bytes_left >= stride)
+            bytes_left -= stride;
+          else
+            bytes_left = 0;
           sec_dat->size = max_decomp_size;
         }
       else
         {
-          if (info->compressed == 2
-              || info->size > max_decomp_size
-              || bytes_left < 0
-            /*|| ((unsigned long)(address + es.fields.address + 32
-                                   + info->size)
-                                   > dat->size) */
-              )
+          size_t src_off;
+          size_t copy_len;
+
+          if (info->size < 0)
             {
               LOG_ERROR ("Some section size out of bounds")
               sec_dat->chain = NULL;
@@ -2399,10 +2441,29 @@ read_2004_compressed_section (Bit_Chain *dat, Dwg_Data *restrict dwg,
               return type < SECTION_REVHISTORY ? DWG_ERR_INVALIDDWG
                                                : DWG_ERR_VALUEOUTOFBOUNDS;
             }
-          memcpy (&decomp[i * info->size],
-                  &dat->chain[address + es.fields.address + 32],
-                  MIN (bytes_left, info->size));
-          bytes_left -= info->size;
+
+          /* Cap to the allocated per-section slot. */
+          copy_len = (size_t)info->size;
+          if (copy_len > stride)
+            copy_len = stride;
+
+          /* Validate source pointer arithmetic against dat->size. */
+          src_off = (size_t)address + (size_t)es.fields.address + 32u;
+          if (src_off > dat->size || copy_len > dat->size - src_off)
+            {
+              LOG_ERROR ("Some section size out of bounds")
+              sec_dat->chain = NULL;
+              free (decomp);
+              return type < SECTION_REVHISTORY ? DWG_ERR_INVALIDDWG
+                                               : DWG_ERR_VALUEOUTOFBOUNDS;
+            }
+
+          memcpy (&decomp[dst_off], &dat->chain[src_off], copy_len);
+
+          if (bytes_left >= stride)
+            bytes_left -= stride;
+          else
+            bytes_left = 0;
           sec_dat->size = max_decomp_size;
         }
     }
@@ -2769,6 +2830,11 @@ read_2004_section_summary (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)
   // not compressed, page size: 0x100
   int error = read_2004_compressed_section (dat, dwg, &sec_dat,
                                         SECTION_SUMMARYINFO); // always 9
+  if (error & DWG_ERR_SECTIONNOTFOUND)
+    {
+      LOG_INFO ("%s section not found\n", "SummaryInfo");
+      return 0;
+    }
   if (error >= DWG_ERR_CRITICAL || !sec_dat.chain)
     {
       LOG_ERROR ("Failed to read uncompressed %s section", "SummaryInfo");
@@ -3084,6 +3150,14 @@ read_2004_section_template (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)
   error = read_2004_compressed_section (dat, dwg, &sec_dat, SECTION_TEMPLATE);
   if (error >= DWG_ERR_CRITICAL || !sec_dat.chain)
     {
+      /* The Template section contains only a few header variables (e.g.
+         MEASUREMENT). Treat absence as non-fatal to avoid aborting on
+         malformed files. */
+      if (error & DWG_ERR_SECTIONNOTFOUND)
+        {
+          LOG_INFO ("%s section not found\n", "Template");
+          return 0;
+        }
       UNTIL (R_2004)
         {
           LOG_INFO ("%s section not found\n", "Template")
@@ -3093,7 +3167,7 @@ read_2004_section_template (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)
         {
           LOG_ERROR ("%s section not found\n", "Template")
         }
-      return error | DWG_ERR_SECTIONNOTFOUND;
+      return error;
     }
 
   LOG_TRACE ("Template\n-------------------\n")