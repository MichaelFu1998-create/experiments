diff --git a/src/p_lx_elf.cpp b/src/p_lx_elf.cpp
index 08b16e5a..ff2f0242 100644
--- a/src/p_lx_elf.cpp
+++ b/src/p_lx_elf.cpp
@@ -7157,6 +7157,12 @@ void PackLinuxElf64::unpack(OutputFile *fo)
         throwCantUnpack("bad e_phoff");
     }
     unsigned const c_phnum = get_te16(&ehdri.e_phnum);
+    // phdri points into the in-memory image created by PackLinuxElf64help1().
+    // Malformed inputs may have e_phnum == 0 or may have prevented phdri
+    // initialization. Avoid out-of-bounds reads below.
+    if (!phdri || c_phnum == 0) {
+        throwCantUnpack("bad e_phnum");
+    }
     unsigned u_phnum = 0;
     upx_uint64_t old_dtinit = 0;
 
@@ -7317,7 +7323,7 @@ void PackLinuxElf64::unpack(OutputFile *fo)
     unsigned d_info[6];
     unsigned sz_d_info = sizeof(d_info);
     if (!is_shlib) {
-        if (get_te32(&phdri[0].p_flags) & Elf64_Phdr::PF_X) {
+        if (c_phnum >= 1 && (get_te32(&phdri[0].p_flags) & Elf64_Phdr::PF_X)) {
             // Old style, such as upx-3.91 thru upx-3.95
             switch (this->e_machine) {
                 default: {
@@ -7330,10 +7336,14 @@ void PackLinuxElf64::unpack(OutputFile *fo)
                 case Elf64_Ehdr::EM_X86_64:  sz_d_info = 2 * sizeof(unsigned); break;
             }
         }
-        loader_offset = off_entry - sz_d_info;
+        // off_entry may be 0 for malformed inputs; avoid unsigned underflow.
+        // If we cannot compute a sensible loader_offset, fall back to 0 and let
+        // the normal loader-skipping logic below handle the file conservatively.
+        loader_offset = (off_entry >= sz_d_info) ? (off_entry - sz_d_info) : 0;
     }
 
-    if (0x1000==get_te64(&phdri[0].p_filesz)  // detect C_BASE style
+    if (c_phnum >= 2
+    &&  0x1000==get_te64(&phdri[0].p_filesz)  // detect C_BASE style
     &&  0==get_te64(&phdri[1].p_offset)
     &&  0==get_te64(&phdri[0].p_offset)
     &&     get_te64(&phdri[1].p_filesz) == get_te64(&phdri[1].p_memsz)) {
@@ -8322,6 +8332,12 @@ void PackLinuxElf32::unpack(OutputFile *fo)
         throwCantUnpack("bad e_phoff");
     }
     unsigned const c_phnum = get_te16(&ehdri.e_phnum);
+    // phdri points into the in-memory image created by PackLinuxElf64help1().
+    // Malformed inputs may have e_phnum == 0 or may have prevented phdri
+    // initialization. Avoid out-of-bounds reads below.
+    if (!phdri || c_phnum == 0) {
+        throwCantUnpack("bad e_phnum");
+    }
     unsigned u_phnum = 0;
     upx_uint32_t old_dtinit = 0;
 
diff --git a/src/util/util.cpp b/src/util/util.cpp
index d6208c80..0b939385 100644
--- a/src/util/util.cpp
+++ b/src/util/util.cpp
@@ -278,7 +278,7 @@ void upx_memswap(void *a, void *b, size_t n) {
 
 // much better memswap(), optimized for our use case in sort functions below
 static void memswap_no_overlap(byte *a, byte *b, size_t n) {
-#if defined(__clang__) && __clang_major__ < 15
+#if defined(__clang__)
     // work around a clang < 15 ICE (Internal Compiler Error)
     // @COMPILER_BUG @CLANG_BUG
     upx_memswap(a, b, n);