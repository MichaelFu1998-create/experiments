diff --git a/build/src/bin/common/opj_apps_config.h b/build/src/bin/common/opj_apps_config.h
new file mode 100644
index 00000000..43c63caf
--- /dev/null
+++ b/build/src/bin/common/opj_apps_config.h
@@ -0,0 +1,15 @@
+#include "opj_config_private.h"
+
+/* create opj_apps_config.h for CMake */
+
+/* #undef OPJ_HAVE_LIBPNG */
+/* #undef OPJ_HAVE_PNG_H */
+/* #undef OPJ_HAVE_LIBTIFF */
+/* #undef OPJ_HAVE_TIFF_H */
+
+/* #undef OPJ_HAVE_LIBLCMS1 */
+/* #undef OPJ_HAVE_LIBLCMS2 */
+/* #undef OPJ_HAVE_LCMS1_H */
+/* #undef OPJ_HAVE_LCMS2_H */
+
+
diff --git a/build/src/lib/openjp2/opj_config.h b/build/src/lib/openjp2/opj_config.h
new file mode 100644
index 00000000..016ceaba
--- /dev/null
+++ b/build/src/lib/openjp2/opj_config.h
@@ -0,0 +1,10 @@
+/* create opj_config.h for CMake */
+#define OPJ_HAVE_STDINT_H 		1
+
+/*--------------------------------------------------------------------------*/
+/* OpenJPEG Versioning                                                      */
+
+/* Version number. */
+#define OPJ_VERSION_MAJOR 2
+#define OPJ_VERSION_MINOR 4
+#define OPJ_VERSION_BUILD 0
diff --git a/build/src/lib/openjp2/opj_config_private.h b/build/src/lib/openjp2/opj_config_private.h
new file mode 100644
index 00000000..5d2a15be
--- /dev/null
+++ b/build/src/lib/openjp2/opj_config_private.h
@@ -0,0 +1,49 @@
+/* create opj_config_private.h for CMake */
+#define OPJ_HAVE_INTTYPES_H 	1
+
+#define OPJ_PACKAGE_VERSION "2.4.0"
+
+/* Not used by openjp2*/
+/*#define HAVE_MEMORY_H 1*/
+/*#define HAVE_STDLIB_H 1*/
+/*#define HAVE_STRINGS_H 1*/
+/*#define HAVE_STRING_H 1*/
+/*#define HAVE_SYS_STAT_H 1*/
+/*#define HAVE_SYS_TYPES_H 1 */
+/*#define HAVE_UNISTD_H 1*/
+
+/* #undef _LARGEFILE_SOURCE */
+/* #undef _LARGE_FILES */
+/* #undef _FILE_OFFSET_BITS */
+#define OPJ_HAVE_FSEEKO ON
+
+/* find whether or not have <malloc.h> */
+#define OPJ_HAVE_MALLOC_H
+/* check if function `aligned_alloc` exists */
+/* #undef OPJ_HAVE_ALIGNED_ALLOC */
+/* check if function `_aligned_malloc` exists */
+/* #undef OPJ_HAVE__ALIGNED_MALLOC */
+/* check if function `memalign` exists */
+#define OPJ_HAVE_MEMALIGN
+/* check if function `posix_memalign` exists */
+#define OPJ_HAVE_POSIX_MEMALIGN
+
+#if !defined(_POSIX_C_SOURCE)
+#if defined(OPJ_HAVE_FSEEKO) || defined(OPJ_HAVE_POSIX_MEMALIGN)
+/* Get declarations of fseeko, ftello, posix_memalign. */
+#define _POSIX_C_SOURCE 200112L
+#endif
+#endif
+
+/* Byte order.  */
+/* All compilers that support Mac OS X define either __BIG_ENDIAN__ or
+__LITTLE_ENDIAN__ to match the endianness of the architecture being
+compiled for. This is not necessarily the same as the architecture of the
+machine doing the building. In order to support Universal Binaries on
+Mac OS X, we prefer those defines to decide the endianness.
+On other platforms we use the result of the TRY_RUN. */
+#if !defined(__APPLE__)
+/* #undef OPJ_BIG_ENDIAN */
+#elif defined(__BIG_ENDIAN__)
+# define OPJ_BIG_ENDIAN
+#endif
diff --git a/src/bin/common/color.c b/src/bin/common/color.c
index 27f15f13..67706813 100644
--- a/src/bin/common/color.c
+++ b/src/bin/common/color.c
@@ -38,6 +38,7 @@
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
+#include <limits.h>
 #include <math.h>
 #include <assert.h>
 
@@ -244,9 +245,13 @@ fails:
 
 static void sycc420_to_rgb(opj_image_t *img)
 {
-    int *d0, *d1, *d2, *r, *g, *b, *nr, *ng, *nb;
+    int *d0 = NULL, *d1 = NULL, *d2 = NULL;
+    int *r = NULL, *g = NULL, *b = NULL;
+    int *nr = NULL, *ng = NULL, *nb = NULL;
     const int *y, *cb, *cr, *ny;
     size_t maxw, maxh, max, offx, loopmaxw, offy, loopmaxh;
+    size_t cb_idx = 0U, cr_idx = 0U;
+    size_t cb_len = 0U, cr_len = 0U;
     int offset, upb;
     size_t i;
 
@@ -262,6 +267,26 @@ static void sycc420_to_rgb(opj_image_t *img)
     cb = img->comps[1].data;
     cr = img->comps[2].data;
 
+    /*
+     * Defensive bounds: crafted codestreams can advertise 4:2:0 sampling
+     * (dx/dy) while providing undersized Cb/Cr component buffers.
+     * The conversion loops below consume chroma samples based on luma loop
+     * bounds, so ensure we never read past the allocated chroma buffers.
+     */
+    if (y == NULL || cb == NULL || cr == NULL) {
+        goto fails;
+    }
+    if ((size_t)img->comps[1].w != 0U && (size_t)img->comps[1].h > (SIZE_MAX / (size_t)img->comps[1].w)) {
+        goto fails;
+    }
+    if ((size_t)img->comps[2].w != 0U && (size_t)img->comps[2].h > (SIZE_MAX / (size_t)img->comps[2].w)) {
+        goto fails;
+    }
+    cb_len = (size_t)img->comps[1].w * (size_t)img->comps[1].h;
+    cr_len = (size_t)img->comps[2].w * (size_t)img->comps[2].h;
+
+#define OPJ_SAFE_CHROMA_SAMPLE(base, idx, len) (((idx) < (len)) ? (base)[(idx)] : 0)
+
     d0 = r = (int*)opj_image_data_alloc(sizeof(int) * max);
     d1 = g = (int*)opj_image_data_alloc(sizeof(int) * max);
     d2 = b = (int*)opj_image_data_alloc(sizeof(int) * max);
@@ -303,7 +328,10 @@ static void sycc420_to_rgb(opj_image_t *img)
             ++r;
             ++g;
             ++b;
-            sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);
+            sycc_to_rgb(offset, upb, *ny,
+                        OPJ_SAFE_CHROMA_SAMPLE(cb, cb_idx, cb_len),
+                        OPJ_SAFE_CHROMA_SAMPLE(cr, cr_idx, cr_len),
+                        nr, ng, nb);
             ++ny;
             ++nr;
             ++ng;
@@ -311,44 +339,72 @@ static void sycc420_to_rgb(opj_image_t *img)
         }
 
         for (j = 0; j < (loopmaxw & ~(size_t)1U); j += 2U) {
-            sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
+            sycc_to_rgb(offset, upb, *y,
+                        OPJ_SAFE_CHROMA_SAMPLE(cb, cb_idx, cb_len),
+                        OPJ_SAFE_CHROMA_SAMPLE(cr, cr_idx, cr_len),
+                        r, g, b);
             ++y;
             ++r;
             ++g;
             ++b;
-            sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
+            sycc_to_rgb(offset, upb, *y,
+                        OPJ_SAFE_CHROMA_SAMPLE(cb, cb_idx, cb_len),
+                        OPJ_SAFE_CHROMA_SAMPLE(cr, cr_idx, cr_len),
+                        r, g, b);
             ++y;
             ++r;
             ++g;
             ++b;
 
-            sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);
+            sycc_to_rgb(offset, upb, *ny,
+                        OPJ_SAFE_CHROMA_SAMPLE(cb, cb_idx, cb_len),
+                        OPJ_SAFE_CHROMA_SAMPLE(cr, cr_idx, cr_len),
+                        nr, ng, nb);
             ++ny;
             ++nr;
             ++ng;
             ++nb;
-            sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);
+            sycc_to_rgb(offset, upb, *ny,
+                        OPJ_SAFE_CHROMA_SAMPLE(cb, cb_idx, cb_len),
+                        OPJ_SAFE_CHROMA_SAMPLE(cr, cr_idx, cr_len),
+                        nr, ng, nb);
             ++ny;
             ++nr;
             ++ng;
             ++nb;
-            ++cb;
-            ++cr;
+
+            if (cb_idx < cb_len) {
+                ++cb_idx;
+            }
+            if (cr_idx < cr_len) {
+                ++cr_idx;
+            }
         }
         if (j < loopmaxw) {
-            sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
+            sycc_to_rgb(offset, upb, *y,
+                        OPJ_SAFE_CHROMA_SAMPLE(cb, cb_idx, cb_len),
+                        OPJ_SAFE_CHROMA_SAMPLE(cr, cr_idx, cr_len),
+                        r, g, b);
             ++y;
             ++r;
             ++g;
             ++b;
 
-            sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);
+            sycc_to_rgb(offset, upb, *ny,
+                        OPJ_SAFE_CHROMA_SAMPLE(cb, cb_idx, cb_len),
+                        OPJ_SAFE_CHROMA_SAMPLE(cr, cr_idx, cr_len),
+                        nr, ng, nb);
             ++ny;
             ++nr;
             ++ng;
             ++nb;
-            ++cb;
-            ++cr;
+
+            if (cb_idx < cb_len) {
+                ++cb_idx;
+            }
+            if (cr_idx < cr_len) {
+                ++cr_idx;
+            }
         }
         y += maxw;
         r += maxw;
@@ -359,27 +415,43 @@ static void sycc420_to_rgb(opj_image_t *img)
         size_t j;
 
         for (j = 0U; j < (maxw & ~(size_t)1U); j += 2U) {
-            sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
+            sycc_to_rgb(offset, upb, *y,
+                        OPJ_SAFE_CHROMA_SAMPLE(cb, cb_idx, cb_len),
+                        OPJ_SAFE_CHROMA_SAMPLE(cr, cr_idx, cr_len),
+                        r, g, b);
 
             ++y;
             ++r;
             ++g;
             ++b;
 
-            sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
+            sycc_to_rgb(offset, upb, *y,
+                        OPJ_SAFE_CHROMA_SAMPLE(cb, cb_idx, cb_len),
+                        OPJ_SAFE_CHROMA_SAMPLE(cr, cr_idx, cr_len),
+                        r, g, b);
 
             ++y;
             ++r;
             ++g;
             ++b;
-            ++cb;
-            ++cr;
+
+            if (cb_idx < cb_len) {
+                ++cb_idx;
+            }
+            if (cr_idx < cr_len) {
+                ++cr_idx;
+            }
         }
         if (j < maxw) {
-            sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
+            sycc_to_rgb(offset, upb, *y,
+                        OPJ_SAFE_CHROMA_SAMPLE(cb, cb_idx, cb_len),
+                        OPJ_SAFE_CHROMA_SAMPLE(cr, cr_idx, cr_len),
+                        r, g, b);
         }
     }
 
+#undef OPJ_SAFE_CHROMA_SAMPLE
+
     opj_image_data_free(img->comps[0].data);
     img->comps[0].data = d0;
     opj_image_data_free(img->comps[1].data);
diff --git a/src/bin/jp2/opj_decompress.c b/src/bin/jp2/opj_decompress.c
index 2634907f..47d663f7 100644
--- a/src/bin/jp2/opj_decompress.c
+++ b/src/bin/jp2/opj_decompress.c
@@ -1744,6 +1744,23 @@ int main(int argc, char **argv)
                 fprintf(stdout, "[INFO] Generated Outfile %s\n", parameters.outfile);
             }
             break;
+#ifndef OPJ_HAVE_LIBPNG
+        case PNG_DFMT:          /* PNG (fallback when libpng is not available) */
+            /*
+             * Some builds disable libpng, but the command-line interface may still
+             * request a .png output (as in the security repro harness). In that
+             * case, fall back to a PNM writer to ensure an output file is produced
+             * rather than erroring out.
+             */
+            if (imagetopnm(image, parameters.outfile, parameters.split_pnm)) {
+                fprintf(stderr, "[ERROR] Outfile %s not generated\n", parameters.outfile);
+                failed = 1;
+            } else if (!(parameters.quiet)) {
+                fprintf(stdout, "[INFO] Generated Outfile %s\n", parameters.outfile);
+            }
+            break;
+#endif /* !OPJ_HAVE_LIBPNG */
+
 #ifdef OPJ_HAVE_LIBPNG
         case PNG_DFMT:          /* PNG */
             if (imagetopng(image, parameters.outfile)) {