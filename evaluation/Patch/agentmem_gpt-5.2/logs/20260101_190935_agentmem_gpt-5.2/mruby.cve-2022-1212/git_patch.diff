diff --git a/src/string.c b/src/string.c
index 0273f74e3..63c7026a3 100644
--- a/src/string.c
+++ b/src/string.c
@@ -1210,15 +1210,38 @@ str_replace_partial(mrb_state *mrb, mrb_value src, mrb_int pos, mrb_int end, mrb
 static mrb_value
 str_escape(mrb_state *mrb, mrb_value str, mrb_bool inspect)
 {
+  /*
+   * GC safety/performance: this function used to call mrb_str_cat() for each
+   * character while iterating over a cached RSTRING_PTR(str). Those repeated
+   * allocations can trigger incremental GC, and `str` is not automatically
+   * rooted by C locals, leading to use-after-free.
+   *
+   * Fix: preallocate enough capacity for the worst-case escaped output so that
+   * mrb_str_cat() won't reallocate inside the loop (avoiding GC trigger
+   * points), and protect `str` during the initial allocation.
+   */
+  mrb_int len = RSTRING_LEN(str);
+  mrb_int capa;
+
+  if (mrb_int_mul_overflow(len, 4, &capa) ||
+      mrb_int_add_overflow(capa, 2, &capa)) {
+    mrb_raise(mrb, E_ARGUMENT_ERROR, "string size too big");
+  }
+
+  int ai = mrb_gc_arena_save(mrb);
+  mrb_gc_protect(mrb, str);
+
   const char *p, *pend;
-  char buf[4];  /* `\x??` or UTF-8 character */
-  mrb_value result = mrb_str_new_lit(mrb, "\"");
+  char buf[4];  /* `\\x??` or UTF-8 character */
+  mrb_value result = mrb_str_new_capa(mrb, capa);
 #ifdef MRB_UTF8_STRING
   uint32_t ascii_flag = MRB_STR_ASCII;
 #endif
 
+  mrb_str_cat_lit(mrb, result, "\"");
+
   p = RSTRING_PTR(str); pend = RSTRING_END(str);
-  for (;p < pend; p++) {
+  for (; p < pend; p++) {
     unsigned char c, cc;
 #ifdef MRB_UTF8_STRING
     if (inspect) {
@@ -1226,24 +1249,24 @@ str_escape(mrb_state *mrb, mrb_value str, mrb_bool inspect)
       if (clen > 1) {
         mrb_int i;
 
-        for (i=0; i<clen; i++) {
+        for (i = 0; i < clen; i++) {
           buf[i] = p[i];
         }
         mrb_str_cat(mrb, result, buf, clen);
-        p += clen-1;
+        p += clen - 1;
         ascii_flag = 0;
         continue;
       }
     }
 #endif
-    c = *p;
-    if (c == '"'|| c == '\\' || (c == '#' && IS_EVSTR(p+1, pend))) {
-      buf[0] = '\\'; buf[1] = c;
+    c = (unsigned char)*p;
+    if (c == '"' || c == '\\' || (c == '#' && IS_EVSTR(p+1, pend))) {
+      buf[0] = '\\'; buf[1] = (char)c;
       mrb_str_cat(mrb, result, buf, 2);
       continue;
     }
     if (ISPRINT(c)) {
-      buf[0] = c;
+      buf[0] = (char)c;
       mrb_str_cat(mrb, result, buf, 1);
       continue;
     }
@@ -1273,6 +1296,7 @@ str_escape(mrb_state *mrb, mrb_value str, mrb_bool inspect)
       continue;
     }
   }
+
   mrb_str_cat_lit(mrb, result, "\"");
 #ifdef MRB_UTF8_STRING
   if (inspect) {
@@ -1284,6 +1308,9 @@ str_escape(mrb_state *mrb, mrb_value str, mrb_bool inspect)
   }
 #endif
 
+  mrb_gc_arena_restore(mrb, ai);
+  /* keep return value alive after arena restore */
+  mrb_gc_protect(mrb, result);
   return result;
 }