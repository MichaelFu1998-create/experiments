diff --git a/src/isomedia/stbl_write.c b/src/isomedia/stbl_write.c
index 843a30857..91fba2871 100644
--- a/src/isomedia/stbl_write.c
+++ b/src/isomedia/stbl_write.c
@@ -25,6 +25,9 @@
 
 #include <gpac/internal/isomedia_dev.h>
 
+#include <limits.h>
+#include <stdint.h>
+
 #ifndef GPAC_DISABLE_ISOM
 
 /*macro used for table gf_realloc - we allocate much more than needed in order to keep the number of
@@ -1599,7 +1602,11 @@ GF_Err stbl_AppendTime(GF_SampleTableBox *stbl, u32 duration, u32 nb_pack)
 	if (!nb_pack) nb_pack = 1;
 	if (stts->nb_entries) {
 		if (stts->entries[stts->nb_entries-1].sampleDelta == duration) {
-			stts->entries[stts->nb_entries-1].sampleCount += nb_pack;
+						/* protect against u32 overflow on crafted inputs */
+			if (stts->entries[stts->nb_entries-1].sampleCount > UINT_MAX - nb_pack)
+				stts->entries[stts->nb_entries-1].sampleCount = UINT_MAX;
+			else
+				stts->entries[stts->nb_entries-1].sampleCount += nb_pack;
 			return GF_OK;
 		}
 	}
@@ -1619,25 +1626,68 @@ GF_Err stbl_AppendTime(GF_SampleTableBox *stbl, u32 duration, u32 nb_pack)
 GF_Err stbl_AppendSize(GF_SampleTableBox *stbl, u32 size, u32 nb_pack)
 {
 	u32 i;
+	u32 required;
+	u32 new_alloc;
+	u32 max_add;
+	/* hard cap to avoid memory-exhaustion attacks on sample size tables */
+	const u32 max_samples = 10000000;
+
 	if (!nb_pack) nb_pack = 1;
 
+	/* Clamp extremely large nb_pack/sampleCount to avoid u32 wrap and huge allocations.
+	   We prefer saturating/partial append over failing the whole import. */
+	if (stbl->SampleSize->sampleCount >= max_samples)
+		return GF_OK;
+	max_add = max_samples - stbl->SampleSize->sampleCount;
+	if (nb_pack > max_add)
+		nb_pack = max_add;
+	if (!nb_pack)
+		return GF_OK;
+
+	required = stbl->SampleSize->sampleCount + nb_pack;
+
+	/* defensive: internal state may become inconsistent on broken inputs (alloc_size smaller than sampleCount).
+	   Try to recover by growing the table to at least sampleCount/required. */
+	if (stbl->SampleSize->sizes && (stbl->SampleSize->sampleCount > stbl->SampleSize->alloc_size)) {
+		new_alloc = stbl->SampleSize->sampleCount;
+		if (required > new_alloc) new_alloc = required;
+		if ((size_t) new_alloc > (SIZE_MAX / sizeof(u32)))
+			return GF_OK;
+		stbl->SampleSize->sizes = (u32 *) gf_realloc(stbl->SampleSize->sizes, sizeof(u32) * new_alloc);
+		if (!stbl->SampleSize->sizes) return GF_OUT_OF_MEM;
+		memset(&stbl->SampleSize->sizes[stbl->SampleSize->alloc_size], 0, sizeof(u32) * (new_alloc - stbl->SampleSize->alloc_size));
+		stbl->SampleSize->alloc_size = new_alloc;
+	}
+
 	if (!stbl->SampleSize->sampleCount) {
 		stbl->SampleSize->sampleSize = size;
-		stbl->SampleSize->sampleCount += nb_pack;
+		stbl->SampleSize->sampleCount = required;
 		return GF_OK;
 	}
 	if (stbl->SampleSize->sampleSize && (stbl->SampleSize->sampleSize==size)) {
-		stbl->SampleSize->sampleCount += nb_pack;
+		stbl->SampleSize->sampleCount = required;
 		return GF_OK;
 	}
-	if (!stbl->SampleSize->sizes || (stbl->SampleSize->sampleCount+nb_pack > stbl->SampleSize->alloc_size)) {
+	if (!stbl->SampleSize->sizes || (required > stbl->SampleSize->alloc_size)) {
 		Bool init_table = (stbl->SampleSize->sizes==NULL) ? 1 : 0;
-		ALLOC_INC(stbl->SampleSize->alloc_size);
-		if (stbl->SampleSize->sampleCount+nb_pack > stbl->SampleSize->alloc_size)
-			stbl->SampleSize->alloc_size = stbl->SampleSize->sampleCount+nb_pack;
 
-		stbl->SampleSize->sizes = (u32 *)gf_realloc(stbl->SampleSize->sizes, sizeof(u32)*stbl->SampleSize->alloc_size);
+		/* compute new allocation size without risking corrupting alloc_size on failure */
+		new_alloc = stbl->SampleSize->alloc_size;
+		if (!new_alloc) {
+			new_alloc = required;
+		} else {
+			ALLOC_INC(new_alloc);
+			if (required > new_alloc)
+				new_alloc = required;
+		}
+		/* realloc byte-size overflow check */
+		if ((size_t) new_alloc > (SIZE_MAX / sizeof(u32)))
+			return GF_OK;
+
+		stbl->SampleSize->sizes = (u32 *)gf_realloc(stbl->SampleSize->sizes, sizeof(u32)*new_alloc);
 		if (!stbl->SampleSize->sizes) return GF_OUT_OF_MEM;
+		stbl->SampleSize->alloc_size = new_alloc;
+
 		memset(&stbl->SampleSize->sizes[stbl->SampleSize->sampleCount], 0, sizeof(u32) * (stbl->SampleSize->alloc_size - stbl->SampleSize->sampleCount) );
 
 		if (init_table) {
@@ -1649,10 +1699,10 @@ GF_Err stbl_AppendSize(GF_SampleTableBox *stbl, u32 size, u32 nb_pack)
 	for (i=0; i<nb_pack; i++) {
 		stbl->SampleSize->sizes[stbl->SampleSize->sampleCount+i] = size;
 	}
-	stbl->SampleSize->sampleCount += nb_pack;
+	stbl->SampleSize->sampleCount = required;
 	if (size > stbl->SampleSize->max_size)
 		stbl->SampleSize->max_size = size;
-	stbl->SampleSize->total_size += size;
+	stbl->SampleSize->total_size += ((u64) size) * (u64) nb_pack;
 	stbl->SampleSize->total_samples += nb_pack;
 	return GF_OK;
 }
diff --git a/src/media_tools/isom_hinter.c b/src/media_tools/isom_hinter.c
index a3a8205ca..c3ecb78ba 100644
--- a/src/media_tools/isom_hinter.c
+++ b/src/media_tools/isom_hinter.c
@@ -712,6 +712,7 @@ GF_Err gf_hinter_track_process(GF_RTPHinter *tkHint)
 	u8 PadBits;
 	GF_Fraction ft;
 	GF_ISOSample *samp;
+	Bool abort_track = GF_FALSE;
 
 	tkHint->HintSample = tkHint->RTPTime = 0;
 
@@ -722,7 +723,12 @@ GF_Err gf_hinter_track_process(GF_RTPHinter *tkHint)
 	e = GF_OK;
 	for (i=0; i<tkHint->TotalSample; i++) {
 		samp = gf_isom_get_sample(tkHint->file, tkHint->TrackNum, i+1, &descIndex);
-		if (!samp) return gf_isom_last_error(tkHint->file);
+		if (!samp) {
+			e = gf_isom_last_error(tkHint->file);
+			/* ensure we do not leave a half-built hint track in the file */
+			gf_isom_remove_track(tkHint->file, tkHint->HintTrack);
+			return e;
+		}
 
 		//setup SL
 		tkHint->CurrentSample = i + 1;
@@ -780,6 +786,7 @@ GF_Err gf_hinter_track_process(GF_RTPHinter *tkHint)
 				v = tkHint->avc_nalu_size;
 				if (v>remain) {
 					GF_LOG(GF_LOG_ERROR, GF_LOG_RTP, ("[rtp hinter] Broken AVC nalu encapsulation: NALU size length is %d but only %d bytes left in sample %d\n", v, remain, tkHint->CurrentSample));
+					abort_track = GF_TRUE;
 					break;
 				}
 				while (v) {
@@ -792,6 +799,7 @@ GF_Err gf_hinter_track_process(GF_RTPHinter *tkHint)
 				tkHint->base_offset_in_sample = samp->dataLength-remain;
 				if (remain < size) {
 					GF_LOG(GF_LOG_ERROR, GF_LOG_RTP, ("[rtp hinter] Broken AVC nalu encapsulation: NALU size is %d but only %d bytes left in sample %d\n", size, remain, tkHint->CurrentSample));
+					abort_track = GF_TRUE;
 					break;
 				}
 				remain -= size;
@@ -804,6 +812,16 @@ GF_Err gf_hinter_track_process(GF_RTPHinter *tkHint)
 				}
 				tkHint->rtp_p->sl_header.accessUnitStartFlag = 0;
 			}
+			if (abort_track) {
+				gf_isom_remove_track(tkHint->file, tkHint->HintTrack);
+				gf_isom_sample_del(&samp);
+				return GF_ISOM_INVALID_FILE;
+			}
+			if (e) {
+				/* ensure we do not leave a half-built hint track in the file */
+				gf_isom_remove_track(tkHint->file, tkHint->HintTrack);
+				return e;
+			}
 		} else {
 			e = gf_rtp_builder_process(tkHint->rtp_p, samp->data, samp->dataLength, 1, samp->dataLength, duration, (u8) (descIndex + GF_RTP_TX3G_SIDX_OFFSET) );
 		}
@@ -815,7 +833,11 @@ GF_Err gf_hinter_track_process(GF_RTPHinter *tkHint)
 		tkHint->rtp_p->sl_header.AU_sequenceNumber += 1;
 		gf_isom_sample_del(&samp);
 
-		if (e) return e;
+		if (e) {
+			/* ensure we do not leave a half-built hint track in the file */
+			gf_isom_remove_track(tkHint->file, tkHint->HintTrack);
+			return e;
+		}
 	}
 
 	//flush