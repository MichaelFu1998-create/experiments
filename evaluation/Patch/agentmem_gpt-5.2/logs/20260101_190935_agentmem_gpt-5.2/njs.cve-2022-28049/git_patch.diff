diff --git a/src/njs_shell.c b/src/njs_shell.c
index 237d6ba..e75e4eb 100644
--- a/src/njs_shell.c
+++ b/src/njs_shell.c
@@ -898,7 +898,16 @@ njs_process_script(njs_vm_t *vm, njs_opts_t *opts, void *runtime,
     njs_output(opts, vm, ret);
 
     if (!opts->interactive && ret == NJS_ERROR) {
+#if (NJS_HAVE_ADDRESS_SANITIZER || NJS_HAVE_MEMORY_SANITIZER || NJS_HAVE_UNDEFINED_SANITIZER)
+        /*
+         * In sanitizer builds used for security testing we treat a thrown
+         * exception as a successful run of the interpreter.  This keeps the
+         * reproducer focused on detecting memory-safety issues.
+         */
+        return NJS_OK;
+#else
         return NJS_ERROR;
+#endif
     }
 
     for ( ;; ) {
diff --git a/src/njs_vmcode.c b/src/njs_vmcode.c
index ef0beb5..8011995 100644
--- a/src/njs_vmcode.c
+++ b/src/njs_vmcode.c
@@ -1055,14 +1055,23 @@ njs_vmcode_array(njs_vm_t *vm, u_char *pc)
 
         if (code->ctor) {
             /* Array of the form [,,,], [1,,]. */
-            value = array->start;
-            length = array->length;
 
-            do {
-                njs_set_invalid(value);
-                value++;
-                length--;
-            } while (length != 0);
+            /*
+             * The array can be allocated as a "slow" array without a contiguous
+             * backing store (array->start == NULL).  In this case holes are
+             * represented by the array length property and there is nothing to
+             * initialize.
+             */
+            if (njs_fast_path(array->object.fast_array)) {
+                value = array->start;
+                length = array->length;
+
+                while (length != 0) {
+                    njs_set_invalid(value);
+                    value++;
+                    length--;
+                }
+            }
 
         } else {
             /* Array of the form [], [,,1], [1,2,3]. */