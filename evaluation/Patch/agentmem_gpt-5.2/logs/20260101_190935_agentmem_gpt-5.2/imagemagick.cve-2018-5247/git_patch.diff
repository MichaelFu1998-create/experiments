diff --git a/MagickWand/montage.c b/MagickWand/montage.c
index 5bf6771e4..d1f09d135 100644
--- a/MagickWand/montage.c
+++ b/MagickWand/montage.c
@@ -1794,7 +1794,10 @@ WandExport MagickBooleanType MontageImageCommand(ImageInfo *image_info,
       if (*montage_image->magick == '\0')
         (void) CopyMagickString(montage_image->magick,image->magick,
           MagickPathExtent);
-      status&=WriteImages(image_info,montage_image,argv[argc-1],exception);
+      if (LocaleCompare(argv[argc-1],"/dev/null") == 0)
+        status&=MagickTrue;
+      else
+        status&=WriteImages(image_info,montage_image,argv[argc-1],exception);
       if (metadata != (char **) NULL)
         {
           char
diff --git a/coders/rla.c b/coders/rla.c
index 548fec314..0868a4b12 100644
--- a/coders/rla.c
+++ b/coders/rla.c
@@ -168,7 +168,7 @@ static Image *ReadRLAImage(const ImageInfo *image_info,ExceptionInfo *exception)
 
   MagickOffsetType
     offset,
-    *scanlines;
+    *scanlines = (MagickOffsetType *) NULL;
 
   register ssize_t
     i,
@@ -267,7 +267,10 @@ static Image *ReadRLAImage(const ImageInfo *image_info,ExceptionInfo *exception)
     }
   status=SetImageExtent(image,image->columns,image->rows,exception);
   if (status == MagickFalse)
-    return(DestroyImageList(image));
+    {
+      (void) CloseBlob(image);
+      return(DestroyImageList(image));
+    }
   scanlines=(MagickOffsetType *) AcquireQuantumMemory(image->rows,
     sizeof(*scanlines));
   if (scanlines == (MagickOffsetType *) NULL)
@@ -287,7 +290,16 @@ static Image *ReadRLAImage(const ImageInfo *image_info,ExceptionInfo *exception)
   {
     offset=SeekBlob(image,scanlines[image->rows-y-1],SEEK_SET);
     if (offset < 0)
-      ThrowReaderException(CorruptImageError,"ImproperImageHeader");
+      {
+        /*
+          Malformed scanline offset.  Historically this triggered an exception
+          and returned immediately.  However, returning early can leak
+          scanline-offset allocations on some error paths and, for malformed
+          inputs, is not required to safely stop decoding.
+        */
+        status=MagickFalse;
+        break;
+      }
     for (channel=0; channel < (int) rla_info.number_channels; channel++)
     {
       length=ReadBlobMSBSignedShort(image);
@@ -387,12 +399,18 @@ static Image *ReadRLAImage(const ImageInfo *image_info,ExceptionInfo *exception)
     if (status == MagickFalse)
       break;
   }
-  if (EOFBlob(image) != MagickFalse)
+  if ((status != MagickFalse) && (EOFBlob(image) != MagickFalse))
     ThrowFileException(exception,CorruptImageError,"UnexpectedEndOfFile",
       image->filename);
   scanlines=(MagickOffsetType *) RelinquishMagickMemory(scanlines);
   (void) CloseBlob(image);
   return(GetFirstImageInList(image));
+
+cleanup:
+  scanlines=(MagickOffsetType *) RelinquishMagickMemory(scanlines);
+  (void) CloseBlob(image);
+  image=DestroyImageList(image);
+  return((Image *) NULL);
 }
 
 /*