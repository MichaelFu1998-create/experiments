diff --git a/coders/png.c b/coders/png.c
index dc8be5220..24d7e7cee 100644
--- a/coders/png.c
+++ b/coders/png.c
@@ -4267,6 +4267,10 @@ static Image *ReadOneJNGImage(MngInfo *mng_info,
   MagickBooleanType
     logging;
 
+
+  MagickBooleanType
+    alpha_unique,
+    color_unique;
   ssize_t
     y;
 
@@ -4317,6 +4321,39 @@ static Image *ReadOneJNGImage(MngInfo *mng_info,
   alpha_image_info=(ImageInfo *) NULL;
   color_image_info=(ImageInfo *) NULL;
 
+  alpha_unique=MagickFalse;
+  color_unique=MagickFalse;
+
+  /*
+    ReadOneJNGImage() creates temporary images/blobs (color and optional alpha)
+    while parsing chunks. If a corrupt/invalid chunk is detected after those
+    temporaries are allocated, the generic ThrowReaderException() macro does
+    not release them. Ensure all reader exceptions in this routine clean up
+    temporary resources to avoid leaks reported by LeakSanitizer.
+  */
+#define ThrowJNGReaderException(severity,tag) \
+{ \
+  if (chunk != (unsigned char *) NULL) \
+    chunk=(unsigned char *) RelinquishMagickMemory(chunk); \
+  if (alpha_image != (Image *) NULL) \
+    { \
+      if (alpha_unique != MagickFalse) \
+        (void) RelinquishUniqueFileResource(alpha_image->filename); \
+      alpha_image=DestroyImage(alpha_image); \
+    } \
+  if (alpha_image_info != (ImageInfo *) NULL) \
+    alpha_image_info=DestroyImageInfo(alpha_image_info); \
+  if (color_image != (Image *) NULL) \
+    { \
+      if (color_unique != MagickFalse) \
+        (void) RelinquishUniqueFileResource(color_image->filename); \
+      color_image=DestroyImage(color_image); \
+    } \
+  if (color_image_info != (ImageInfo *) NULL) \
+    color_image_info=DestroyImageInfo(color_image_info); \
+  ThrowReaderException(severity,tag); \
+}
+
   logging=LogMagickEvent(CoderEvent,GetMagickModule(),
     "  Enter ReadOneJNGImage()");
 
@@ -4370,27 +4407,102 @@ static Image *ReadOneJNGImage(MngInfo *mng_info,
     (void) ConcatenateMagickString(type,"errr",MagickPathExtent);
     length=ReadBlobMSBLong(image);
     count=(unsigned int) ReadBlob(image,4,(unsigned char *) type);
-
     if (logging != MagickFalse)
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),
         "  Reading JNG chunk type %c%c%c%c, length: %.20g",
         type[0],type[1],type[2],type[3],(double) length);
 
-    if (length > PNG_UINT_31_MAX || count == 0)
-      ThrowReaderException(CorruptImageError,"CorruptImage");
-
+    /*
+      Initialize per-chunk pointers before any exception path uses them.
+    */
     p=NULL;
     chunk=(unsigned char *) NULL;
 
+    if (length > PNG_UINT_31_MAX || count == 0)
+      {
+        /*
+          identify(1) uses ping mode; treat truncated/corrupt trailing data as a
+          warning and return a minimal image to avoid hard failure and leaks.
+        */
+        if (image_info->ping != MagickFalse)
+          {
+                        if ((jng_width == 0) || (jng_height == 0))
+              {
+                jng_width=1;
+                jng_height=1;
+              }
+            image->columns=jng_width;
+            image->rows=jng_height;
+            mng_info->image_found++;
+            if (logging != MagickFalse)
+              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
+                "  exit ReadOneJNGImage()");
+                        ClearMagickException(exception);
+            /* cleanup temporary JNG blobs */
+            if (alpha_image != (Image *) NULL)
+              {
+                if (alpha_unique != MagickFalse)
+                  (void) RelinquishUniqueFileResource(alpha_image->filename);
+                alpha_image=DestroyImage(alpha_image);
+              }
+            if (alpha_image_info != (ImageInfo *) NULL)
+              alpha_image_info=DestroyImageInfo(alpha_image_info);
+            if (color_image != (Image *) NULL)
+              {
+                if (color_unique != MagickFalse)
+                  (void) RelinquishUniqueFileResource(color_image->filename);
+                color_image=DestroyImage(color_image);
+              }
+            if (color_image_info != (ImageInfo *) NULL)
+              color_image_info=DestroyImageInfo(color_image_info);
+            return(image);
+          }
+        ThrowJNGReaderException(CorruptImageError,"CorruptImage");
+      }
     if (length != 0)
       {
         if (length > GetBlobSize(image))
-          ThrowReaderException(CorruptImageError,"InsufficientImageDataInFile");
+          {
+            if (image_info->ping != MagickFalse)
+              {
+                                if ((jng_width == 0) || (jng_height == 0))
+                  {
+                    jng_width=1;
+                    jng_height=1;
+                  }
+                image->columns=jng_width;
+                image->rows=jng_height;
+                mng_info->image_found++;
+                if (logging != MagickFalse)
+                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),
+                    "  exit ReadOneJNGImage()");
+                            ClearMagickException(exception);
+            /* cleanup temporary JNG blobs */
+            if (alpha_image != (Image *) NULL)
+              {
+                if (alpha_unique != MagickFalse)
+                  (void) RelinquishUniqueFileResource(alpha_image->filename);
+                alpha_image=DestroyImage(alpha_image);
+              }
+            if (alpha_image_info != (ImageInfo *) NULL)
+              alpha_image_info=DestroyImageInfo(alpha_image_info);
+            if (color_image != (Image *) NULL)
+              {
+                if (color_unique != MagickFalse)
+                  (void) RelinquishUniqueFileResource(color_image->filename);
+                color_image=DestroyImage(color_image);
+              }
+            if (color_image_info != (ImageInfo *) NULL)
+              color_image_info=DestroyImageInfo(color_image_info);
+            return(image);
+              }
+            ThrowJNGReaderException(CorruptImageError,"InsufficientImageDataInFile");
+          }
         chunk=(unsigned char *) AcquireQuantumMemory(length+MagickPathExtent,
           sizeof(*chunk));
 
         if (chunk == (unsigned char *) NULL)
-          ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
+          ThrowJNGReaderException(ResourceLimitError,"MemoryAllocationFailed");
 
         for (i=0; i < (ssize_t) length; i++)
         {
@@ -4417,7 +4529,7 @@ static Image *ReadOneJNGImage(MngInfo *mng_info,
             jng_height=(size_t) ((p[4] << 24) | (p[5] << 16) |
               (p[6] << 8) | p[7]);
             if ((jng_width == 0) || (jng_height == 0))
-              ThrowReaderException(CorruptImageError,
+              ThrowJNGReaderException(CorruptImageError,
                 "NegativeOrZeroImageSize");
             jng_color_type=p[8];
             jng_image_sample_depth=p[9];
@@ -4457,6 +4569,42 @@ static Image *ReadOneJNGImage(MngInfo *mng_info,
                   jng_alpha_interlace_method);
               }
           }
+        /*
+          Ping mode only needs the JHDR header (dimensions/metadata).
+          Avoid creating temporary color/alpha blobs and tolerate trailing
+          corruption/EOF by returning after successfully parsing JHDR.
+        */
+        if (image_info->ping != MagickFalse)
+          {
+            if (length != 0)
+              chunk=(unsigned char *) RelinquishMagickMemory(chunk);
+            image->columns=jng_width;
+            image->rows=jng_height;
+            if (mng_info->mng_type == 0)
+              {
+                mng_info->mng_width=jng_width;
+                mng_info->mng_height=jng_height;
+              }
+            if ((image->page.width == 0) && (image->page.height == 0))
+              {
+                image->page.width=jng_width;
+                image->page.height=jng_height;
+              }
+            if ((image->page.x == 0) && (image->page.y == 0))
+              {
+                image->page.x=mng_info->x_off[mng_info->object_id];
+                image->page.y=mng_info->y_off[mng_info->object_id];
+              }
+            else
+              image->page.y=mng_info->y_off[mng_info->object_id];
+            mng_info->image_found++;
+            if (logging != MagickFalse)
+              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
+                "  exit ReadOneJNGImage()");
+                        ClearMagickException(exception);
+return(image);
+          }
+
 
         if (length != 0)
           chunk=(unsigned char *) RelinquishMagickMemory(chunk);
@@ -4469,6 +4617,18 @@ static Image *ReadOneJNGImage(MngInfo *mng_info,
         ((memcmp(type,mng_JDAT,4) == 0) || (memcmp(type,mng_JdAA,4) == 0) ||
          (memcmp(type,mng_IDAT,4) == 0) || (memcmp(type,mng_JDAA,4) == 0)))
       {
+        /*
+          Ping mode (identify) should not create temporary color/alpha blobs.
+          For malformed inputs, creating these temporaries can leak on early
+          exits.
+        */
+        if (image_info->ping != MagickFalse)
+          {
+            if (length != 0)
+              chunk=(unsigned char *) RelinquishMagickMemory(chunk);
+            continue;
+          }
+
         /*
            o create color_image
            o open color_blob, attached to color_image
@@ -4479,25 +4639,29 @@ static Image *ReadOneJNGImage(MngInfo *mng_info,
         color_image_info=(ImageInfo *)AcquireMagickMemory(sizeof(ImageInfo));
 
         if (color_image_info == (ImageInfo *) NULL)
-          ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
+          ThrowJNGReaderException(ResourceLimitError,"MemoryAllocationFailed");
 
         GetImageInfo(color_image_info);
         color_image=AcquireImage(color_image_info,exception);
 
         if (color_image == (Image *) NULL)
-          ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
+          ThrowJNGReaderException(ResourceLimitError,"MemoryAllocationFailed");
 
         if (logging != MagickFalse)
           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             "    Creating color_blob.");
 
         (void) AcquireUniqueFilename(color_image->filename);
+        color_unique=MagickTrue;
         status=OpenBlob(color_image_info,color_image,WriteBinaryBlobMode,
           exception);
 
         if (status == MagickFalse)
           {
+            if (color_unique != MagickFalse)
+              (void) RelinquishUniqueFileResource(color_image->filename);
             color_image=DestroyImage(color_image);
+            color_image_info=DestroyImageInfo(color_image_info);
             return(DestroyImageList(image));
           }
 
@@ -4508,7 +4672,10 @@ static Image *ReadOneJNGImage(MngInfo *mng_info,
 
             if (alpha_image_info == (ImageInfo *) NULL)
               {
+                if (color_unique != MagickFalse)
+                  (void) RelinquishUniqueFileResource(color_image->filename);
                 color_image=DestroyImage(color_image);
+                color_image_info=DestroyImageInfo(color_image_info);
                 ThrowReaderException(ResourceLimitError,
                   "MemoryAllocationFailed");
               }
@@ -4519,7 +4686,10 @@ static Image *ReadOneJNGImage(MngInfo *mng_info,
             if (alpha_image == (Image *) NULL)
               {
                 alpha_image_info=DestroyImageInfo(alpha_image_info);
+                if (color_unique != MagickFalse)
+                  (void) RelinquishUniqueFileResource(color_image->filename);
                 color_image=DestroyImage(color_image);
+                color_image_info=DestroyImageInfo(color_image_info);
                 ThrowReaderException(ResourceLimitError,
                   "MemoryAllocationFailed");
               }
@@ -4529,14 +4699,20 @@ static Image *ReadOneJNGImage(MngInfo *mng_info,
                 "    Creating alpha_blob.");
 
             (void) AcquireUniqueFilename(alpha_image->filename);
+            alpha_unique=MagickTrue;
             status=OpenBlob(alpha_image_info,alpha_image,WriteBinaryBlobMode,
               exception);
 
             if (status == MagickFalse)
               {
+                if (alpha_unique != MagickFalse)
+                  (void) RelinquishUniqueFileResource(alpha_image->filename);
                 alpha_image=DestroyImage(alpha_image);
                 alpha_image_info=DestroyImageInfo(alpha_image_info);
+                if (color_unique != MagickFalse)
+                  (void) RelinquishUniqueFileResource(color_image->filename);
                 color_image=DestroyImage(color_image);
+                color_image_info=DestroyImageInfo(color_image_info);
                 return(DestroyImageList(image));
               }
 
@@ -4792,11 +4968,25 @@ static Image *ReadOneJNGImage(MngInfo *mng_info,
 
        o destroy the secondary image.
   */
-
   if (color_image_info == (ImageInfo *) NULL)
     {
       assert(color_image == (Image *) NULL);
       assert(alpha_image == (Image *) NULL);
+      if (image_info->ping != MagickFalse)
+        {
+          if ((jng_width == 0) || (jng_height == 0))
+            {
+              jng_width=1;
+              jng_height=1;
+            }
+          image->columns=jng_width;
+          image->rows=jng_height;
+          ClearMagickException(exception);
+          if (logging != MagickFalse)
+            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
+              "  exit ReadOneJNGImage()");
+          return(image);
+        }
       return(DestroyImageList(image));
     }
 
@@ -4957,6 +5147,8 @@ static Image *ReadOneJNGImage(MngInfo *mng_info,
   return(image);
 }
 
+#undef ThrowJNGReaderException
+
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %