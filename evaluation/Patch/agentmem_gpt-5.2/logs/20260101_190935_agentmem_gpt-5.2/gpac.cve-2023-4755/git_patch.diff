diff --git a/src/filters/mux_isom.c b/src/filters/mux_isom.c
index 4044ef11f..0601b6a8e 100644
--- a/src/filters/mux_isom.c
+++ b/src/filters/mux_isom.c
@@ -687,6 +687,23 @@ static void mp4mux_reorder_tracks(GF_MP4MuxCtx *ctx)
 	ctx->tracks = new_tracks;
 }
 
+static TrackWriter *mp4_mux_get_ref_track(GF_MP4MuxCtx *ctx)
+{
+	u32 i, count;
+	if (!ctx || !ctx->tracks) return NULL;
+	count = gf_list_count(ctx->tracks);
+	for (i=0; i<count; i++) {
+		TrackWriter *tkw = gf_list_get(ctx->tracks, i);
+		if (!tkw) continue;
+		if (tkw->fake_track) continue;
+		/* Make sure track_id is available when possible */
+		if (!tkw->track_id && ctx->file && tkw->track_num)
+			tkw->track_id = gf_isom_get_track_id(ctx->file, tkw->track_num);
+		if (tkw->track_id) return tkw;
+	}
+	return gf_list_get(ctx->tracks, 0);
+}
+
 static void mp4mx_set_track_group(GF_MP4MuxCtx *ctx, TrackWriter *tkw, char *name, const GF_PropertyValue *p)
 {
 	s32 grp_id=0;
@@ -3990,11 +4007,22 @@ static GF_Err mp4_mux_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool i
 	if (is_remove) {
 		TrackWriter *tkw = gf_filter_pid_get_udta(pid);
 		if (tkw) {
+			/* TrackWriter lifetime: ctx->ref_tkw may cache a pointer to a TrackWriter in
+			 * ctx->tracks. When a PID is disconnected, the TrackWriter is removed and
+			 * freed. Ensure we don't keep a dangling pointer to freed memory.
+			 */
+			if (ctx->ref_tkw == tkw) ctx->ref_tkw = NULL;
 			gf_list_del_item(ctx->tracks, tkw);
 			gf_free(tkw);
+			/* If we just removed the reference track but still have tracks, pick a new
+			 * valid one to avoid use-after-free during fragmented processing.
+			 */
+			if (!ctx->ref_tkw && gf_list_count(ctx->tracks))
+				ctx->ref_tkw = mp4_mux_get_ref_track(ctx);
 		}
 		//removing last pid
 		if (ctx->opid && !gf_list_count(ctx->tracks)) {
+			ctx->ref_tkw = NULL;
 			if (ctx->file) {
 				//non-frag file, flush file
 				if (!ctx->init_movie_done) {
@@ -5824,7 +5852,17 @@ static GF_Err mp4_mux_initialize_movie(GF_MP4MuxCtx *ctx)
 
 		//use 1 for the default sample description index. If no multi stsd, this is always the case
 		//otherwise we need to update the stsd idx in the traf headers
-		e = gf_isom_setup_track_fragment(ctx->file, tkw->track_id, tkw->stsd_idx, def_pck_dur, def_samp_size, def_is_rap, 0, 0, ctx->nofragdef ? GF_TRUE : GF_FALSE);
+					/* Track may not be fully configured (eg, PID disconnected during init).
+			 * Do not abort the whole session on a missing track_id; skip it instead.
+			 */
+			if (!tkw->track_id && ctx->file && tkw->track_num)
+				tkw->track_id = gf_isom_get_track_id(ctx->file, tkw->track_num);
+			if (!tkw->track_id) {
+				GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, ("[MP4Mux] Missing track ID for PID %s, skipping fragmentation setup\n", gf_filter_pid_get_name(tkw->ipid) ));
+				continue;
+			}
+
+e = gf_isom_setup_track_fragment(ctx->file, tkw->track_id, tkw->stsd_idx, def_pck_dur, def_samp_size, def_is_rap, 0, 0, ctx->nofragdef ? GF_TRUE : GF_FALSE);
 		if (e) {
 			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[MP4Mux] Unable to setup fragmentation for track ID %d: %s\n", tkw->track_id, gf_error_to_string(e) ));
 			return e;
@@ -5900,7 +5938,7 @@ static GF_Err mp4_mux_initialize_movie(GF_MP4MuxCtx *ctx)
 		gf_list_del_item(ctx->tracks, ref_tkw);
 		gf_list_insert(ctx->tracks, ref_tkw, 0);
 	}
-	ctx->ref_tkw = gf_list_get(ctx->tracks, 0);
+	ctx->ref_tkw = mp4_mux_get_ref_track(ctx);
 
 	if (!ctx->abs_offset) {
 		u32 mval = ctx->dash_mode ? '6' : '5';
@@ -6629,6 +6667,13 @@ static GF_Err mp4_mux_process_fragmented(GF_MP4MuxCtx *ctx)
 		Bool is_eos = (count == nb_eos) ? GF_TRUE : GF_FALSE;
 		u32 ref_timescale;
 		Bool flush_refs = ctx->dash_mode ? GF_FALSE : GF_TRUE;
+		/* The reference TrackWriter can be removed when its PID is disconnected.
+		 * Ensure we always have a valid reference track before dereferencing it.
+		 */
+		if (!ctx->ref_tkw && count)
+			ctx->ref_tkw = mp4_mux_get_ref_track(ctx);
+		if (!ctx->ref_tkw)
+			goto check_eos;
 		u64 next_ref_ts = ctx->ref_tkw->next_seg_cts;
 		if (is_eos)
 			next_ref_ts = ctx->ref_tkw->cts_next;