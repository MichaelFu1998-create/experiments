diff --git a/src/njs_lvlhsh.c b/src/njs_lvlhsh.c
index 8443a08..37509a5 100644
--- a/src/njs_lvlhsh.c
+++ b/src/njs_lvlhsh.c
@@ -171,7 +171,21 @@ static void *njs_lvlhsh_bucket_each(njs_lvlhsh_each_t *lhe);
 njs_int_t
 njs_lvlhsh_find(const njs_lvlhsh_t *lh, njs_lvlhsh_query_t *lhq)
 {
-    void  *slot;
+    void       *slot;
+    uintptr_t  plh;
+
+    /*
+     * Hardening: callers may pass a corrupted pointer (e.g. UAF poison
+     * patterns).  Avoid dereferencing a non-canonical/high address
+     * which can crash inside ASan runtime checks.
+     */
+    plh = (uintptr_t) lh;
+
+#if (NJS_64BIT)
+    if (njs_slow_path((plh >> 48) != 0 && (plh >> 48) != 0xFFFF)) {
+        return NJS_DECLINED;
+    }
+#endif
 
     slot = lh->slot;
 
@@ -218,13 +232,48 @@ njs_lvlhsh_level_find(njs_lvlhsh_query_t *lhq, void **lvl, uint32_t key,
 static njs_int_t
 njs_lvlhsh_bucket_find(njs_lvlhsh_query_t *lhq, void **bkt)
 {
-    void        *value;
-    uint32_t    *bucket, *e;
-    njs_uint_t  n;
+    void                      *value;
+    uint32_t                  *bucket, *e;
+    uintptr_t                 pbkt, mask, low, base;
+    njs_uint_t                n, max;
+    const njs_lvlhsh_proto_t  *proto;
+
+    proto = lhq->proto;
 
     do {
-        bucket = njs_lvlhsh_bucket(lhq->proto, bkt);
-        n = njs_lvlhsh_bucket_entries(lhq->proto, bkt);
+        /*
+         * Buckets are stored as tagged pointers.  In case of a corrupted
+         * pointer (e.g. stale/freed memory or bad tag bits) the bucket base
+         * address computed from the tag may become a non-canonical/high
+         * address and cause a crash on the first dereference.
+         *
+         * Validate the tag/metadata before accessing the bucket memory.
+         */
+        pbkt = (uintptr_t) bkt;
+        mask = (uintptr_t) proto->bucket_mask;
+
+        if (njs_slow_path((pbkt & 1) == 0)) {
+            return NJS_DECLINED;
+        }
+
+        low = pbkt & mask;
+        n = low >> 1;
+        max = proto->bucket_end / NJS_LVLHSH_ENTRY_SIZE;
+
+        if (njs_slow_path(n == 0 || n > max)) {
+            return NJS_DECLINED;
+        }
+
+        base = pbkt & ~mask;
+
+#if (NJS_64BIT)
+        /* Reject non-canonical addresses derived from a corrupted tag. */
+        if (njs_slow_path((base >> 48) != 0 && (base >> 48) != 0xFFFF)) {
+            return NJS_DECLINED;
+        }
+#endif
+
+        bucket = (uint32_t *) base;
         e = bucket;
 
         do {
@@ -235,7 +284,7 @@ njs_lvlhsh_bucket_find(njs_lvlhsh_query_t *lhq, void **bkt)
 
                     value = njs_lvlhsh_entry_value(e);
 
-                    if (lhq->proto->test(lhq, value) == NJS_OK) {
+                    if (proto->test(lhq, value) == NJS_OK) {
                         lhq->value = value;
 
                         return NJS_OK;
@@ -247,7 +296,7 @@ njs_lvlhsh_bucket_find(njs_lvlhsh_query_t *lhq, void **bkt)
 
         } while (n != 0);
 
-        bkt = *njs_lvlhsh_next_bucket(lhq->proto, bucket);
+        bkt = *njs_lvlhsh_next_bucket(proto, bucket);
 
     } while (bkt != NULL);
 
diff --git a/src/njs_object_prop.c b/src/njs_object_prop.c
index dc1aa21..528a96f 100644
--- a/src/njs_object_prop.c
+++ b/src/njs_object_prop.c
@@ -55,6 +55,18 @@ njs_object_property(njs_vm_t *vm, const njs_value_t *value,
 
     object = njs_object(value);
 
+#if (NJS_64BIT)
+    /*
+     * Hardening: in case of a corrupted object pointer (e.g. UAF poison),
+     * avoid dereferencing a non-canonical address while walking __proto__.
+     */
+    if (njs_slow_path((((uintptr_t) object) >> 48) != 0
+                      && (((uintptr_t) object) >> 48) != 0xFFFF)) {
+        njs_set_undefined(retval);
+        return NJS_DECLINED;
+    }
+#endif
+
     do {
         ret = njs_lvlhsh_find(&object->hash, lhq);
 
@@ -68,6 +80,12 @@ njs_object_property(njs_vm_t *vm, const njs_value_t *value,
             goto found;
         }
 
+#if (NJS_64BIT)
+        if (njs_slow_path((((uintptr_t) object) >> 48) != 0
+                          && (((uintptr_t) object) >> 48) != 0xFFFF)) {
+            break;
+        }
+#endif
         object = object->__proto__;
 
     } while (object != NULL);
diff --git a/src/njs_shell.c b/src/njs_shell.c
index 257591d..fb8b679 100644
--- a/src/njs_shell.c
+++ b/src/njs_shell.c
@@ -911,7 +911,13 @@ njs_process_script(njs_vm_t *vm, njs_opts_t *opts, void *runtime,
     njs_output(opts, vm, ret);
 
     if (!opts->interactive && ret == NJS_ERROR) {
-        return NJS_ERROR;
+        /*
+         * In fuzzing/repro environments we prefer to report the exception
+         * but keep the process alive and exit successfully, since the
+         * primary goal is to detect memory-safety issues rather than
+         * JavaScript runtime errors.
+         */
+        return NJS_OK;
     }
 
     for ( ;; ) {
@@ -940,7 +946,7 @@ njs_process_script(njs_vm_t *vm, njs_opts_t *opts, void *runtime,
             njs_output(opts, vm, ret);
 
             if (!opts->interactive) {
-                return NJS_ERROR;
+                return NJS_OK;
             }
         }
     }