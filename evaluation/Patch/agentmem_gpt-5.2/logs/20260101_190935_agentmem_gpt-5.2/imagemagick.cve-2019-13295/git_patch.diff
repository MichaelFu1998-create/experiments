diff --git a/MagickCore/threshold.c b/MagickCore/threshold.c
index a3bb96a21..6b0090f10 100644
--- a/MagickCore/threshold.c
+++ b/MagickCore/threshold.c
@@ -181,6 +181,10 @@ MagickExport Image *AdaptiveThresholdImage(const Image *image,
 {
 #define AdaptiveThresholdImageTag  "AdaptiveThreshold/Image"
 
+  size_t
+    neighborhood_width,
+    neighborhood_height;
+
   CacheView
     *image_view,
     *threshold_view;
@@ -209,6 +213,16 @@ MagickExport Image *AdaptiveThresholdImage(const Image *image,
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",image->filename);
   assert(exception != (ExceptionInfo *) NULL);
   assert(exception->signature == MagickCoreSignature);
+
+  /*
+    Harden against invalid neighborhood geometry.
+
+    The algorithm below assumes width/height are at least 1 and uses
+    expressions like (width-1) in pointer arithmetic.  A width (or height)
+    of zero can underflow and trigger out-of-bounds reads.
+  */
+  neighborhood_width=(width == 0 ? 1UL : width);
+  neighborhood_height=(height == 0 ? 1UL : height);
   threshold_image=CloneImage(image,0,0,MagickTrue,exception);
   if (threshold_image == (Image *) NULL)
     return((Image *) NULL);
@@ -223,7 +237,7 @@ MagickExport Image *AdaptiveThresholdImage(const Image *image,
   */
   status=MagickTrue;
   progress=0;
-  number_pixels=(MagickSizeType) width*height;
+  number_pixels=(MagickSizeType) neighborhood_width*neighborhood_height;
   image_view=AcquireVirtualCacheView(image,exception);
   threshold_view=AcquireAuthenticCacheView(threshold_image,exception);
 #if defined(MAGICKCORE_OPENMP_SUPPORT)
@@ -254,8 +268,9 @@ MagickExport Image *AdaptiveThresholdImage(const Image *image,
 
     if (status == MagickFalse)
       continue;
-    p=GetCacheViewVirtualPixels(image_view,-((ssize_t) width/2L),y-(ssize_t)
-      (height/2L),image->columns+width,height,exception);
+    p=GetCacheViewVirtualPixels(image_view,-((ssize_t) neighborhood_width/2L),
+      y-(ssize_t) (neighborhood_height/2L),image->columns+neighborhood_width,
+      neighborhood_height,exception);
     q=QueueCacheViewAuthenticPixels(threshold_view,0,y,threshold_image->columns,
       1,exception);
     if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))
@@ -263,8 +278,8 @@ MagickExport Image *AdaptiveThresholdImage(const Image *image,
         status=MagickFalse;
         continue;
       }
-    center=(ssize_t) GetPixelChannels(image)*(image->columns+width)*(height/2L)+
-      GetPixelChannels(image)*(width/2);
+    center=(ssize_t) GetPixelChannels(image)*(image->columns+neighborhood_width)*
+      (neighborhood_height/2L)+GetPixelChannels(image)*(neighborhood_width/2);
     for (i=0; i < (ssize_t) GetPixelChannels(image); i++)
     {
       PixelChannel channel = GetPixelChannelChannel(image,i);
@@ -282,11 +297,11 @@ MagickExport Image *AdaptiveThresholdImage(const Image *image,
       pixels=p;
       channel_bias[channel]=0.0;
       channel_sum[channel]=0.0;
-      for (v=0; v < (ssize_t) height; v++)
+      for (v=0; v < (ssize_t) neighborhood_height; v++)
       {
-        for (u=0; u < (ssize_t) width; u++)
+        for (u=0; u < (ssize_t) neighborhood_width; u++)
         {
-          if (u == (ssize_t) (width-1))
+          if (u == (ssize_t) (neighborhood_width-1))
             channel_bias[channel]+=pixels[i];
           channel_sum[channel]+=pixels[i];
           pixels+=GetPixelChannels(image);
@@ -319,7 +334,7 @@ MagickExport Image *AdaptiveThresholdImage(const Image *image,
         for (v=0; v < (ssize_t) height; v++)
         {
           channel_bias[channel]+=pixels[i];
-          pixels+=(width-1)*GetPixelChannels(image);
+          pixels+=(neighborhood_width-1)*GetPixelChannels(image);
           channel_sum[channel]+=pixels[i];
           pixels+=GetPixelChannels(image)*(image->columns+1);
         }