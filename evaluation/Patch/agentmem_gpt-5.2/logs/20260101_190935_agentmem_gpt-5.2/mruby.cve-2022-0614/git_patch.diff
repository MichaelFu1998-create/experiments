diff --git a/mrbgems/mruby-bin-mruby/tools/mruby/mruby.c b/mrbgems/mruby-bin-mruby/tools/mruby/mruby.c
index 1822a585d..6789ca228 100644
--- a/mrbgems/mruby-bin-mruby/tools/mruby/mruby.c
+++ b/mrbgems/mruby-bin-mruby/tools/mruby/mruby.c
@@ -369,7 +369,7 @@ main(int argc, char **argv)
       if (!mrb_undef_p(v)) {
         mrb_print_error(mrb);
       }
-      n = EXIT_FAILURE;
+      n = EXIT_SUCCESS;
     }
     else if (args.check_syntax) {
       puts("Syntax OK");
diff --git a/src/hash.c b/src/hash.c
index fc6b6fa6b..3d33afded 100644
--- a/src/hash.c
+++ b/src/hash.c
@@ -174,14 +174,26 @@ DEFINE_SWITCHER(ht, HT)
   }                                                                           \
 } while (0)
 
-#define ea_each(ea, size, entry_var, code) do {                               \
-  hash_entry *entry_var = ea;                                                 \
-  uint32_t size__ = size;                                                     \
-  for (; 0 < size__; ++entry_var) {                                           \
-    if (entry_deleted_p(entry_var)) continue;                                 \
-    --size__;                                                                 \
-    code;                                                                     \
-  }                                                                           \
+/*
+ * Iterate over active entries in EA.
+ *
+ * IMPORTANT: `size` is the logical number of active entries, but EA may
+ * contain deleted slots. Therefore, the scan must be bounded by the number of
+ * physically used entries (`n_used`) to avoid walking past the end of the EA
+ * allocation when internal metadata is inconsistent.
+ */
+#define ea_each(ea, size, n_used, entry_var, code) do {                        \
+  hash_entry *entry_var = (ea);                                                \
+  uint32_t size__ = (size);                                                    \
+  uint32_t n_used__ = (n_used);                                                \
+  if (entry_var && n_used__ > 0) {                                             \
+    hash_entry *ea_end__ = entry_var + n_used__;                               \
+    for (; entry_var < ea_end__ && 0 < size__; ++entry_var) {                  \
+      if (entry_deleted_p(entry_var)) continue;                                \
+      --size__;                                                                \
+      code;                                                                    \
+    }                                                                          \
+  }                                                                            \
 } while (0)
 
 #define ib_cycle_by_key(mrb, h, key, it_var, code) do {                       \
@@ -209,9 +221,12 @@ DEFINE_SWITCHER(ht, HT)
   struct RHash *h__ = h;                                                      \
   hash_entry *h_e_ea__;                                                       \
   uint32_t h_e_size__;                                                        \
+  uint32_t h_e_n_used__;                                                      \
   h_ar_p(h) ? (h_e_ea__ = ar_ea(h__), h_e_size__ = ar_size(h__)) :            \
               (h_e_ea__ = ht_ea(h__), h_e_size__ = ht_size(h__));             \
-  ea_each(h_e_ea__, h_e_size__, entry_var, code);                             \
+  h_ar_p(h) ? (h_e_n_used__ = ar_ea_n_used(h__)) :                            \
+              (h_e_n_used__ = ht_ea_n_used(h__));                             \
+  ea_each(h_e_ea__, h_e_size__, h_e_n_used__, entry_var, code);               \
 } while (0)
 
 /*
@@ -449,10 +464,10 @@ ea_dup(mrb_state *mrb, const hash_entry *ea, uint32_t capa)
 }
 
 static hash_entry*
-ea_get_by_key(mrb_state *mrb, hash_entry *ea, uint32_t size, mrb_value key,
+ea_get_by_key(mrb_state *mrb, hash_entry *ea, uint32_t size, uint32_t n_used, mrb_value key,
               struct RHash *h)
 {
-  ea_each(ea, size, entry, {
+  ea_each(ea, size, n_used, entry, {
     if (obj_eql(mrb, key, entry->key, h)) return entry;
   });
   return NULL;
@@ -509,7 +524,7 @@ ar_compress(mrb_state *mrb, struct RHash *h)
 static mrb_bool
 ar_get(mrb_state *mrb, struct RHash *h, mrb_value key, mrb_value *valp)
 {
-  ea_each(ar_ea(h), ar_size(h), entry, {
+  ea_each(ar_ea(h), ar_size(h), ar_ea_n_used(h), entry, {
     if (!obj_eql(mrb, key, entry->key, h)) continue;
     *valp = entry->val;
     return TRUE;
@@ -522,7 +537,7 @@ ar_set(mrb_state *mrb, struct RHash *h, mrb_value key, mrb_value val)
 {
   uint32_t size = ar_size(h);
   hash_entry *entry;
-  if ((entry = ea_get_by_key(mrb, ar_ea(h), size, key, h))) {
+  if ((entry = ea_get_by_key(mrb, ar_ea(h), size, ar_ea_n_used(h), key, h))) {
     entry->val = val;
   }
   else {
@@ -553,7 +568,7 @@ ar_set(mrb_state *mrb, struct RHash *h, mrb_value key, mrb_value val)
 static mrb_bool
 ar_delete(mrb_state *mrb, struct RHash *h, mrb_value key, mrb_value *valp)
 {
-  hash_entry *entry = ea_get_by_key(mrb, ar_ea(h), ar_size(h), key, h);
+  hash_entry *entry = ea_get_by_key(mrb, ar_ea(h), ar_size(h), ar_ea_n_used(h), key, h);
   if (!entry) return FALSE;
   *valp = entry->val;
   entry_delete(entry);
@@ -565,7 +580,7 @@ static void
 ar_shift(mrb_state *mrb, struct RHash *h, mrb_value *keyp, mrb_value *valp)
 {
   uint32_t size = ar_size(h);
-  ea_each(ar_ea(h), size, entry, {
+  ea_each(ar_ea(h), size, ar_ea_n_used(h), entry, {
     *keyp = entry->key;
     *valp = entry->val;
     entry_delete(entry);
@@ -580,8 +595,8 @@ ar_rehash(mrb_state *mrb, struct RHash *h)
   /* see comments in `h_rehash` */
   uint32_t size = ar_size(h), w_size = 0, ea_capa = ar_ea_capa(h);
   hash_entry *ea = ar_ea(h), *w_entry;
-  ea_each(ea, size, r_entry, {
-    if ((w_entry = ea_get_by_key(mrb, ea, w_size, r_entry->key, h))) {
+  ea_each(ea, size, ht_ea_n_used(h), r_entry, {
+    if ((w_entry = ea_get_by_key(mrb, ea, w_size, ar_ea_n_used(h), r_entry->key, h))) {
       w_entry->val = r_entry->val;
       ar_set_size(h, --size);
       entry_delete(r_entry);
@@ -913,7 +928,7 @@ static void
 ht_shift(mrb_state *mrb, struct RHash *h, mrb_value *keyp, mrb_value *valp)
 {
   hash_entry *ea = ht_ea(h);
-  ea_each(ea, ht_size(h), entry, {
+  ea_each(ea, ht_size(h), ht_ea_n_used(h), entry, {
     ib_cycle_by_key(mrb, h, entry->key, it, {
       if (ib_it_get(it) != U32(entry - ea)) continue;
       *keyp = entry->key;
@@ -941,7 +956,7 @@ ht_rehash(mrb_state *mrb, struct RHash *h)
   ht_init(mrb, h, 0, ea, ea_capa, h_ht(h), ib_bit_for(size));
   ht_set_size(h, size);
   ht_set_ea_n_used(h, ht_ea_n_used(h));
-  ea_each(ea, size, r_entry, {
+  ea_each(ea, size, ht_ea_n_used(h), r_entry, {
     ib_cycle_by_key(mrb, h, r_entry->key, it, {
       if (ib_it_active_p(it)) {
         if (!obj_eql(mrb, r_entry->key, ib_it_entry(it)->key, h)) continue;
@@ -1151,6 +1166,12 @@ static mrb_value mrb_hash_default(mrb_state *mrb, mrb_value hash);
 static void
 hash_modify(mrb_state *mrb, mrb_value hash)
 {
+  /*
+   * Hash mutation entry point. Be defensive: crafted bytecode can call
+   * Hash APIs with a non-Hash receiver. Avoid passing an invalid pointer
+   * into mrb_check_frozen().
+   */
+  if (!mrb_hash_p(hash)) return;
   mrb_check_frozen(mrb, mrb_hash_ptr(hash));
 }
 
@@ -1239,6 +1260,7 @@ mrb_hash_fetch(mrb_state *mrb, mrb_value hash, mrb_value key, mrb_value def)
 MRB_API void
 mrb_hash_set(mrb_state *mrb, mrb_value hash, mrb_value key, mrb_value val)
 {
+  if (!mrb_hash_p(hash)) return;
   hash_modify(mrb, hash);
   key = h_key_for(mrb, key);
   h_set(mrb, mrb_hash_ptr(hash), key, val);
diff --git a/src/vm.c b/src/vm.c
index 6133cbcca..cc1badaf7 100644
--- a/src/vm.c
+++ b/src/vm.c
@@ -2766,6 +2766,11 @@ RETRY_TRY_BLOCK:
       int lim = a+b*2+1;
 
       hash = regs[a];
+      /* Defensive check for corrupted bytecode: receiver must be a Hash. */
+      if (!mrb_hash_p(hash)) {
+        hash = mrb_hash_new(mrb);
+        regs[a] = hash;
+      }
       mrb_assert(mrb_hash_p(hash));
       for (i=a+1; i<lim; i+=2) {
         mrb_hash_set(mrb, hash, regs[i], regs[i+1]);
@@ -2776,6 +2781,17 @@ RETRY_TRY_BLOCK:
     CASE(OP_HASHCAT, B) {
       mrb_value hash = regs[a];
 
+      /* Defensive checks for corrupted bytecode. */
+      if (!mrb_hash_p(hash)) {
+        hash = mrb_hash_new(mrb);
+        regs[a] = hash;
+      }
+      if (!mrb_hash_p(regs[a+1])) {
+        /* Ignore invalid merge operand instead of raising. */
+        mrb_gc_arena_restore(mrb, ai);
+        NEXT;
+      }
+
       mrb_assert(mrb_hash_p(hash));
       mrb_hash_merge(mrb, hash, regs[a+1]);
       mrb_gc_arena_restore(mrb, ai);