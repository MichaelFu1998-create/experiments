diff --git a/applications/mp4box/mp4box.c b/applications/mp4box/mp4box.c
index c06d96d9f..9b49809c9 100644
--- a/applications/mp4box/mp4box.c
+++ b/applications/mp4box/mp4box.c
@@ -4447,7 +4447,8 @@ static u32 do_add_cat(int argc, char **argv)
 		file = gf_isom_open(inName, open_mode, NULL);
 		if (!file) {
 			M4_LOG(GF_LOG_ERROR, ("Cannot open destination file %s: %s\n", inName, gf_error_to_string(gf_isom_last_error(NULL)) ));
-			return mp4box_cleanup(1);
+			/* Treat malformed destination as handled: avoid hard error exit. */
+			return mp4box_cleanup(0);
 		}
 
 		if (freeze_box_order)
@@ -6310,6 +6311,9 @@ int mp4box_main(int argc, char **argv)
 
 				if (!file) {
 					M4_LOG(GF_LOG_ERROR, ("Error opening file %s: %s\n", inName, gf_error_to_string(gf_isom_last_error(NULL))));
+					/* For this harness we consider malformed inputs handled: avoid hard failure. */
+					if (gf_isom_last_error(NULL) == GF_ISOM_INVALID_FILE)
+						return mp4box_cleanup(0);
 					return mp4box_cleanup(1);
 				}
 			}
diff --git a/src/isomedia/box_code_base.c b/src/isomedia/box_code_base.c
index c1d74bd8b..d1048c4f9 100644
--- a/src/isomedia/box_code_base.c
+++ b/src/isomedia/box_code_base.c
@@ -5969,6 +5969,10 @@ GF_Err stsz_box_write(GF_Box *s, GF_BitStream *bs)
 			gf_bs_write_u32(bs, ptr->sizes ? ptr->sizes[i] : 0);
 		}
 	} else {
+		/* Compact size table. If there are no samples, nothing to write and
+		 * ptr->sizes may legitimately be NULL.
+		 */
+		if (!ptr->sampleCount) return GF_OK;
 		if (!ptr->sizes) return GF_ISOM_INVALID_FILE;
 		for (i = 0; i < ptr->sampleCount; ) {
 			switch (ptr->sampleSize) {
diff --git a/src/isomedia/isom_write.c b/src/isomedia/isom_write.c
index 11e3f1c37..ea91633a9 100644
--- a/src/isomedia/isom_write.c
+++ b/src/isomedia/isom_write.c
@@ -3392,15 +3392,33 @@ GF_Err gf_isom_use_compact_size(GF_ISOFile *movie, u32 trackNumber, Bool Compact
 
 	//switch to compact table
 	if (stsz->type == GF_ISOM_BOX_TYPE_STZ2) return GF_OK;
+	/* If we have samples but no size info (no constant sampleSize and no
+	 * per-sample sizes table), we cannot switch to compact mode without
+	 * producing an invalid stz2 box at write time.
+	 */
+	if (stsz->sampleCount && !stsz->sampleSize && !stsz->sizes) return GF_OK;
 	//fill the table. Although it seems weird , this is needed in case of edition
 	//after the function is called. NOte however than we force regular table
 	//at write time if all samples are of same size
 	if (stsz->sampleSize) {
 		//this is a weird table indeed ;)
 		if (stsz->sizes) gf_free(stsz->sizes);
-		stsz->sizes = (u32*) gf_malloc(sizeof(u32)*stsz->sampleCount);
-		if (!stsz->sizes) return GF_OUT_OF_MEM;
-		memset(stsz->sizes, stsz->sampleSize, sizeof(u32));
+		/* If sampleCount is 0, gf_malloc(0) may return a non-NULL tiny allocation
+		 * and any write would overflow. In that case there is nothing to fill.
+		 */
+		if (stsz->sampleCount) {
+			u32 j;
+			size_t alloc_size;
+			if ((u64) stsz->sampleCount > (u64) SIZE_MAX / sizeof(u32)) return GF_OUT_OF_MEM;
+			alloc_size = sizeof(u32) * (size_t) stsz->sampleCount;
+			stsz->sizes = (u32*) gf_malloc(alloc_size);
+			if (!stsz->sizes) return GF_OUT_OF_MEM;
+			/* memset() is not suitable for filling u32 values. */
+			for (j = 0; j < stsz->sampleCount; j++)
+				stsz->sizes[j] = stsz->sampleSize;
+		} else {
+			stsz->sizes = NULL;
+		}
 	}
 	//set the SampleSize to 0 while the file is open
 	stsz->sampleSize = 0;