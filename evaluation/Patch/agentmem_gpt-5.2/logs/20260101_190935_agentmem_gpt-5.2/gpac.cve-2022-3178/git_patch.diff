diff --git a/src/isomedia/box_code_base.c b/src/isomedia/box_code_base.c
index 3cf6b3bd3..400abe759 100644
--- a/src/isomedia/box_code_base.c
+++ b/src/isomedia/box_code_base.c
@@ -12886,12 +12886,27 @@ GF_Err xtra_box_read(GF_Box *s, GF_BitStream *bs)
 			prop_type = gf_bs_read_u16(bs);
 			prop_size -= 6;
 			ISOM_DECREASE_SIZE_NO_ERR(ptr, prop_size)
-			//add 2 extra bytes for UTF16 case string dump
-			data2 = gf_malloc(sizeof(char) * (prop_size+2));
-			gf_bs_read_data(bs, data2, prop_size);
-			data2[prop_size] = 0;
-			data2[prop_size+1] = 0;
-			tag_size-=prop_size;
+			/*
+				XTRA tags may embed UTF-16 strings (prop_type==0). Some malformed files
+				declare an odd prop_size, which would make later UTF-16 word scanning
+				(eg gf_utf8_wcslen/gf_utf8_wcstombs) read 2 bytes past the allocation.
+				We defensively pad odd-sized UTF-16 buffers to an even size and always
+				append a 16-bit NUL terminator.
+			*/
+			u32 prop_read = prop_size;
+			u32 pad = 0;
+			if (!prop_type && (prop_size & 1)) pad = 1;
+			data2 = gf_malloc(sizeof(char) * (prop_size + pad + 2));
+			if (!data2) {
+				gf_free(data);
+				return GF_OUT_OF_MEM;
+			}
+			gf_bs_read_data(bs, data2, prop_read);
+			if (pad) data2[prop_read] = 0;
+			data2[prop_read + pad] = 0;
+			data2[prop_read + pad + 1] = 0;
+			prop_size = prop_read + pad;
+			tag_size-=prop_read;
 		} else {
 			prop_size = 0;
 		}