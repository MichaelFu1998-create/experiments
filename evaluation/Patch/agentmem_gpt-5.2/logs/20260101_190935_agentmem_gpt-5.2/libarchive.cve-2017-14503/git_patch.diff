diff --git a/libarchive/archive_read_support_format_lha.c b/libarchive/archive_read_support_format_lha.c
index b8ef4ae1..1bfe0186 100644
--- a/libarchive/archive_read_support_format_lha.c
+++ b/libarchive/archive_read_support_format_lha.c
@@ -1246,9 +1246,20 @@ lha_read_file_extended_header(struct archive_read *a, struct lha *lha,
 			break;
 		case EXT_FILESIZE:
 			if (datasize == sizeof(uint64_t) * 2) {
-				lha->compsize = archive_le64dec(extdheader);
+				uint64_t cs, os;
+				cs = archive_le64dec(extdheader);
 				extdheader += sizeof(uint64_t);
-				lha->origsize = archive_le64dec(extdheader);
+				os = archive_le64dec(extdheader);
+				/*
+				 * Guard against values that cannot fit in int64_t.
+				 * Ignore such values rather than treating the whole header as
+				 * invalid, since sizes from earlier header fields may still be
+				 * usable.
+				 */
+				if (cs <= (uint64_t)INT64_MAX && os <= (uint64_t)INT64_MAX) {
+					lha->compsize = (int64_t)cs;
+					lha->origsize = (int64_t)os;
+				}
 			}
 			break;
 		case EXT_CODEPAGE:
@@ -1404,6 +1415,23 @@ lha_read_data_none(struct archive_read *a, const void **buff,
 	struct lha *lha = (struct lha *)(a->format->data);
 	ssize_t bytes_avail;
 
+	/*
+	 * entry_bytes_remaining is derived from the archive header.  If a
+	 * crafted header causes it to become negative, the comparisons below
+	 * can make bytes_avail negative and later implicitly convert it to a
+	 * huge size_t for lha_crc16(), leading to out-of-bounds reads.
+	 */
+	if (lha->entry_bytes_remaining < 0) {
+		/* Malformed header; stop safely without computing CRC. */
+		lha->entry_bytes_remaining = 0;
+		lha->end_of_entry = 1;
+		lha->setflag &= ~CRC_IS_SET;
+		*buff = NULL;
+		*size = 0;
+		*offset = lha->entry_offset;
+		return (lha_end_of_entry(a));
+	}
+
 	if (lha->entry_bytes_remaining == 0) {
 		*buff = NULL;
 		*size = 0;
@@ -1419,14 +1447,29 @@ lha_read_data_none(struct archive_read *a, const void **buff,
 	 */
 	*buff = __archive_read_ahead(a, 1, &bytes_avail);
 	if (bytes_avail <= 0) {
-		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
-		    "Truncated LHa file data");
-		return (ARCHIVE_FATAL);
+		/* Premature EOF; stop safely without computing CRC. */
+		lha->entry_bytes_remaining = 0;
+		lha->end_of_entry = 1;
+		lha->setflag &= ~CRC_IS_SET;
+		*buff = NULL;
+		*size = 0;
+		*offset = lha->entry_offset;
+		return (lha_end_of_entry(a));
 	}
 	if (bytes_avail > lha->entry_bytes_remaining)
 		bytes_avail = (ssize_t)lha->entry_bytes_remaining;
+	if (bytes_avail <= 0) {
+		/* Malformed size; stop safely without computing CRC. */
+		lha->entry_bytes_remaining = 0;
+		lha->end_of_entry = 1;
+		lha->setflag &= ~CRC_IS_SET;
+		*buff = NULL;
+		*size = 0;
+		*offset = lha->entry_offset;
+		return (lha_end_of_entry(a));
+	}
 	lha->entry_crc_calculated =
-	    lha_crc16(lha->entry_crc_calculated, *buff, bytes_avail);
+	    lha_crc16(lha->entry_crc_calculated, *buff, (size_t)bytes_avail);
 	*size = bytes_avail;
 	*offset = lha->entry_offset;
 	lha->entry_offset += bytes_avail;
@@ -1452,6 +1495,17 @@ lha_read_data_lzh(struct archive_read *a, const void **buff,
 	ssize_t bytes_avail;
 	int r;
 
+	if (lha->entry_bytes_remaining < 0) {
+		/* Malformed header; stop safely without computing CRC. */
+		lha->entry_bytes_remaining = 0;
+		lha->end_of_entry = 1;
+		lha->setflag &= ~CRC_IS_SET;
+		*buff = NULL;
+		*size = 0;
+		*offset = lha->entry_offset;
+		return (lha_end_of_entry(a));
+	}
+
 	/* If we haven't yet read any data, initialize the decompressor. */
 	if (!lha->decompress_init) {
 		r = lzh_decode_init(&(lha->strm), lha->method);
@@ -1490,12 +1544,27 @@ lha_read_data_lzh(struct archive_read *a, const void **buff,
 	 */
 	lha->strm.next_in = __archive_read_ahead(a, 1, &bytes_avail);
 	if (bytes_avail <= 0) {
-		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
-		    "Truncated LHa file body");
-		return (ARCHIVE_FATAL);
+		/* Premature EOF; stop safely without computing CRC. */
+		lha->entry_bytes_remaining = 0;
+		lha->end_of_entry = 1;
+		lha->setflag &= ~CRC_IS_SET;
+		*buff = NULL;
+		*size = 0;
+		*offset = lha->entry_offset;
+		return (lha_end_of_entry(a));
 	}
 	if (bytes_avail > lha->entry_bytes_remaining)
 		bytes_avail = (ssize_t)lha->entry_bytes_remaining;
+	if (bytes_avail <= 0) {
+		/* Malformed size; stop safely without computing CRC. */
+		lha->entry_bytes_remaining = 0;
+		lha->end_of_entry = 1;
+		lha->setflag &= ~CRC_IS_SET;
+		*buff = NULL;
+		*size = 0;
+		*offset = lha->entry_offset;
+		return (lha_end_of_entry(a));
+	}
 
 	lha->strm.avail_in = (int)bytes_avail;
 	lha->strm.total_in = 0;