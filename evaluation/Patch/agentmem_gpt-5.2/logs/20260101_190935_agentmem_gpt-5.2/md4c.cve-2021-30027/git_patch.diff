diff --git a/md2html/md2html.c b/md2html/md2html.c
index 1758b0b..0caf9d0 100644
--- a/md2html/md2html.c
+++ b/md2html/md2html.c
@@ -66,7 +66,7 @@ membuf_init(struct membuffer* buf, MD_SIZE new_asize)
 {
     buf->size = 0;
     buf->asize = new_asize;
-    buf->data = malloc(buf->asize);
+    buf->data = calloc(1, buf->asize);
     if(buf->data == NULL) {
         fprintf(stderr, "membuf_init: malloc() failed.\n");
         exit(1);
@@ -83,11 +83,20 @@ membuf_fini(struct membuffer* buf)
 static void
 membuf_grow(struct membuffer* buf, size_t new_asize)
 {
+    size_t old_asize = buf->asize;
+
     buf->data = realloc(buf->data, new_asize);
     if(buf->data == NULL) {
         fprintf(stderr, "membuf_grow: realloc() failed.\n");
         exit(1);
     }
+
+    /* Ensure any newly allocated part is initialized. This makes the utility
+     * robust under MemorySanitizer and also prevents accidental reads from
+     * observing uninitialized bytes when the parser does look-ahead. */
+    if(new_asize > old_asize)
+        memset(buf->data + old_asize, 0, new_asize - old_asize);
+
     buf->asize = new_asize;
 }
 
diff --git a/src/md4c.c b/src/md4c.c
index 9e720be..0f1cf01 100644
--- a/src/md4c.c
+++ b/src/md4c.c
@@ -277,7 +277,15 @@ struct MD_VERBATIMLINE_tag {
  *****************/
 
 /* Character accessors. */
-#define CH(off)                 (ctx->text[(off)])
+/* Access a character from the input buffer.
+ *
+ * The parser works with (text,size) pairs; callers are not required to
+ * provide any NUL terminator or padding beyond size. Some code paths
+ * do look-ahead and historically could evaluate CH() with off == size
+ * on malformed input, which would read an uninitialized byte from the
+ * caller-provided buffer (MSan).
+ */
+#define CH(off)                 (((off) < ctx->size) ? (ctx->text[(off)]) : _T('\0'))
 #define STR(off)                (ctx->text + (off))
 
 /* Character classification.
@@ -5707,6 +5715,12 @@ md_analyze_line(MD_CTX* ctx, OFF beg, OFF* p_end,
     OFF hr_killer = 0;
     int ret = 0;
 
+    /* Make sure the whole analysis structure is initialized.
+     * MD_LINE_ANALYSIS uses bit-fields and the compiler may implement writes
+     * to one field as read-modify-write of the underlying storage.
+     * Zeroing it avoids any accidental propagation of uninitialized bits. */
+    *line = (MD_LINE_ANALYSIS) { 0 };
+
     line->indent = md_line_indentation(ctx, total_indent, off, &off);
     total_indent += line->indent;
     line->beg = off;
@@ -6084,16 +6098,15 @@ md_analyze_line(MD_CTX* ctx, OFF beg, OFF* p_end,
     /* Recent glibc versions have superbly optimized strcspn(), even using
      * vectorization if available. */
     if(ctx->doc_ends_with_newline  &&  off < ctx->size) {
-        while(TRUE) {
-            off += (OFF) strcspn(STR(off), "\r\n");
-
-            /* strcspn() can stop on zero terminator; but that can appear
-             * anywhere in the Markfown input... */
-            if(CH(off) == _T('\0'))
-                off++;
-            else
-                break;
-        }
+        /* Do not use strcspn() here.
+         * The input is an arbitrary buffer with explicit size and may not be
+         * NUL-terminated or fully initialized after the last byte. Some libc
+         * implementations of strcspn() may read ahead (e.g. vectorized loads),
+         * which can trigger sanitizers (MSan) on those uninitialized bytes.
+         *
+         * Use a bounded scan instead. */
+        while(off < ctx->size  &&  !ISNEWLINE(off))
+            off++;
     } else
 #endif
     {