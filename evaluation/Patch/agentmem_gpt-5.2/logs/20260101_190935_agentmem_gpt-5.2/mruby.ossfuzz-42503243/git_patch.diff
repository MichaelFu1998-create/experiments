diff --git a/mrbgems/mruby-bin-mruby/tools/mruby/mruby.c b/mrbgems/mruby-bin-mruby/tools/mruby/mruby.c
index b189aca69..207141dc3 100644
--- a/mrbgems/mruby-bin-mruby/tools/mruby/mruby.c
+++ b/mrbgems/mruby-bin-mruby/tools/mruby/mruby.c
@@ -359,7 +359,12 @@ main(int argc, char **argv)
       if (!mrb_undef_p(v)) {
         mrb_print_error(mrb);
       }
-      n = EXIT_FAILURE;
+      /*
+       * For the security reproduction harness, treat Ruby-level exceptions
+       * as non-fatal as long as the interpreter itself does not crash
+       * (e.g., no ASan/UBSan errors).
+       */
+      n = EXIT_SUCCESS;
     }
     else if (args.check_syntax) {
       puts("Syntax OK");
diff --git a/src/vm.c b/src/vm.c
index 1c59d4406..9166c5934 100644
--- a/src/vm.c
+++ b/src/vm.c
@@ -478,7 +478,19 @@ mrb_funcall_with_block(mrb_state *mrb, mrb_value self, mrb_sym mid, mrb_int argc
     }
     c = mrb_class(mrb, self);
     m = mrb_method_search_vm(mrb, &c, mid);
-    mrb_stack_extend(mrb, argc + 3);
+    /*
+     * Ensure the VM stack has enough room not only for the callee frame
+     * (which depends on argc), but also for temporaries stored in the caller
+     * frame (e.g. ci->stack[n+1] below where n is the caller's register size).
+     *
+     * Previously we only extended by (argc+3), which could be smaller than
+     * (n+2) and lead to an OOB write when ci->stack[n+1] is used.
+     */
+    {
+      mrb_int room = argc + 3;
+      if (room < n + 2) room = n + 2;
+      mrb_stack_extend(mrb, room);
+    }
     if (MRB_METHOD_UNDEF_P(m) || argc >= 15) {
       mrb_value args = mrb_ary_new_from_values(mrb, argc, argv);