diff --git a/src/utils/xml_parser.c b/src/utils/xml_parser.c
index 49df33816..2f58c4d1c 100644
--- a/src/utils/xml_parser.c
+++ b/src/utils/xml_parser.c
@@ -968,6 +968,9 @@ exit:
 static GF_Err xml_sax_append_string(GF_SAXParser *parser, char *string)
 {
 	u32 size = parser->line_size;
+	/* Defensive: malformed inputs can lead to NULL strings being appended.
+	   Avoid strlen(NULL) crashes. */
+	if (!string) return GF_BAD_PARAM;
 	u32 nl_size = (u32) strlen(string);
 
 	if (!nl_size) return GF_OK;
@@ -990,6 +993,10 @@ static GF_Err xml_sax_append_string(GF_SAXParser *parser, char *string)
 static XML_Entity *gf_xml_locate_entity(GF_SAXParser *parser, char *ent_start, Bool *needs_text)
 {
 	u32 i, count;
+	if (!ent_start) {
+		*needs_text = GF_FALSE;
+		return NULL;
+	}
 	u32 len = (u32) strlen(ent_start);
 
 	*needs_text = GF_FALSE;
@@ -1031,10 +1038,18 @@ static GF_Err gf_xml_sax_parse_intern(GF_SAXParser *parser, char *current)
 			entityEnd = strstr(current, ";");
 			if (!entityEnd) return xml_sax_append_string(parser, current);
 			entityStart = strrchr(parser->buffer, '&');
+			/* If parser state indicates an entity continuation but no '&' is present
+			   in the buffer, the input is inconsistent/corrupted. */
+			if (!entityStart) {
+				parser->in_entity = GF_FALSE;
+				parser->sax_state = SAX_STATE_SYNTAX_ERROR;
+				return GF_CORRUPTED_DATA;
+			}
 
 			entityEnd[0] = 0;
 			len = (u32) strlen(entityStart) + (u32) strlen(current) + 1;
 			name = (char*)gf_malloc(sizeof(char)*len);
+			if (!name) return GF_OUT_OF_MEM;
 			sprintf(name, "%s%s;", entityStart+1, current);
 
 			ent = gf_xml_locate_entity(parser, name, &needs_text);