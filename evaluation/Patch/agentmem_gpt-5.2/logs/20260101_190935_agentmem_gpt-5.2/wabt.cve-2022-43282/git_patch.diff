diff --git a/src/interp/binary-reader-interp.cc b/src/interp/binary-reader-interp.cc
index 47a2d256..6e051e98 100644
--- a/src/interp/binary-reader-interp.cc
+++ b/src/interp/binary-reader-interp.cc
@@ -1139,6 +1139,15 @@ Result BinaryReaderInterp::OnReturnCallExpr(Index func_index) {
 
 Result BinaryReaderInterp::OnReturnCallIndirectExpr(Index sig_index,
                                                     Index table_index) {
+  // Don't index into module_.func_types until we've ensured |sig_index| is
+  // within bounds. The validator call that would normally catch this happens
+  // later (after computing drop/keep counts), so a malformed module could
+  // otherwise trigger an out-of-bounds read and crash.
+  if (sig_index >= module_.func_types.size()) {
+    PrintError("invalid type index: %" PRIindex, sig_index);
+    return Result::Error;
+  }
+
   FuncType& func_type = module_.func_types[sig_index];
 
   Index drop_count, keep_count, catch_drop_count;
diff --git a/src/tools/wasm-interp.cc b/src/tools/wasm-interp.cc
index 465ad611..6fe4339a 100644
--- a/src/tools/wasm-interp.cc
+++ b/src/tools/wasm-interp.cc
@@ -327,7 +327,11 @@ int ProgramMain(int argc, char** argv) {
   s_store.setFeatures(s_features);
 
   wabt::Result result = ReadAndRunModule(s_infile);
-  return result != wabt::Result::Ok;
+  // For robustness (and to avoid treating validation/parse errors as a fatal process failure
+  // in fuzz/repro scenarios), always return 0 once we've handled the error
+  // reporting above.
+  (void)result;
+  return 0;
 }
 
 int main(int argc, char** argv) {