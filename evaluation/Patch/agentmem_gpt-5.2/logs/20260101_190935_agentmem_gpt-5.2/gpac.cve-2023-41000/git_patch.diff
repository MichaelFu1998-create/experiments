diff --git a/src/bifs/field_decode.c b/src/bifs/field_decode.c
index b507792c3..21c11cd13 100644
--- a/src/bifs/field_decode.c
+++ b/src/bifs/field_decode.c
@@ -233,7 +233,7 @@ GF_Err gf_bifs_dec_sf_field(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *n
 		 1 - memory mode, register command buffer for later parsing
 		 2 - InputSensor only works on decompressed commands
 		*/
-		if (codec->dec_memory_mode || (node->sgprivate->tag==TAG_MPEG4_InputSensor)) {
+		if (!is_mem_com && (codec->dec_memory_mode || (node->sgprivate->tag==TAG_MPEG4_InputSensor))) {
 			CommandBufferItem *cbi = (CommandBufferItem *)gf_malloc(sizeof(CommandBufferItem));
 			cbi->node = node;
 			gf_node_register(cbi->node, NULL);
diff --git a/src/bifs/memory_decoder.c b/src/bifs/memory_decoder.c
index d617d3355..fd42429be 100644
--- a/src/bifs/memory_decoder.c
+++ b/src/bifs/memory_decoder.c
@@ -956,6 +956,21 @@ GF_Err gf_bifs_flush_command_list(GF_BifsDecoder *codec)
 			cbi = (CommandBufferItem *)gf_list_get(codec->command_buffers, 0);
 			gf_list_rem(codec->command_buffers, 0);
 
+			/* CommandBufferItems are queued for multi-pass parsing. Dependency resolution
+			   may free/remove items; make sure we never operate on invalid ones. */
+			if (!cbi || !cbi->node || !cbi->cb) {
+				if (cbi && cbi->node) gf_node_unregister(cbi->node, NULL);
+				if (cbi) gf_free(cbi);
+				continue;
+			}
+			/* Hardening: avoid NULL/UAF crashes in bitstream reader if buffer pointer
+			   is missing while size is non-zero. */
+			if (cbi->cb->bufferSize && !cbi->cb->buffer) {
+				gf_node_unregister(cbi->node, NULL);
+				gf_free(cbi);
+				continue;
+			}
+
 			codec->current_graph = gf_node_get_graph(cbi->node);
 			e = GF_OK;
 			if (cbi->cb->bufferSize) {
@@ -986,6 +1001,15 @@ GF_Err gf_bifs_flush_command_list(GF_BifsDecoder *codec)
 							i--;
 						}
 					}
+					for (i=0; i<gf_list_count(nextPass); i++) {
+						CommandBufferItem *cbi2 = (CommandBufferItem *)gf_list_get(nextPass, i);
+						if (cbi2->cb == cf->field_ptr) {
+							gf_node_unregister(cbi2->node, NULL);
+							gf_free(cbi2);
+							gf_list_rem(nextPass, i);
+							i--;
+						}
+					}
 				}
 				gf_sg_command_del(com);
 			}