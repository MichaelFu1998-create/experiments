diff --git a/src/decode_r2007.c b/src/decode_r2007.c
index 37527b91..ebabf394 100644
--- a/src/decode_r2007.c
+++ b/src/decode_r2007.c
@@ -484,16 +484,28 @@ decompress_r2007 (BITCODE_RC *restrict dst, int dst_size,
   BITCODE_RC *src_end = src + src_size;
   unsigned char opcode;
 
-  if (!src)
+  if (!src || src_size <= 0)
     {
       LOG_ERROR ("Empty src argument to %s\n", __FUNCTION__);
       return DWG_ERR_INTERNALERROR;
     }
+
+  if (src >= src_end)
+    {
+      /* Nothing to decompress. Avoid reading past the end. */
+      return 0;
+    }
   opcode = *src++;
   LOG_INSANE ("decompress_r2007(%p %d %p %d)\n", dst, dst_size, src, src_size);
 
   if ((opcode & 0xf0) == 0x20)
     {
+      /* Needs 2 bytes to skip + 1 byte to read the initial length */
+      if ((src + 3) > src_end)
+        {
+          /* Truncated stream: stop gracefully. */
+          return 0;
+        }
       src += 2;
       length = *src++ & 0x07;
 
@@ -515,6 +527,21 @@ decompress_r2007 (BITCODE_RC *restrict dst, int dst_size,
           return DWG_ERR_INTERNALERROR;
         }
 
+      /* Ensure we never read past the compressed input buffer.
+         copy_compressed_bytes() performs fixed-size memcpy reads.
+         For truncated/corrupt input, clamp to remaining bytes. */
+      if ((src + length) > src_end)
+        {
+          length = (uint32_t)(src_end - src);
+          if (length == 0)
+            return 0;
+          if ((dst + length) > dst_end)
+            {
+              LOG_ERROR ("Decompression error: length overflow");
+              return DWG_ERR_INTERNALERROR;
+            }
+        }
+
       // LOG_INSANE("copy_compressed_bytes(%p %p %u)\n", dst, src, length);
       copy_compressed_bytes (dst, src, length);
 
@@ -528,6 +555,9 @@ decompress_r2007 (BITCODE_RC *restrict dst, int dst_size,
 
       opcode = *src++;
 
+      if ((src + 3) > src_end)
+        return 0;
+
       read_instructions (&src, &opcode, &offset, &length);
 
       while (1)
@@ -559,6 +589,9 @@ decompress_r2007 (BITCODE_RC *restrict dst, int dst_size,
           if ((opcode >> 4) == 0x0f)
             opcode &= 0xf;
 
+          if ((src + 3) > src_end)
+            return 0;
+
           read_instructions ((unsigned char **)&src, &opcode, &offset,
                              &length);
         }