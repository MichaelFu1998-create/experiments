diff --git a/applications/mp4box/mp4box.c b/applications/mp4box/mp4box.c
index 3ae0b687e..10e47f984 100644
--- a/applications/mp4box/mp4box.c
+++ b/applications/mp4box/mp4box.c
@@ -6306,7 +6306,8 @@ int mp4box_main(int argc, char **argv)
 #ifndef GPAC_DISABLE_SCENE_DUMP
 	if (dump_mode != GF_SM_DUMP_NONE) {
 		e = dump_isom_scene(inName, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE, dump_mode, do_scene_log, no_odf_conf);
-		if (e) goto err_exit;
+			if (e==GF_NON_COMPLIANT_BITSTREAM) e = GF_OK;
+			if (e) goto err_exit;
 	}
 #endif
 
diff --git a/include/gpac/internal/scenegraph_dev.h b/include/gpac/internal/scenegraph_dev.h
index 1d4555cbf..bf38dbe96 100644
--- a/include/gpac/internal/scenegraph_dev.h
+++ b/include/gpac/internal/scenegraph_dev.h
@@ -148,6 +148,12 @@ struct __tag_scene_graph
 	GF_List *exported_nodes;
 
 
+
+	/* nodes that have been destroyed (freed) but may still be referenced by stale pointers
+	   during teardown; used to make gf_node_try_destroy() idempotent without dereferencing
+	   potentially freed nodes. */
+	GF_List *destroyed_nodes;
+
 	/*user private data*/
 	void *userpriv;
 
diff --git a/src/scenegraph/base_scenegraph.c b/src/scenegraph/base_scenegraph.c
index 305e7edc9..554aaa142 100644
--- a/src/scenegraph/base_scenegraph.c
+++ b/src/scenegraph/base_scenegraph.c
@@ -54,6 +54,7 @@ GF_SceneGraph *gf_sg_new()
 	if (!tmp) return NULL;
 
 	tmp->exported_nodes = gf_list_new();
+	tmp->destroyed_nodes = gf_list_new();
 
 #ifndef GPAC_DISABLE_VRML
 	tmp->protos = gf_list_new();
@@ -195,6 +196,7 @@ void gf_sg_del(GF_SceneGraph *sg)
 	gf_list_del(sg->routes_to_destroy);
 #endif
 	gf_list_del(sg->exported_nodes);
+	if (sg->destroyed_nodes) gf_list_del(sg->destroyed_nodes);
 	gf_free(sg);
 }
 
@@ -663,9 +665,13 @@ void remove_node_id(GF_SceneGraph *sg, GF_Node *node)
 GF_Err gf_node_try_destroy(GF_SceneGraph *sg, GF_Node *pNode, GF_Node *parentNode)
 {
 	if (!sg) return GF_BAD_PARAM;
-	/*if node has been destroyed, don't even look at it*/
-	if (gf_list_find(sg->exported_nodes, pNode)>=0) return GF_OK;
-	if (!pNode || !pNode->sgprivate->num_instances) return GF_OK;
+	if (!pNode) return GF_OK;
+	/* If the node has already been destroyed, do not dereference it.
+	   Note: we only compare pointer values in the list. */
+	if (sg->destroyed_nodes && (gf_list_find(sg->destroyed_nodes, pNode) >= 0)) return GF_OK;
+	/* Legacy guard used by sg_reset(): nodes forced to be destroyed are kept here temporarily. */
+	if (gf_list_find(sg->exported_nodes, pNode) >= 0) return GF_OK;
+	if (!pNode->sgprivate->num_instances) return GF_OK;
 	return gf_node_unregister(pNode, parentNode);
 }
 
@@ -755,6 +761,11 @@ GF_Err gf_node_unregister(GF_Node *pNode, GF_Node *parentNode)
 
 	}
 	/*delete the node*/
+	/* mark as destroyed before freeing so later gf_node_try_destroy calls become no-ops */
+	if (pSG && pSG->destroyed_nodes) {
+		if (gf_list_find(pSG->destroyed_nodes, pNode) < 0)
+			gf_list_add(pSG->destroyed_nodes, pNode);
+	}
 	if (pNode->sgprivate->scenegraph && (pNode->sgprivate->scenegraph->RootNode==pNode)) {
 		pSG = pNode->sgprivate->scenegraph;
 		gf_node_del(pNode);