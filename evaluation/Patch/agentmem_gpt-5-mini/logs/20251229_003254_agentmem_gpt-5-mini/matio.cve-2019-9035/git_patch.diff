diff --git a/src/mat5.c b/src/mat5.c
index 2841b58..375e0cf 100644
--- a/src/mat5.c
+++ b/src/mat5.c
@@ -1284,7 +1284,18 @@ ReadNextCell( mat_t *mat, matvar_t *matvar )
                     cells[i]->rank = uncomp_buf[1];
                     nbytes -= cells[i]->rank;
                     cells[i]->rank /= 4;
-                    cells[i]->dims = (size_t*)malloc(cells[i]->rank*sizeof(*cells[i]->dims));
+                    /* Bounds check: uncomp_buf has 16 entries; dims start at index 2 */
+                    {
+                        size_t rank_count = cells[i]->rank;
+                        size_t max_uncomp_dims = (sizeof(uncomp_buf)/sizeof(uncomp_buf[0]));
+                        if (rank_count > 0 && rank_count <= (max_uncomp_dims > 2 ? max_uncomp_dims - 2 : 0)) {
+                            cells[i]->dims = (size_t*)malloc(rank_count*sizeof(*cells[i]->dims));
+                        } else {
+                            Mat_Critical("Rank %zu too large to process safely (compressed)", rank_count);
+                            cells[i]->rank = 0;
+                            cells[i]->dims = NULL;
+                        }
+                    }
                     if ( mat->byteswap ) {
                         for ( j = 0; j < cells[i]->rank; j++ )
                             cells[i]->dims[j] = Mat_uint32Swap(uncomp_buf+2+j);
@@ -1619,8 +1630,18 @@ ReadNextStructField( mat_t *mat, matvar_t *matvar )
                     fields[i]->rank = uncomp_buf[1];
                     nbytes -= fields[i]->rank;
                     fields[i]->rank /= 4;
-                    fields[i]->dims = (size_t*)malloc(fields[i]->rank*
-                                             sizeof(*fields[i]->dims));
+                    /* Bounds check: uncomp_buf has 16 entries; dims start at index 2 */
+                    {
+                        size_t rank_count = fields[i]->rank;
+                        size_t max_uncomp_dims = (sizeof(uncomp_buf)/sizeof(uncomp_buf[0]));
+                        if (rank_count > 0 && rank_count <= (max_uncomp_dims > 2 ? max_uncomp_dims - 2 : 0)) {
+                            fields[i]->dims = (size_t*)malloc(rank_count*sizeof(*fields[i]->dims));
+                        } else {
+                            Mat_Critical("Rank %zu too large to process safely (compressed)", rank_count);
+                            fields[i]->rank = 0;
+                            fields[i]->dims = NULL;
+                        }
+                    }
                     if ( mat->byteswap ) {
                         for ( j = 0; j < fields[i]->rank; j++ )
                             fields[i]->dims[j] = Mat_uint32Swap(uncomp_buf+2+j);