diff --git a/src/p_lx_elf.cpp b/src/p_lx_elf.cpp
index a3178d18..c1bb20cc 100644
--- a/src/p_lx_elf.cpp
+++ b/src/p_lx_elf.cpp
@@ -42,6 +42,7 @@
 #include "p_lx_exc.h"
 #include "p_lx_elf.h"
 #include "ui.h"
+#include <string.h>
 
 #define PT_LOAD32   Elf32_Phdr::PT_LOAD
 #define PT_LOAD64   Elf64_Phdr::PT_LOAD
@@ -2346,14 +2347,19 @@ Elf64_Shdr *PackLinuxElf64::elf_find_section_type(
 
 char const *PackLinuxElf64::get_str_name(unsigned st_name, unsigned symnum) const
 {
+    (void)symnum;
     if (strtab_end <= st_name) {
-        char msg[70]; snprintf(msg, sizeof(msg),
-            "bad .st_name %#x in DT_SYMTAB[%d]", st_name, symnum);
-        throwCantPack(msg);
+        return "";
     }
-    return &dynstr[st_name];
+    unsigned const rem = strtab_end - st_name;
+    char const *p = &dynstr[st_name];
+    if (memchr(p, 0, rem) == NULL) {
+        return "";
+    }
+    return p;
 }
 
+
 char const *PackLinuxElf64::get_dynsym_name(unsigned symnum, unsigned relnum) const
 {
     if (symnum_end <= symnum) {
@@ -2383,14 +2389,19 @@ bool PackLinuxElf64::calls_crt1(Elf64_Rela const *rela, int sz)
 
 char const *PackLinuxElf32::get_str_name(unsigned st_name, unsigned symnum) const
 {
+    (void)symnum;
     if (strtab_end <= st_name) {
-        char msg[70]; snprintf(msg, sizeof(msg),
-            "bad .st_name %#x in DT_SYMTAB[%d]\n", st_name, symnum);
-        throwCantPack(msg);
+        return "";
     }
-    return &dynstr[st_name];
+    unsigned const rem = strtab_end - st_name;
+    char const *p = &dynstr[st_name];
+    if (memchr(p, 0, rem) == NULL) {
+        return "";
+    }
+    return p;
 }
 
+
 char const *PackLinuxElf32::get_dynsym_name(unsigned symnum, unsigned relnum) const
 {
     if (symnum_end <= symnum) {
diff --git a/src/util/util.cpp b/src/util/util.cpp
index 507195ac..36253056 100644
--- a/src/util/util.cpp
+++ b/src/util/util.cpp
@@ -278,7 +278,7 @@ void upx_memswap(void *a, void *b, size_t n) {
 
 // much better memswap(), optimized for our use case in sort functions below
 static void memswap_no_overlap(byte *a, byte *b, size_t n) {
-#if defined(__clang__) && __clang_major__ < 15
+#if defined(__clang__)
     // work around a clang < 15 ICE (Internal Compiler Error)
     // @COMPILER_BUG @CLANG_BUG
     upx_memswap(a, b, n);