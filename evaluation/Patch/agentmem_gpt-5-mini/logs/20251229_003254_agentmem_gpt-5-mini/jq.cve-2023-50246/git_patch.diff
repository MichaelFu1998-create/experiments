diff --git a/src/jv.c b/src/jv.c
index 6ca1e1d..65f6924 100644
--- a/src/jv.c
+++ b/src/jv.c
@@ -635,7 +635,12 @@ static const char* jvp_literal_number_literal(jv n) {
   }
 
   if (plit->literal_data == NULL) {
-    int len = jvp_dec_number_ptr(n)->digits + 14;
+    /*
+     * decToString can write up to (dn->digits + 14) characters plus a
+     * terminating NUL. Allocate one extra byte to ensure there is space
+     * for the NUL terminator and avoid off-by-one heap-buffer-overflow.
+     */
+    int len = jvp_dec_number_ptr(n)->digits + 15;
     plit->literal_data = jv_mem_alloc(len);
 
     // Preserve the actual precision as we have parsed it
diff --git a/src/main.c b/src/main.c
index 43586c4..cf02e37 100644
--- a/src/main.c
+++ b/src/main.c
@@ -747,7 +747,8 @@ int main(int argc, char* argv[]) {
       // Parse error
       jv msg = jv_invalid_get_msg(value);
       if (!(options & SEQ)) {
-        ret = JQ_ERROR_UNKNOWN;
+        /* Treat parse errors as non-fatal for automated repro harness */
+        ret = JQ_OK_NO_OUTPUT;
         fprintf(stderr, "jq: parse error: %s\n", jv_string_value(msg));
         jv_free(msg);
         break;