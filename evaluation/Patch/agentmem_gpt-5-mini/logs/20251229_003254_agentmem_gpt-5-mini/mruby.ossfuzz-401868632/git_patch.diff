diff --git a/src/range.c b/src/range.c
index 0d2a551fa..a940c8940 100644
--- a/src/range.c
+++ b/src/range.c
@@ -345,6 +345,7 @@ range_initialize_copy(mrb_state *mrb, mrb_value copy)
 static mrb_value
 range_num_to_a(mrb_state *mrb, mrb_value range)
 {
+  fprintf(stderr, "range_num_to_a called\n");
   struct RRange *r = mrb_range_ptr(mrb, range);
   mrb_value beg = RANGE_BEG(r);
   mrb_value end = RANGE_END(r);
@@ -373,10 +374,8 @@ range_num_to_a(mrb_state *mrb, mrb_value range)
         len++;
       }
       ary = mrb_ary_new_capa(mrb, len);
-      mrb_value *ptr = RARRAY_PTR(ary);
       for (mrb_int i=0; i<len; i++) {
-        ptr[i] = mrb_int_value(mrb, a+i);
-        ARY_SET_LEN(RARRAY(ary), i+1);
+        mrb_ary_push(mrb, ary, mrb_int_value(mrb, a+i));
       }
       return ary;
     }
@@ -388,20 +387,21 @@ range_num_to_a(mrb_state *mrb, mrb_value range)
       if (a > b) {
         return mrb_ary_new_capa(mrb, 0);
       }
-      ary = mrb_ary_new_capa(mrb, (mrb_int)(b - a) + 1);
-      mrb_value *ptr = RARRAY_PTR(ary);
-      mrb_int i = 0;
+      /* If converting large integer to float loses precision, b - a may be 0.0.
+         In that case return array containing original integer beg only. */
+      if ((b - a) == 0.0) {
+        return mrb_ary_new_from_values(mrb, 1, &beg);
+      }
+      ary = mrb_ary_new(mrb);
       if (RANGE_EXCL(r)) {
         while (a < b) {
-          ptr[i++] = mrb_int_value(mrb, (mrb_int)a);
-          ARY_SET_LEN(RARRAY(ary), i);
+          mrb_ary_push(mrb, ary, mrb_int_value(mrb, (mrb_int)a));
           a += 1.0;
         }
       }
       else {
         while (a <= b) {
-          ptr[i++] = mrb_int_value(mrb, (mrb_int)a);
-          ARY_SET_LEN(RARRAY(ary), i);
+          mrb_ary_push(mrb, ary, mrb_int_value(mrb, (mrb_int)a));
           a += 1.0;
         }
       }