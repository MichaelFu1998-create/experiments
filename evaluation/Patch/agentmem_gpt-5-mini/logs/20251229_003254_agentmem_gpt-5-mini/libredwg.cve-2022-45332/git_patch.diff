diff --git a/src/decode_r11.c b/src/decode_r11.c
index 7db9052c..d285cda8 100644
--- a/src/decode_r11.c
+++ b/src/decode_r11.c
@@ -127,7 +127,12 @@ decode_preR13_section_hdr (const char *restrict name, Dwg_Section_Type_r11 id,
 		           Bit_Chain *restrict dat, Dwg_Data *restrict dwg)
 {
   int error = 0;
-  Dwg_Section *tbl = &dwg->header.section[id];
+  Dwg_Section *tbl = NULL;
+  if (!dwg || !dwg->header.section || id < 0 || id >= dwg->header.numsections) {
+    LOG_ERROR("Invalid section id %d", id);
+    return DWG_ERR_INVALIDDWG;
+  }
+  tbl = &dwg->header.section[id];
   //Dwg_Object_BLOCK_CONTROL *block_control = dwg_block_control (dwg);
   //Dwg_Object_BLOCK_HEADER *mspace;
   //Dwg_Object *mspaceobj;
@@ -136,8 +141,11 @@ decode_preR13_section_hdr (const char *restrict name, Dwg_Section_Type_r11 id,
   tbl->number = bit_read_RS (dat);
   tbl->flags = bit_read_RS (dat);
   tbl->address = bit_read_RL (dat);
-  strncpy (tbl->name, name, sizeof(tbl->name) - 1);
-  tbl->name[63] = '\0';
+  { size_t _name_size = sizeof (tbl->name);
+  if (name) strncpy (tbl->name, name, _name_size - 1);
+  else tbl->name[0] = '\0';
+  tbl->name[_name_size - 1] = '\0';
+  }
   LOG_TRACE ("ptr table %-8s [%2d]: size:%-4u num:%-2d (0x%lx-0x%lx) flags:0x%x\n",
              tbl->name, id, tbl->size, tbl->number, (unsigned long)tbl->address,
              (unsigned long)(tbl->address + (tbl->number * tbl->size)),
@@ -226,27 +234,52 @@ static int
 decode_preR13_section (Dwg_Section_Type_r11 id, Bit_Chain *restrict dat,
                        Dwg_Data *restrict dwg)
 {
-  Dwg_Section *tbl = &dwg->header.section[id];
+  Dwg_Section *tbl = NULL;
   Bit_Chain *hdl_dat = dat;
   int i;
   BITCODE_BL vcount;
   int error = 0;
-  long unsigned int num = dwg->num_objects;
-  long unsigned int pos = tbl->address;
+  long unsigned int num = 0;
+  long unsigned int pos = 0;
   BITCODE_RC flag;
   BITCODE_TF name;
+  /* Validate dwg and section array and id before use. */
+  if (!dwg || !dwg->header.section) {
+    LOG_ERROR("Empty header.section");
+    return DWG_ERR_INVALIDDWG;
+  }
+  if (id < 0 || id >= dwg->header.numsections) {
+    LOG_ERROR("Invalid section id %d", id);
+    return DWG_ERR_INVALIDDWG;
+  }
+  tbl = &dwg->header.section[id];
+  /* Protect against bogus addresses read from the bitstream. */
+  num = dwg->num_objects;
+  if ((unsigned long)tbl->address > dat->size) {
+    LOG_ERROR("%s.address out of range", tbl->name);
+    return DWG_ERR_INVALIDDWG;
+  }
+  pos = tbl->address;
 
   LOG_TRACE ("contents table %-8s [%2d]: size:%-4u num:%-3ld (0x%lx-0x%lx)\n",
              tbl->name, id, tbl->size, (long)tbl->number, (unsigned long)tbl->address,
              (unsigned long)(tbl->address + ((unsigned long long)tbl->number * tbl->size)))
   dat->byte = tbl->address;
   dat->bit = 0;
-  if ((unsigned long)(tbl->number * tbl->size) > dat->size - dat->byte)
-    {
+  /* Check for obviously invalid tables and avoid multiplication overflow. */
+  if (tbl->number == 0 || tbl->size == 0) {
+    /* Nothing to do for empty table. */
+    dat->byte = tbl->address + (unsigned long long)tbl->number * (unsigned long long)tbl->size;
+  } else {
+    unsigned long long need = (unsigned long long)tbl->number * (unsigned long long)tbl->size;
+    unsigned long long avail = 0;
+    if (dat->byte <= dat->size) avail = (unsigned long long)(dat->size - dat->byte);
+    if (need > avail || tbl->address > dat->size) {
       LOG_ERROR ("Overlarge table num_entries %ld or size %ld for %-8s [%2d]",
                  (long)tbl->number, (long)tbl->size, tbl->name, id);
       return DWG_ERR_INVALIDDWG;
     }
+  }
   tbl->objid_r11 = num;
   if (dwg->num_alloced_objects < dwg->num_objects + tbl->number)
     {
@@ -258,25 +291,35 @@ decode_preR13_section (Dwg_Section_Type_r11 id, Bit_Chain *restrict dat,
 
   // TODO: use the dwg.spec instead
   // MAYBE: move to a spec dwg_r11.spec, and dwg_decode_r11_NAME
-#define PREP_TABLE(token)                                                     \
-  Dwg_Object *obj;                                                            \
-  Dwg_Object_##token *_obj;                                                   \
-  Dwg_Object *ctrl = dwg_get_first_object (dwg, DWG_TYPE_##token##_CONTROL);  \
-  Dwg_Object_##token##_CONTROL *_ctrl                                         \
-      = ctrl->tio.object->tio.token##_CONTROL;                                \
-  if (dat->byte > dat->size || (num + i) > dwg->num_objects)                  \
-    return DWG_ERR_INVALIDDWG;                                                \
-  flag = bit_read_RC (dat);                                                   \
-  name = bit_read_TF (dat, 32);                                               \
-  _obj = dwg_add_##token (dwg, (const char *)name);                           \
-  obj = dwg_obj_generic_to_object (_obj, &error);                             \
-  _ctrl->entries[i] = dwg_add_handleref (dwg, 2, obj->handle.value, obj);     \
-  obj->size = tbl->size;                                                      \
-  obj->address = pos;                                                         \
-  _obj->flag = flag;                                                          \
-  LOG_TRACE ("\n-- table entry " #token " [%d]: 0x%lx\n", i, pos);            \
-  LOG_TRACE ("flag: %u [RC 70]\n", flag);                                     \
-  LOG_TRACE ("name: \"%s\" [TF 32 2]\n", name);                               \
+
+
+
+#define PREP_TABLE(token) \
+  Dwg_Object *obj; \
+  Dwg_Object_##token *_obj; \
+  Dwg_Object *ctrl = dwg_get_first_object (dwg, DWG_TYPE_##token##_CONTROL); \
+  Dwg_Object_##token##_CONTROL *_ctrl = NULL; \
+  if (ctrl) \
+    _ctrl = ctrl->tio.object->tio.token##_CONTROL; \
+  if (dat->byte > dat->size || (num + i) > dwg->num_objects) \
+    return DWG_ERR_INVALIDDWG; \
+  flag = bit_read_RC (dat); \
+  name = bit_read_TF (dat, 32); \
+  _obj = dwg_add_##token (dwg, (const char *)name); \
+  obj = dwg_obj_generic_to_object (_obj, &error); \
+  /* Only add handle and set object fields if obj is non-NULL. */ \
+  if (obj) { \
+    if (_ctrl) \
+      _ctrl->entries[i] = (obj ? dwg_add_handleref (dwg, 2, obj->handle.value, obj) : NULL); \
+    obj->size = tbl->size; \
+    obj->address = pos; \
+  } else { \
+    if (_ctrl) _ctrl->entries[i] = NULL; \
+  } \
+  if (_obj) _obj->flag = flag; \
+  LOG_TRACE ("\n-- table entry " #token " [%d]: 0x%lx\n", i, pos); \
+  LOG_TRACE ("flag: %u [RC 70]\n", flag); \
+  LOG_TRACE ("name: \"%s\" [TF 32 2]\n", name); \
   free (name)
 
 #define CHK_ENDPOS                                                            \
@@ -321,8 +364,7 @@ decode_preR13_section (Dwg_Section_Type_r11 id, Bit_Chain *restrict dat,
             if (ctrl)
               {
                 _ctrl = ctrl->tio.object->tio.BLOCK_CONTROL;
-                _ctrl->entries[i]
-                    = dwg_add_handleref (dwg, 2, obj->handle.value, obj);
+                _ctrl->entries[i] = (obj ? dwg_add_handleref (dwg, 2, obj->handle.value, obj) : NULL);
               }
 
             // TODO move to => dwg.spec
@@ -478,8 +520,7 @@ decode_preR13_section (Dwg_Section_Type_r11 id, Bit_Chain *restrict dat,
             ucsydir.y = bit_read_RD (dat);
             _obj = dwg_add_UCS (dwg, &ucsorg, &ucsxdir, &ucsydir, (const char *)name);
             obj = dwg_obj_generic_to_object (_obj, &error);
-            _ctrl->entries[i]
-                = dwg_add_handleref (dwg, 2, obj->handle.value, obj);
+            _ctrl->entries[i] = (obj ? dwg_add_handleref (dwg, 2, obj->handle.value, obj) : NULL);
             obj->size = tbl->size;
             obj->address = pos;
             _obj->flag = flag;