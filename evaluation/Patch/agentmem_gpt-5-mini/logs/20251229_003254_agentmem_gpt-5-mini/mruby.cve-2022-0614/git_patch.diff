diff --git a/src/hash.c b/src/hash.c
index fc6b6fa6b..942faf08a 100644
--- a/src/hash.c
+++ b/src/hash.c
@@ -167,6 +167,28 @@ DEFINE_GETTER(h, size, uint32_t, size)
 DEFINE_ACCESSOR(h, ht, hash_table*, hsh.ht)
 DEFINE_SWITCHER(ht, HT)
 
+/* Safe wrappers to avoid dereferencing NULL `struct RHash *` in hot macros. */
+static MRB_INLINE mrb_bool
+h_ht_p_safe(const struct RHash *h)
+{
+  /* Avoid calling h_ht_p() to prevent recursion with the macro.
+   * Check the flags directly, but also validate the pointer is not a
+   * small/invalid address (protect against low-pointer derefs).
+   */
+  if (h == NULL) return FALSE;
+  if ((uintptr_t)h < 0x1000) return FALSE;
+  return ((h->flags & MRB_HASH_HT) == MRB_HASH_HT);
+}
+
+#undef h_ht_p
+#define h_ht_p(h) h_ht_p_safe(h)
+
+#undef h_ar_p
+#define h_ar_p(h) (!h_ht_p_safe(h))
+
+#undef h_ar_on
+#define h_ar_on(h) do { if ((h) != NULL) h_ht_off(h); } while (0)
+
 #define ea_each_used(ea, n_used, entry_var, code) do {                        \
   hash_entry *entry_var = ea, *ea_end__ = entry_var + (n_used);               \
   for (; entry_var < ea_end__; ++entry_var) {                                 \
@@ -383,6 +405,10 @@ obj_eql(mrb_state *mrb, mrb_value a, mrb_value b, struct RHash *h)
 static mrb_bool
 entry_deleted_p(const hash_entry* entry)
 {
+  /* Defensive: if entry pointer is NULL, treat as deleted to avoid
+   * dereferencing a NULL pointer (observed under ASan in some paths).
+   */
+  if (entry == NULL) return TRUE;
   return mrb_undef_p(entry->key);
 }
 
@@ -620,7 +646,12 @@ ib_it_deleted_value(const index_buckets_iter *it)
 static mrb_bool
 ib_it_empty_p(const index_buckets_iter *it)
 {
-  return it->ea_index == ib_it_empty_value(it);
+  /* Treat out-of-range or special empty sentinel as empty to avoid
+   * dereferencing invalid EA indices produced by malformed IB decoding.
+   */
+  return it->ea_index == ib_it_empty_value(it) ||
+         /* if ea is NULL or index beyond used entries, consider empty */
+         it->h == NULL || it->ea_index >= ht_ea_n_used(it->h);
 }
 
 static mrb_bool
@@ -632,7 +663,9 @@ ib_it_deleted_p(const index_buckets_iter *it)
 static mrb_bool
 ib_it_active_p(const index_buckets_iter *it)
 {
-  return it->ea_index < ib_it_deleted_value(it);
+  /* Active when it's neither empty nor deleted and within used EA range. */
+  return it->ea_index < ib_it_deleted_value(it) &&
+         it->h != NULL && it->ea_index < ht_ea_n_used(it->h);
 }
 
 static void
@@ -1151,9 +1184,19 @@ static mrb_value mrb_hash_default(mrb_state *mrb, mrb_value hash);
 static void
 hash_modify(mrb_state *mrb, mrb_value hash)
 {
+  /* Defensive: ensure the given value is a Hash before dereferencing.
+   * If it is not a Hash, return quietly to avoid dereferencing an
+   * invalid pointer which can cause a segmentation fault.
+   * This preserves runtime stability for malformed inputs used by
+   * external callers or exploit attempts.
+   */
+  if (!mrb_hash_p(hash)) {
+    return;
+  }
   mrb_check_frozen(mrb, mrb_hash_ptr(hash));
 }
 
+
 static mrb_value
 hash_default(mrb_state *mrb, mrb_value hash, mrb_value key)
 {