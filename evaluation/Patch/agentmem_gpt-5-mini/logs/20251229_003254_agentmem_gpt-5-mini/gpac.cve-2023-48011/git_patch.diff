diff --git a/src/isomedia/movie_fragments.c b/src/isomedia/movie_fragments.c
index b7f7ade32..59c67be11 100644
--- a/src/isomedia/movie_fragments.c
+++ b/src/isomedia/movie_fragments.c
@@ -928,24 +928,43 @@ GF_Err gf_isom_write_compressed_box(GF_ISOFile *mov, GF_Box *root_box, u32 repl_
 
 void flush_ref_samples(GF_ISOFile *movie, u64 *out_seg_size, Bool use_seg_marker)
 {
-	u32 i=0;
+	if (!movie) return;
 	if (movie->in_sidx_write) return;
-	u32 trun_count = gf_list_count(movie->moof->trun_list);
-	for (i=0; i<trun_count; i++) {
-		GF_TrackFragmentRunBox *trun = gf_list_get(movie->moof->trun_list, i);
-		u32 s_count = gf_list_count(trun->sample_refs);
-		while (s_count) {
-			if (!use_seg_marker && movie->on_last_block_start && (i+1==trun_count) && (s_count==1)) {
-				movie->on_last_block_start(movie->on_block_out_usr_data);
+	if (!movie->moof) return;
+
+	/* Safer iteration: traverse TRAFs and their TrackRuns instead of relying on moof->trun_list
+	   which may contain pointers to truns that have been freed elsewhere. This avoids
+	   dereferencing freed trun structures. */
+	u32 ti = 0;
+	while (movie->moof && (ti < gf_list_count(movie->moof->TrackList))) {
+		GF_TrackFragmentBox *traf = (GF_TrackFragmentBox*)gf_list_get(movie->moof->TrackList, ti);
+		ti++;
+		if (!traf) continue;
+		u32 ri = 0;
+		while (traf && (ri < gf_list_count(traf->TrackRuns))) {
+			GF_TrackFragmentRunBox *trun = (GF_TrackFragmentRunBox*)gf_list_get(traf->TrackRuns, ri);
+			ri++;
+			if (!trun || !trun->sample_refs) continue;
+			/* Pop all sample refs for this trun */
+			while (gf_list_count(trun->sample_refs)) {
+				GF_TrafSampleRef *sref = (GF_TrafSampleRef*)gf_list_pop_front(trun->sample_refs);
+				if (!sref) break;
+				if (movie->on_block_out) {
+					movie->on_block_out(movie->on_block_out_usr_data, sref->data, sref->len, sref->ref, sref->ref_offset);
+				}
+				if (out_seg_size) *out_seg_size += sref->len;
+				if (!sref->ref) gf_free(sref->data);
+				gf_free(sref);
 			}
-			GF_TrafSampleRef *sref = gf_list_pop_front(trun->sample_refs);
-			movie->on_block_out(movie->on_block_out_usr_data, sref->data, sref->len, sref->ref, sref->ref_offset);
-			if (out_seg_size) *out_seg_size += sref->len;
-			if (!sref->ref) gf_free(sref->data);
-			gf_free(sref);
-			s_count--;
 		}
 	}
+
+	/* Ensure last-block callback is invoked if needed (best-effort fallback)
+	   Original code called on_last_block_start for the last trun/sample when
+	   not using segment markers. Call it here once if no moof_list remains. */
+	if (!use_seg_marker && movie->on_last_block_start && !gf_list_count(movie->moof ? movie->moof->trun_list : NULL)) {
+		movie->on_last_block_start(movie->on_block_out_usr_data);
+	}
 }
 
 GF_Err gf_bs_grow(GF_BitStream *bs, u32 addSize);