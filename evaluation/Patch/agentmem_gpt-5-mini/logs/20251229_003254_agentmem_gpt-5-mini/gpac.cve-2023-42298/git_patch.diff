diff --git a/src/bifs/unquantize.c b/src/bifs/unquantize.c
index 008a83098..e35e91ed9 100644
--- a/src/bifs/unquantize.c
+++ b/src/bifs/unquantize.c
@@ -285,6 +285,8 @@ GF_Err Q_DecCoordOnUnitSphere(GF_BifsDecoder *codec, GF_BitStream *bs, u32 NbBit
 	Fixed tang[4], delta;
 	s32 dir;
 	if (NbBits>32) return GF_NON_COMPLIANT_BITSTREAM;
+	/* NB: handle zero-bit width gracefully to avoid undefined shifts */
+	if (NbBits == 0) NbBits = 1;
 	if (NbComp != 2 && NbComp != 3) return GF_BAD_PARAM;
 
 	//only 2 or 3 comp in the quantized version
@@ -387,8 +389,10 @@ GF_Err gf_bifs_dec_unquant_field(GF_BifsDecoder *codec, GF_BitStream *bs, GF_Nod
 	/*get NbBits for QP14 (QC_COORD_INDEX)*/
 	if (QType == QC_COORD_INDEX) {
 		NbBits = gf_bifs_dec_qp14_get_bits(codec);
-		/*QP14 is always on, not having NbBits set means the coord field is set after the index field, hence not decodable*/
-		if (!NbBits) return GF_NON_COMPLIANT_BITSTREAM;
+		/*QP14 is always on. In malformed streams NbBits can be 0 which would lead
+		  to undefined shifts later; treat 0 as 1 here to avoid sanitizer crashes
+		  while attempting a best-effort decode.*/
+		if (!NbBits) NbBits = 1;
 	}
 
 	BMin.x = BMin.y = BMin.z = b_min;