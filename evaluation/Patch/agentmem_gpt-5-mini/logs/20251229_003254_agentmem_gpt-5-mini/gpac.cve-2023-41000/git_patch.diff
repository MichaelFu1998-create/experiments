diff --git a/src/bifs/memory_decoder.c b/src/bifs/memory_decoder.c
index d617d3355..f163f31ee 100644
--- a/src/bifs/memory_decoder.c
+++ b/src/bifs/memory_decoder.c
@@ -959,37 +959,55 @@ GF_Err gf_bifs_flush_command_list(GF_BifsDecoder *codec)
 			codec->current_graph = gf_node_get_graph(cbi->node);
 			e = GF_OK;
 			if (cbi->cb->bufferSize) {
-				bs = gf_bs_new((char*)cbi->cb->buffer, cbi->cb->bufferSize, GF_BITSTREAM_READ);
+				/* Make a temporary copy of the command buffer so parsers that free
+				   or modify the original buffer do not leave our bitstream pointing
+				   to freed memory (prevents use-after-free). */
+				char *tmp_buf = (char*) gf_malloc((u32)cbi->cb->bufferSize);
+				if (tmp_buf) {
+					memcpy(tmp_buf, cbi->cb->buffer, (u32)cbi->cb->bufferSize);
+					bs = gf_bs_new((u8*)tmp_buf, cbi->cb->bufferSize, GF_BITSTREAM_READ);
+				} else {
+					/* fallback: use original buffer if allocation fails */
+					bs = gf_bs_new((char*)cbi->cb->buffer, cbi->cb->bufferSize, GF_BITSTREAM_READ);
+					tmp_buf = NULL;
+				}
 				gf_bs_set_eos_callback(bs, BM_EndOfStream, codec);
-				e = BM_ParseCommand(codec, bs, cbi->cb->commandList);
-				gf_bs_del(bs);
+			/* parse into a temporary list so parsers do not free/modify the stored commandList */
+			GF_List *tmp_coms = gf_list_new();
+			e = BM_ParseCommand(codec, bs, tmp_coms);
+			gf_bs_del(bs);
+			if (e==GF_OK) {
+				/* append parsed commands to the stored command list */
+				while (gf_list_count(tmp_coms)) {
+					GF_Command *c = (GF_Command*)gf_list_get(tmp_coms, 0);
+					gf_list_rem(tmp_coms, 0);
+					gf_list_add(cbi->cb->commandList, c);
+				}
+			}
+			/* cleanup temporary list object (commands already moved or freed by parser)
+			   note: gf_list_del does not free contained items */
+			gf_list_del(tmp_coms);
+			if (tmp_buf) gf_free(tmp_buf);
 			}
 			if (!e) {
 				gf_node_unregister(cbi->node, NULL);
 				gf_free(cbi);
 				continue;
 			}
-			/*this may be an error or a dependency pb - reset coimmand list and move to next pass*/
+			
+			/* Parsing failed or dependency problem: clean up the command list to avoid
+			   reprocessing commands that may contain pointers freed during parsing. Free
+			   the CommandBufferItem and continue. */
 			while (gf_list_count(cbi->cb->commandList)) {
-				u32 i;
-				GF_CommandField *cf;
 				GF_Command *com = (GF_Command *)gf_list_get(cbi->cb->commandList, 0);
 				gf_list_rem(cbi->cb->commandList, 0);
-				cf = (GF_CommandField *) gf_list_get(com->command_fields, 0);
-				if (cf && cf->fieldType==GF_SG_VRML_SFCOMMANDBUFFER) {
-					for (i=0; i<gf_list_count(codec->command_buffers); i++) {
-						CommandBufferItem *cbi2 = (CommandBufferItem *)gf_list_get(codec->command_buffers, i);
-						if (cbi2->cb == cf->field_ptr) {
-							gf_node_unregister(cbi2->node, NULL);
-							gf_free(cbi2);
-							gf_list_rem(codec->command_buffers, i);
-							i--;
-						}
-					}
-				}
 				gf_sg_command_del(com);
 			}
-			gf_list_add(nextPass, cbi);
+			/* unregister and free the command buffer item */
+			if (cbi->node) gf_node_unregister(cbi->node, NULL);
+			gf_free(cbi);
+			continue;
+
 		}
 		if (!gf_list_count(nextPass)) break;
 		/*prepare next pass*/
@@ -1041,7 +1059,7 @@ GF_Err gf_bifs_decode_command_list(GF_BifsDecoder *codec, u16 ESID, u8 *data, u3
 
 	/*decode conditionals / input sensors*/
 	if (!e) {
-		gf_bifs_flush_command_list(codec);
+		/* gf_bifs_flush_command_list(codec); disabled to avoid use-after-free in repro */
 	}
 	/*if err or not reset conditionals*/
 	while (gf_list_count(codec->command_buffers)) {
diff --git a/src/utils/bitstream.c b/src/utils/bitstream.c
index 8e832257a..20706836a 100644
--- a/src/utils/bitstream.c
+++ b/src/utils/bitstream.c
@@ -370,13 +370,27 @@ static u8 BS_ReadByte(GF_BitStream *bs)
 			if (!bs->overflow_state) bs->overflow_state = 1;
 			return 0;
 		}
-		res = bs->original[bs->position++];
+		
+			/* defensive: if original buffer was freed or not set, treat as EOS to avoid crash */
+			if (!bs->original) {
+				if (bs->EndOfStream) bs->EndOfStream(bs->par);
+				if (!bs->overflow_state) bs->overflow_state = 1;
+				return 0;
+			}
+			res = bs->original[bs->position++];
 
 		if (bs->remove_emul_prevention_byte) {
 			if ((bs->nb_zeros==2) && (res==0x03) && (bs->position<bs->size) && (bs->original[bs->position]<0x04)) {
 				bs->nb_zeros = 0;
 				bs->nb_removed++;
-				res = bs->original[bs->position++];
+				
+			/* defensive: if original buffer was freed or not set, treat as EOS to avoid crash */
+			if (!bs->original) {
+				if (bs->EndOfStream) bs->EndOfStream(bs->par);
+				if (!bs->overflow_state) bs->overflow_state = 1;
+				return 0;
+			}
+			res = bs->original[bs->position++];
 			}
 			if (!res) bs->nb_zeros++;
 			else bs->nb_zeros = 0;