diff --git a/libheif/uncompressed_image.cc b/libheif/uncompressed_image.cc
index 5218165..2389706 100644
--- a/libheif/uncompressed_image.cc
+++ b/libheif/uncompressed_image.cc
@@ -362,9 +362,15 @@ Error Box_uncC::write(StreamWriter& writer) const
 
 static Error uncompressed_image_type_is_supported(std::shared_ptr<Box_uncC>& uncC, std::shared_ptr<Box_cmpd>& cmpd)
 {
+  const auto cmpd_components = cmpd->get_components();
   for (Box_uncC::Component component : uncC->get_components()) {
     uint16_t component_index = component.component_index;
-    uint16_t component_type = cmpd->get_components()[component_index].component_type;
+    const auto& cmpd_components = cmpd->get_components();
+    if (component_index >= cmpd_components.size()) {
+      // Malformed cmpd: skip this component instead of failing.
+      continue;
+    }
+    uint16_t component_type = cmpd_components[component_index].component_type;
     if (component_type > 7) {
       std::stringstream sstr;
       sstr << "Uncompressed image with component_type " << ((int) component_type) << " is not implemented yet";
@@ -464,9 +470,16 @@ static Error get_heif_chroma_uncompressed(std::shared_ptr<Box_uncC>& uncC, std::
   // each 1-bit represents an existing component in the image
   uint16_t componentSet = 0;
 
+  const auto cmpd_components = cmpd->get_components();
+
   for (Box_uncC::Component component : uncC->get_components()) {
     uint16_t component_index = component.component_index;
-    uint16_t component_type = cmpd->get_components()[component_index].component_type;
+    const auto& cmpd_components = cmpd->get_components();
+    if (component_index >= cmpd_components.size()) {
+      // Malformed cmpd: skip this component instead of failing.
+      continue;
+    }
+    uint16_t component_type = cmpd_components[component_index].component_type;
 
     if (component_type > component_type_max_valid) {
       std::stringstream sstr;
@@ -534,7 +547,13 @@ int UncompressedImageCodec::get_luma_bits_per_pixel_from_configuration_unci(cons
   int alternate_channel_bits = 0;
   for (Box_uncC::Component component : uncC_box->get_components()) {
     uint16_t component_index = component.component_index;
-    auto component_type = cmpd_box->get_components()[component_index].component_type;
+    // Defensive: ensure component_index is within bounds of the cmpd components vector.
+    const auto& cmpd_components_box = cmpd_box->get_components();
+    if (component_index >= cmpd_components_box.size()) {
+      // Malformed file: skip this component instead of crashing.
+      continue;
+    }
+    auto component_type = cmpd_components_box[component_index].component_type;
     switch (component_type) {
       case component_type_monochrome:
       case component_type_red:
@@ -679,37 +698,55 @@ Error UncompressedImageCodec::decode_uncompressed_image(const std::shared_ptr<co
   std::map<heif_channel, uint32_t> channel_to_pixelOffset;
 
   uint32_t componentOffset = 0;
+  const auto cmpd_components = cmpd->get_components();
   for (Box_uncC::Component component : uncC->get_components()) {
     uint16_t component_index = component.component_index;
-    uint16_t component_type = cmpd->get_components()[component_index].component_type;
+    const auto& cmpd_components = cmpd->get_components();
+    if (component_index >= cmpd_components.size()) {
+      // Malformed cmpd: skip this component instead of failing.
+      continue;
+    }
+    uint16_t component_type = cmpd_components[component_index].component_type;
     if (component_type == component_type_Y ||
         component_type == component_type_monochrome) {
-      img->add_plane(heif_channel_Y, width, height, component.component_bit_depth);
+      if (!img->add_plane(heif_channel_Y, width, height, component.component_bit_depth)) {
+          return Error(heif_error_Memory_allocation_error, heif_suberror_Unspecified, "Failed to allocate image plane");
+        }
       channels.push_back(heif_channel_Y);
       channel_to_pixelOffset.emplace(heif_channel_Y, componentOffset);
     }
     else if (component_type == component_type_Cb) {
-      img->add_plane(heif_channel_Cb, width, height, component.component_bit_depth);
+      if (!img->add_plane(heif_channel_Cb, width, height, component.component_bit_depth)) {
+          return Error(heif_error_Memory_allocation_error, heif_suberror_Unspecified, "Failed to allocate image plane");
+        }
       channels.push_back(heif_channel_Cb);
       channel_to_pixelOffset.emplace(heif_channel_Cb, componentOffset);
     }
     else if (component_type == component_type_Cr) {
-      img->add_plane(heif_channel_Cr, width, height, component.component_bit_depth);
+      if (!img->add_plane(heif_channel_Cr, width, height, component.component_bit_depth)) {
+          return Error(heif_error_Memory_allocation_error, heif_suberror_Unspecified, "Failed to allocate image plane");
+        }
       channels.push_back(heif_channel_Cr);
       channel_to_pixelOffset.emplace(heif_channel_Cr, componentOffset);
     }
     else if (component_type == component_type_red) {
-      img->add_plane(heif_channel_R, width, height, component.component_bit_depth);
+      if (!img->add_plane(heif_channel_R, width, height, component.component_bit_depth)) {
+          return Error(heif_error_Memory_allocation_error, heif_suberror_Unspecified, "Failed to allocate image plane");
+        }
       channels.push_back(heif_channel_R);
       channel_to_pixelOffset.emplace(heif_channel_R, componentOffset);
     }
     else if (component_type == component_type_green) {
-      img->add_plane(heif_channel_G, width, height, component.component_bit_depth);
+      if (!img->add_plane(heif_channel_G, width, height, component.component_bit_depth)) {
+          return Error(heif_error_Memory_allocation_error, heif_suberror_Unspecified, "Failed to allocate image plane");
+        }
       channels.push_back(heif_channel_G);
       channel_to_pixelOffset.emplace(heif_channel_G, componentOffset);
     }
     else if (component_type == component_type_blue) {
-      img->add_plane(heif_channel_B, width, height, component.component_bit_depth);
+      if (!img->add_plane(heif_channel_B, width, height, component.component_bit_depth)) {
+          return Error(heif_error_Memory_allocation_error, heif_suberror_Unspecified, "Failed to allocate image plane");
+        }
       channels.push_back(heif_channel_B);
       channel_to_pixelOffset.emplace(heif_channel_B, componentOffset);
     }