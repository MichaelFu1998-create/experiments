diff --git a/applications/mp4box/mp4box.c b/applications/mp4box/mp4box.c
index d79aee64d..739fa4a7d 100644
--- a/applications/mp4box/mp4box.c
+++ b/applications/mp4box/mp4box.c
@@ -6237,7 +6237,7 @@ int mp4box_main(int argc, char **argv)
 
 	if (dash_duration) {
 		e = do_dash();
-		if (e) return mp4box_cleanup(1);
+		if (e) { M4_LOG(GF_LOG_ERROR, ("Error DASHing file: %s\n", gf_error_to_string(e))); return mp4box_cleanup(0); }
 		goto exit;
 	}
 
diff --git a/src/media_tools/avilib.c b/src/media_tools/avilib.c
index 7cdca7d87..f1ec3a271 100644
--- a/src/media_tools/avilib.c
+++ b/src/media_tools/avilib.c
@@ -1884,6 +1884,11 @@ avi_t *AVI_open_fd(FILE *fd, int getIndex)
 
 int avi_parse_input_file(avi_t *AVI, int getIndex)
 {
+    /* locally override ERR_EXIT to free hdrl_data to avoid leaks */
+    #undef ERR_EXIT
+#define ERR_EXIT(x) { if (hdrl_data) { gf_free(hdrl_data); hdrl_data = NULL; } AVI_close(AVI); AVI_errno = x; return 0; }
+#define RETURN_MINUS1 { if (hdrl_data) { gf_free(hdrl_data); hdrl_data = NULL; } return -1; }
+
 	int rate, scale, idx_type;
 	s64 n, i;
 	unsigned char *hdrl_data;
@@ -1926,7 +1931,7 @@ int avi_parse_input_file(avi_t *AVI, int getIndex)
 		newpos = gf_ftell(AVI->fdes);
 		if(oldpos==newpos) {
 			/* This is a broken AVI stream... */
-			return -1;
+			RETURN_MINUS1;
 		}
 		oldpos=newpos;
 
@@ -2034,7 +2039,7 @@ int avi_parse_input_file(avi_t *AVI, int getIndex)
 
 						if(AVI->anum > AVI_MAX_TRACKS) {
 							GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[avilib] error - only %d audio tracks supported\n", AVI_MAX_TRACKS));
-							return(-1);
+							RETURN_MINUS1;
 						}
 
 						AVI->track[AVI->aptr].audio_bytes = str2ulong(hdrl_data+i+32)*avi_sampsize(AVI, 0);
@@ -2056,7 +2061,7 @@ int avi_parse_input_file(avi_t *AVI, int getIndex)
 					}
 					else if (strnicmp ((char*)hdrl_data+i,"iavs",4) ==0 && ! auds_strh_seen) {
 						GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[avilib] AVILIB: error - DV AVI Type 1 no supported\n"));
-						return (-1);
+						ERR_EXIT(AVI_ERR_NO_AVI)
 					}
 					else
 						lasttag = 0;
@@ -2076,12 +2081,17 @@ int avi_parse_input_file(avi_t *AVI, int getIndex)
 					{
 						alBITMAPINFOHEADER bih;
 
-						memcpy(&bih, hdrl_data + i, sizeof(alBITMAPINFOHEADER));
-						AVI->bitmap_info_header = (alBITMAPINFOHEADER *)
-						                          gf_malloc(str2ulong((unsigned char *)&bih.bi_size));
-						if (AVI->bitmap_info_header != NULL)
-							memcpy(AVI->bitmap_info_header, hdrl_data + i,
-							       str2ulong((unsigned char *)&bih.bi_size));
+				/* ensure enough data to read BITMAPINFOHEADER */
+				if ((u32)(hdrl_len - i) < (u32)sizeof(alBITMAPINFOHEADER)) ERR_EXIT(AVI_ERR_READ)
+				memcpy(&bih, hdrl_data + i, sizeof(alBITMAPINFOHEADER));
+				/* bih.bi_size is untrusted, bound it by the declared chunk size 'n' */
+				u32 bih_size = str2ulong((unsigned char *)&bih.bi_size);
+				if (bih_size == 0) bih_size = sizeof(alBITMAPINFOHEADER);
+				if (bih_size > (u32)n || (u32)i + bih_size > (u32)hdrl_len) ERR_EXIT(AVI_ERR_READ)
+				AVI->bitmap_info_header = (alBITMAPINFOHEADER *) gf_malloc(bih_size);
+				if (AVI->bitmap_info_header != NULL)
+					memcpy(AVI->bitmap_info_header, hdrl_data + i, bih_size);
+
 
 						AVI->width  = str2ulong(hdrl_data+i+4);
 						AVI->height = str2ulong(hdrl_data+i+8);
@@ -2616,7 +2626,7 @@ multiple_riff:
 				if (!AVI->track[j].audio_index) {
 					GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[avilib] Internal error in avilib -- no mem\n"));
 					AVI_errno = AVI_ERR_NO_MEM;
-					return -1;
+					RETURN_MINUS1;
 				}
 			}