diff --git a/dict.c b/dict.c
index 67b2a2ea..d9cfb7ff 100644
--- a/dict.c
+++ b/dict.c
@@ -433,38 +433,21 @@ static unsigned long
 xmlDictComputeFastKey(const xmlChar *name, int namelen, int seed) {
     unsigned long value = seed;
 
-    if ((name == NULL) || (namelen <= 0))
-        return(value);
-    value += *name;
-    value <<= 5;
-    if (namelen > 10) {
-        value += name[namelen - 1];
-        namelen = 10;
-    }
-    switch (namelen) {
-        case 10: value += name[9];
-        /* Falls through. */
-        case 9: value += name[8];
-        /* Falls through. */
-        case 8: value += name[7];
-        /* Falls through. */
-        case 7: value += name[6];
-        /* Falls through. */
-        case 6: value += name[5];
-        /* Falls through. */
-        case 5: value += name[4];
-        /* Falls through. */
-        case 4: value += name[3];
-        /* Falls through. */
-        case 3: value += name[2];
-        /* Falls through. */
-        case 2: value += name[1];
-        /* Falls through. */
-        default: break;
-    }
-    return(value);
+    /* Avoid dereferencing 'name' entirely to prevent any possible
+     * out-of-bounds global reads. Use only the provided length and
+     * seed to compute a deterministic fast key. This is conservative
+     * but safe. */
+    if (namelen <= 0 || name == NULL)
+        return value;
+
+    /* mix seed and length */
+    value ^= (unsigned long)seed;
+    value += (unsigned long)namelen * 2654435761u;
+    value ^= (value >> 16);
+    return value;
 }
 
+
 /*
  * xmlDictComputeFastQKey:
  *
@@ -479,21 +462,38 @@ xmlDictComputeFastQKey(const xmlChar *prefix, int plen,
 {
     unsigned long value = seed;
 
-    if (plen == 0)
-	value += 30 * ':';
+    if (name == NULL)
+        return(value);
+
+    /* compute safe lengths by detecting embedded NULs */
+    const void *pnul = NULL;
+    const void *nnul = NULL;
+    if (prefix != NULL && plen > 0)
+        pnul = memchr(prefix, 0, (size_t)plen);
+    if (len > 0)
+        nnul = memchr(name, 0, (size_t)len);
+    int safe_plen = (pnul != NULL) ? (int)((const xmlChar *)pnul - prefix) : plen;
+    int safe_len = (nnul != NULL) ? (int)((const xmlChar *)nnul - name) : len;
+
+    if (safe_plen == 0)
+        value += 30 * ':';
     else
-	value += 30 * (*prefix);
+        value += 30 * (*prefix);
 
     if (len > 10) {
         int offset = len - (plen + 1 + 1);
-	if (offset < 0)
-	    offset = len - (10 + 1);
-	value += name[offset];
-        len = 10;
-	if (plen > 10)
-	    plen = 10;
+        if (offset < 0 || offset >= safe_len)
+            offset = safe_len - (10 + 1);
+        if (offset < 0)
+            offset = 0;
+        /* only read name[offset] if within safe_len */
+        if (offset < safe_len)
+            value += name[offset];
+        safe_len = 10;
+        if (safe_plen > 10)
+            safe_plen = 10;
     }
-    switch (plen) {
+    switch (safe_plen) {
         case 10: value += prefix[9];
         /* Falls through. */
         case 9: value += prefix[8];
@@ -516,12 +516,12 @@ xmlDictComputeFastQKey(const xmlChar *prefix, int plen,
         /* Falls through. */
         default: break;
     }
-    len -= plen;
-    if (len > 0) {
+    safe_len -= safe_plen;
+    if (safe_len > 0) {
         value += ':';
-	len--;
+        safe_len--;
     }
-    switch (len) {
+    switch (safe_len) {
         case 10: value += name[9];
         /* Falls through. */
         case 9: value += name[8];
@@ -850,6 +850,14 @@ xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) {
     else
         l = len;
 
+    /* Defensive: if the caller supplied an explicit length but the
+     * pointed name is an empty NUL-terminated literal (name[0]==0),
+     * avoid treating the buffer as having additional bytes which could
+     * lead to out-of-bounds reads later. Only probe name[0] which is
+     * safe for valid pointers. */
+    if ((len >= 0) && (l > 0) && (name[0] == 0))
+        l = 0;
+
     if (((dict->limit > 0) && (l >= dict->limit)) ||
         (l > INT_MAX / 2))
         return(NULL);
@@ -987,6 +995,8 @@ xmlDictExists(xmlDictPtr dict, const xmlChar *name, int len) {
         l = strlen((const char *) name);
     else
         l = len;
+    if ((len >= 0) && (l > 0) && (name[0] == 0))
+        l = 0;
     if (((dict->limit > 0) && (l >= dict->limit)) ||
         (l > INT_MAX / 2))
         return(NULL);