diff --git a/src/filters/reframe_mpgvid.c b/src/filters/reframe_mpgvid.c
index 308546f28..55c93a45e 100644
--- a/src/filters/reframe_mpgvid.c
+++ b/src/filters/reframe_mpgvid.c
@@ -580,17 +580,24 @@ GF_Err mpgviddmx_process(GF_Filter *filter)
 	//we stored some data to find the complete vosh, aggregate this packet with current one
 	if (!ctx->resume_from && ctx->hdr_store_size) {
 		if (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size) {
-			ctx->hdr_store_alloc = ctx->hdr_store_size + pck_size;
-			ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);
-		}
-		memcpy(ctx->hdr_store + ctx->hdr_store_size, data, sizeof(char)*pck_size);
-		if (byte_offset != GF_FILTER_NO_BO) {
-			if (byte_offset >= ctx->hdr_store_size)
-				byte_offset -= ctx->hdr_store_size;
-			else
-				byte_offset = GF_FILTER_NO_BO;
+			/* allocate new buffer and adjust data pointer if it pointed into old buffer */
+			u32 _mpg_bytes = (u32) pck_size;
+			u32 _mpg_new_alloc = ctx->hdr_store_size + _mpg_bytes;
+			char *_mpg_old_store = ctx->hdr_store;
+			char *_mpg_new_store = gf_realloc(ctx->hdr_store, sizeof(char)*_mpg_new_alloc);
+			if (!_mpg_new_store) return GF_OUT_OF_MEM;
+			/* if data pointed into old store, compute equivalent pointer into new store */
+			if (_mpg_old_store && data >= _mpg_old_store && data < _mpg_old_store + ctx->hdr_store_size) {
+				size_t _mpg_off = (size_t)(data - _mpg_old_store);
+				data = _mpg_new_store + _mpg_off;
+			}
+			/* copy new bytes into new buffer */
+			memcpy(_mpg_new_store + ctx->hdr_store_size, data, (size_t)_mpg_bytes);
+			ctx->hdr_store = _mpg_new_store;
+			ctx->hdr_store_alloc = _mpg_new_alloc;
 		}
 		ctx->hdr_store_size += pck_size;
+
 		start = data = ctx->hdr_store;
 		remain = pck_size = ctx->hdr_store_size;
 	}
@@ -807,10 +814,17 @@ GF_Err mpgviddmx_process(GF_Filter *filter)
 					if (vosh_start<0) vosh_start = 0;
 					if (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {
 						ctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - vosh_start);
-						ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);
-					}
-					memcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );
-					ctx->hdr_store_size += pck_size - (u32) vosh_start;
+	u32 _mpg_bytes = (u32) (pck_size - vosh_start);
+	u32 _mpg_new_alloc = ctx->hdr_store_size + _mpg_bytes;
+	char *_mpg_new_store = gf_realloc(ctx->hdr_store, sizeof(char)*_mpg_new_alloc);
+	if (!_mpg_new_store) return GF_OUT_OF_MEM;
+	char *_mpg_src;
+	if ((void*)(data + vosh_start) == (void*)ctx->hdr_store) _mpg_src = _mpg_new_store + (u32)vosh_start; else _mpg_src = data + vosh_start;
+	memcpy(_mpg_new_store + ctx->hdr_store_size, _mpg_src, (size_t)_mpg_bytes);
+	ctx->hdr_store = _mpg_new_store;
+	ctx->hdr_store_alloc = _mpg_new_alloc;
+	ctx->hdr_store_size += _mpg_bytes;
+}
 					gf_filter_pid_drop_packet(ctx->ipid);
 					return GF_OK;
 				} else if (e != GF_OK) {
@@ -846,10 +860,17 @@ GF_Err mpgviddmx_process(GF_Filter *filter)
 					if (vosh_start<0) vosh_start = 0;
 					if (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {
 						ctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - (u32) vosh_start);
-						ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);
-					}
-					memcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );
-					ctx->hdr_store_size += pck_size - (u32) vosh_start;
+	u32 _mpg_bytes = (u32) (pck_size - vosh_start);
+	u32 _mpg_new_alloc = ctx->hdr_store_size + _mpg_bytes;
+	char *_mpg_new_store = gf_realloc(ctx->hdr_store, sizeof(char)*_mpg_new_alloc);
+	if (!_mpg_new_store) return GF_OUT_OF_MEM;
+	char *_mpg_src;
+	if ((void*)(data + vosh_start) == (void*)ctx->hdr_store) _mpg_src = _mpg_new_store + (u32)vosh_start; else _mpg_src = data + vosh_start;
+	memcpy(_mpg_new_store + ctx->hdr_store_size, _mpg_src, (size_t)_mpg_bytes);
+	ctx->hdr_store = _mpg_new_store;
+	ctx->hdr_store_alloc = _mpg_new_alloc;
+	ctx->hdr_store_size += _mpg_bytes;
+}
 					gf_filter_pid_drop_packet(ctx->ipid);
 					return GF_OK;
 				} else if (e != GF_OK) {
@@ -1233,5 +1254,3 @@ const GF_FilterRegister *mpgviddmx_register(GF_FilterSession *session)
 	return NULL;
 }
 #endif // GPAC_DISABLE_AV_PARSERS
-
-