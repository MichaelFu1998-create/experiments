diff --git a/src/isomedia/stbl_write.c b/src/isomedia/stbl_write.c
index 843a30857..ccf045644 100644
--- a/src/isomedia/stbl_write.c
+++ b/src/isomedia/stbl_write.c
@@ -1630,24 +1630,65 @@ GF_Err stbl_AppendSize(GF_SampleTableBox *stbl, u32 size, u32 nb_pack)
 		stbl->SampleSize->sampleCount += nb_pack;
 		return GF_OK;
 	}
-	if (!stbl->SampleSize->sizes || (stbl->SampleSize->sampleCount+nb_pack > stbl->SampleSize->alloc_size)) {
+	{
+		/* ensure we have enough space for the new samples; compute required count first */
+		u32 needed = stbl->SampleSize->sampleCount + nb_pack;
 		Bool init_table = (stbl->SampleSize->sizes==NULL) ? 1 : 0;
-		ALLOC_INC(stbl->SampleSize->alloc_size);
-		if (stbl->SampleSize->sampleCount+nb_pack > stbl->SampleSize->alloc_size)
-			stbl->SampleSize->alloc_size = stbl->SampleSize->sampleCount+nb_pack;
-
+		/* if current alloc is insufficient, grow it safely */
+		if (stbl->SampleSize->alloc_size < needed) {
+			u32 new_alloc = stbl->SampleSize->alloc_size ? stbl->SampleSize->alloc_size : 1;
+			/* grow until we fit 'needed', using same growth policy as ALLOC_INC but checked */
+			while (new_alloc < needed) {
+				u32 prev = new_alloc;
+				if (new_alloc < 10) new_alloc = 100;
+				else {
+					/* multiply by 3/2 but check overflow */
+					u64 tmp = (u64)new_alloc * 3 / 2;
+					if (tmp <= new_alloc || tmp > 0xFFFFFFFFu) {
+						new_alloc = needed; /* fallback */
+						break;
+					}
+					new_alloc = (u32)tmp;
+				}
+				/* sanity: if no progress, break to avoid infinite loop */
+				if (new_alloc <= prev) { new_alloc = needed; break; }
+			}
+			if (new_alloc < needed) new_alloc = needed;
+			/* guard multiplication overflow for allocation size in bytes */
+			if (new_alloc > (SIZE_MAX / sizeof(u32))) return GF_OUT_OF_MEM;
+			/* perform realloc into temp pointer and update struct only on success */
+			u32 *tmp = (u32 *)gf_realloc(stbl->SampleSize->sizes, sizeof(u32)*new_alloc);
+			if (!tmp) return GF_OUT_OF_MEM;
+			/* zero newly allocated area */
+			if (new_alloc > stbl->SampleSize->sampleCount)
+				memset(&tmp[stbl->SampleSize->sampleCount], 0, sizeof(u32) * (new_alloc - stbl->SampleSize->sampleCount));
+			stbl->SampleSize->sizes = tmp;
+			stbl->SampleSize->alloc_size = new_alloc;
+			if (init_table) {
+				for (i=0; i<stbl->SampleSize->sampleCount; i++)
+					stbl->SampleSize->sizes[i] = stbl->SampleSize->sampleSize;
+			}
+		}
+	}
+	stbl->SampleSize->sampleSize = 0;
+	/* defensive check: ensure realloc provided enough space for nb_pack entries */
+	if (stbl->SampleSize->sampleCount + nb_pack > stbl->SampleSize->alloc_size) {
+		u32 needed2 = stbl->SampleSize->sampleCount + nb_pack;
+		/* try to grow to needed2 */
+		if (needed2 > (SIZE_MAX / sizeof(u32))) return GF_OUT_OF_MEM;
+		stbl->SampleSize->alloc_size = needed2;
 		stbl->SampleSize->sizes = (u32 *)gf_realloc(stbl->SampleSize->sizes, sizeof(u32)*stbl->SampleSize->alloc_size);
 		if (!stbl->SampleSize->sizes) return GF_OUT_OF_MEM;
 		memset(&stbl->SampleSize->sizes[stbl->SampleSize->sampleCount], 0, sizeof(u32) * (stbl->SampleSize->alloc_size - stbl->SampleSize->sampleCount) );
-
-		if (init_table) {
-			for (i=0; i<stbl->SampleSize->sampleCount; i++)
-				stbl->SampleSize->sizes[i] = stbl->SampleSize->sampleSize;
-		}
 	}
-	stbl->SampleSize->sampleSize = 0;
 	for (i=0; i<nb_pack; i++) {
-		stbl->SampleSize->sizes[stbl->SampleSize->sampleCount+i] = size;
+		u32 idx = stbl->SampleSize->sampleCount + i;
+		/* If we still don't have enough space, refuse to append to avoid OOB */
+		if (idx >= stbl->SampleSize->alloc_size) {
+			/* allocation failed or overflow - avoid OOB write */
+			return GF_OUT_OF_MEM;
+		}
+		stbl->SampleSize->sizes[idx] = size;
 	}
 	stbl->SampleSize->sampleCount += nb_pack;
 	if (size > stbl->SampleSize->max_size)