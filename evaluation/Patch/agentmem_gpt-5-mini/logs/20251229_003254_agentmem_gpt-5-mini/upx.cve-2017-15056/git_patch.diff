diff --git a/src/p_lx_elf.cpp b/src/p_lx_elf.cpp
index 822a7652..430c9333 100644
--- a/src/p_lx_elf.cpp
+++ b/src/p_lx_elf.cpp
@@ -238,6 +238,43 @@ PackLinuxElf32::PackLinuxElf32help1(InputFile *f)
     e_phoff = get_te32(&ehdri.e_phoff);
     e_shoff = get_te32(&ehdri.e_shoff);
     sz_phdrs = e_phnum * e_phentsize;
+    /* Validate program header table fits within input file to avoid mapping out-of-range pointers. */
+    if (f) {
+        upx_uint64_t const req = (upx_uint64_t)e_phoff + (upx_uint64_t)sz_phdrs;
+        if (req > (upx_uint64_t)file_size) {
+            /* Malformed ELF: avoid using phdri/shdri. */
+            e_phoff = 0;
+            e_shoff = 0;
+            sz_phdrs = 0;
+            phdri = NULL;
+            shdri = NULL;
+            return;
+        }
+    }
+    // Validate that program header table lies within the file image.
+    {
+        upx_uint64_t const req = (upx_uint64_t)e_phoff + (upx_uint64_t)sz_phdrs;
+        if (f && req > (upx_uint64_t)file_size) {
+            // Malformed headers: avoid mapping/using phdri to prevent OOB reads.
+            e_phoff = 0;
+            e_shoff = 0;
+            sz_phdrs = 0;
+            phdri = NULL;
+            return;
+        }
+    }
+    // Validate that program header table lies within the file image.
+    {
+        upx_uint64_t const req = (upx_uint64_t)e_phoff + (upx_uint64_t)sz_phdrs;
+        if (f && req > (upx_uint64_t)file_size) {
+            // Malformed headers: avoid mapping/using phdri to prevent OOB reads.
+            e_phoff = 0;
+            e_shoff = 0;
+            sz_phdrs = 0;
+            phdri = NULL;
+            return;
+        }
+    }
 
     if (f && Elf32_Ehdr::ET_DYN!=e_type) {
         unsigned const len = sz_phdrs + e_phoff;
@@ -602,6 +639,19 @@ PackLinuxElf64::PackLinuxElf64help1(InputFile *f)
     e_phoff = get_te64(&ehdri.e_phoff);
     e_shoff = get_te64(&ehdri.e_shoff);
     sz_phdrs = e_phnum * e_phentsize;
+    /* Validate program header table fits within input file to avoid mapping out-of-range pointers. */
+    if (f) {
+        upx_uint64_t const req = (upx_uint64_t)e_phoff + (upx_uint64_t)sz_phdrs;
+        if (req > (upx_uint64_t)file_size) {
+            /* Malformed ELF: avoid using phdri/shdri. */
+            e_phoff = 0;
+            e_shoff = 0;
+            sz_phdrs = 0;
+            phdri = NULL;
+            shdri = NULL;
+            return;
+        }
+    }
 
     if (f && Elf64_Ehdr::ET_DYN!=e_type) {
         unsigned const len = sz_phdrs + e_phoff;
@@ -1395,7 +1445,17 @@ PackLinuxElf64arm::buildLoader(const Filter *ft)
 Elf32_Phdr const *
 PackLinuxElf32::elf_find_ptype(unsigned type, Elf32_Phdr const *phdr, unsigned phnum)
 {
-    for (unsigned j = 0; j < phnum; ++j, ++phdr) {
+    if (phdr == NULL || phnum == 0)
+        return 0;
+    unsigned max_entries = phnum;
+    if (e_phnum && e_phnum < max_entries)
+        max_entries = e_phnum;
+    if (sz_phdrs) {
+        unsigned cap = sz_phdrs / sizeof(Elf32_Phdr);
+        if (cap < max_entries)
+            max_entries = cap;
+    }
+    for (unsigned j = 0; j < max_entries; ++j, ++phdr) {
         if (type == get_te32(&phdr->p_type)) {
             return phdr;
         }
@@ -1406,7 +1466,17 @@ PackLinuxElf32::elf_find_ptype(unsigned type, Elf32_Phdr const *phdr, unsigned p
 Elf64_Phdr const *
 PackLinuxElf64::elf_find_ptype(unsigned type, Elf64_Phdr const *phdr, unsigned phnum)
 {
-    for (unsigned j = 0; j < phnum; ++j, ++phdr) {
+    if (phdr == NULL || phnum == 0)
+        return 0;
+    unsigned max_entries = phnum;
+    if (e_phnum && e_phnum < max_entries)
+        max_entries = e_phnum;
+    if (sz_phdrs) {
+        unsigned cap = sz_phdrs / sizeof(Elf64_Phdr);
+        if (cap < max_entries)
+            max_entries = cap;
+    }
+    for (unsigned j = 0; j < max_entries; ++j, ++phdr) {
         if (type == get_te32(&phdr->p_type)) {
             return phdr;
         }
@@ -3831,7 +3901,7 @@ void PackLinuxElf64::unpack(OutputFile *fo)
 
     // Packed ET_EXE has no PT_DYNAMIC.
     // Packed ET_DYN has original PT_DYNAMIC for info needed by rtld.
-    bool const is_shlib = !!elf_find_ptype(Elf64_Phdr::PT_DYNAMIC, phdri, c_phnum);
+    bool const is_shlib = (phdri != NULL && c_phnum != 0) ? !!elf_find_ptype(Elf64_Phdr::PT_DYNAMIC, phdri, c_phnum) : false;
     if (is_shlib) {
         // Unpack and output the Ehdr and Phdrs for real.
         // This depends on position within input file fi.
@@ -3849,7 +3919,10 @@ void PackLinuxElf64::unpack(OutputFile *fo)
         // Search the Phdrs of compressed
         int n_ptload = 0;
         phdr = (Elf64_Phdr *) (void *) (1+ (Elf64_Ehdr *)(unsigned char *)ibuf);
-        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {
+        unsigned max_phdrs = u_phnum;
+            unsigned cap = ph.u_len / sizeof(Elf64_Phdr);
+            if (cap < max_phdrs) max_phdrs = cap;
+            for (unsigned j=0; j < max_phdrs; ++phdr, ++j) {
             if (PT_LOAD64==get_te32(&phdr->p_type) && 0!=n_ptload++) {
                 old_data_off = get_te64(&phdr->p_offset);
                 old_data_len = get_te64(&phdr->p_filesz);
@@ -3876,7 +3949,10 @@ void PackLinuxElf64::unpack(OutputFile *fo)
         // Decompress each PT_LOAD.
         bool first_PF_X = true;
         phdr = (Elf64_Phdr *) (void *) (1+ ehdr);  // uncompressed
-        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {
+        unsigned max_phdrs = u_phnum;
+            unsigned cap = ph.u_len / sizeof(Elf64_Phdr);
+            if (cap < max_phdrs) max_phdrs = cap;
+            for (unsigned j=0; j < max_phdrs; ++phdr, ++j) {
             if (PT_LOAD64==get_te32(&phdr->p_type)) {
                 unsigned const filesz = get_te64(&phdr->p_filesz);
                 unsigned const offset = get_te64(&phdr->p_offset);
@@ -3894,12 +3970,15 @@ void PackLinuxElf64::unpack(OutputFile *fo)
             }
         }
     }
-    phdr = phdri;
     load_va = 0;
-    for (unsigned j=0; j < c_phnum; ++j) {
-        if (PT_LOAD64==get_te32(&phdr->p_type)) {
-            load_va = get_te64(&phdr->p_vaddr);
-            break;
+    if (phdri) {
+        phdr = phdri;
+        for (unsigned j=0; j < c_phnum; ++j) {
+            if (PT_LOAD64==get_te32(&phdr->p_type)) {
+                load_va = get_te64(&phdr->p_vaddr);
+                break;
+            }
+            ++phdr;
         }
     }
     if (is_shlib
@@ -4445,6 +4524,10 @@ void PackLinuxElf32::unpack(OutputFile *fo)
     fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);
 
     unsigned const u_phnum = get_te16(&ehdr->e_phnum);
+    unsigned max_phdrs = u_phnum;
+    unsigned cap = ph.u_len / sizeof(Elf32_Phdr);
+    if (cap < max_phdrs) max_phdrs = cap;
+
     unsigned total_in = 0;
     unsigned total_out = 0;
     unsigned c_adler = upx_adler32(NULL, 0);
@@ -4452,7 +4535,7 @@ void PackLinuxElf32::unpack(OutputFile *fo)
 
     // Packed ET_EXE has no PT_DYNAMIC.
     // Packed ET_DYN has original PT_DYNAMIC for info needed by rtld.
-    bool const is_shlib = !!elf_find_ptype(Elf32_Phdr::PT_DYNAMIC, phdri, c_phnum);
+    bool const is_shlib = (phdri != NULL && c_phnum != 0) ? !!elf_find_ptype(Elf32_Phdr::PT_DYNAMIC, phdri, c_phnum) : false;
     if (is_shlib) {
         // Unpack and output the Ehdr and Phdrs for real.
         // This depends on position within input file fi.
@@ -4470,7 +4553,7 @@ void PackLinuxElf32::unpack(OutputFile *fo)
         // Search the Phdrs of compressed
         int n_ptload = 0;
         phdr = (Elf32_Phdr *) (void *) (1+ (Elf32_Ehdr *)(unsigned char *)ibuf);
-        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {
+        for (unsigned j = 0; j < max_phdrs; ++phdr, ++j) {
             if (PT_LOAD32==get_te32(&phdr->p_type) && 0!=n_ptload++) {
                 old_data_off = get_te32(&phdr->p_offset);
                 old_data_len = get_te32(&phdr->p_filesz);
@@ -4484,7 +4567,7 @@ void PackLinuxElf32::unpack(OutputFile *fo)
 
         // Decompress and unfilter the tail of first PT_LOAD.
         phdr = (Elf32_Phdr *) (void *) (1+ ehdr);
-        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {
+        for (unsigned j = 0; j < max_phdrs; ++phdr, ++j) {
             if (PT_LOAD32==get_te32(&phdr->p_type)) {
                 ph.u_len = get_te32(&phdr->p_filesz) - overlay_offset;
                 break;
@@ -4497,7 +4580,7 @@ void PackLinuxElf32::unpack(OutputFile *fo)
         // Decompress each PT_LOAD.
         bool first_PF_X = true;
         phdr = (Elf32_Phdr *) (void *) (1+ ehdr);  // uncompressed
-        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {
+        for (unsigned j = 0; j < max_phdrs; ++phdr, ++j) {
             if (PT_LOAD32==get_te32(&phdr->p_type)) {
                 unsigned const filesz = get_te32(&phdr->p_filesz);
                 unsigned const offset = get_te32(&phdr->p_offset);
@@ -4515,12 +4598,15 @@ void PackLinuxElf32::unpack(OutputFile *fo)
             }
         }
     }
-    phdr = phdri;
     load_va = 0;
-    for (unsigned j=0; j < c_phnum; ++j) {
-        if (PT_LOAD32==get_te32(&phdr->p_type)) {
-            load_va = get_te32(&phdr->p_vaddr);
-            break;
+    if (phdri) {
+        phdr = phdri;
+        for (unsigned j=0; j < c_phnum; ++j) {
+            if (PT_LOAD32==get_te32(&phdr->p_type)) {
+                load_va = get_te32(&phdr->p_vaddr);
+                break;
+            }
+            ++phdr;
         }
     }
     if (is_shlib
@@ -4539,12 +4625,12 @@ void PackLinuxElf32::unpack(OutputFile *fo)
     // The gaps between PT_LOAD and after last PT_LOAD
     phdr = (Elf32_Phdr *) (u.buf + sizeof(*ehdr));
     unsigned hi_offset(0);
-    for (unsigned j = 0; j < u_phnum; ++j) {
+    for (unsigned j = 0; j < max_phdrs; ++j) {
         if (PT_LOAD32==phdr[j].p_type
         &&  hi_offset < phdr[j].p_offset)
             hi_offset = phdr[j].p_offset;
     }
-    for (unsigned j = 0; j < u_phnum; ++j) {
+    for (unsigned j = 0; j < max_phdrs; ++j) {
         unsigned const size = find_LOAD_gap(phdr, j, u_phnum);
         if (size) {
             unsigned const where = get_te32(&phdr[j].p_offset) +
@@ -4575,7 +4661,7 @@ void PackLinuxElf32::unpack(OutputFile *fo)
         int n_ptload = 0;
         unsigned load_off = 0;
         phdr = (Elf32_Phdr *) (u.buf + sizeof(*ehdr));
-        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {
+        for (unsigned j = 0; j < max_phdrs; ++j, ++phdr) {
             if (PT_LOAD32==get_te32(&phdr->p_type) && 0!=n_ptload++) {
                 load_off = get_te32(&phdr->p_offset);
                 fi->seek(old_data_off, SEEK_SET);
@@ -4590,7 +4676,7 @@ void PackLinuxElf32::unpack(OutputFile *fo)
         }
         // Restore DT_INIT.d_val
         phdr = (Elf32_Phdr *) (u.buf + sizeof(*ehdr));
-        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {
+        for (unsigned j = 0; j < max_phdrs; ++j, ++phdr) {
             if (phdr->PT_DYNAMIC==get_te32(&phdr->p_type)) {
                 unsigned const dyn_off = get_te32(&phdr->p_offset);
                 unsigned const dyn_len = get_te32(&phdr->p_filesz);