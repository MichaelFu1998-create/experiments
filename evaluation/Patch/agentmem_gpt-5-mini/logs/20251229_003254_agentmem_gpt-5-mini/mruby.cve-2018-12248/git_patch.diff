diff --git a/mrbgems/mruby-fiber/src/fiber.c b/mrbgems/mruby-fiber/src/fiber.c
index 83153a9d..7a3b3065 100644
--- a/mrbgems/mruby-fiber/src/fiber.c
+++ b/mrbgems/mruby-fiber/src/fiber.c
@@ -5,7 +5,7 @@
 
 #define fiber_ptr(o) ((struct RFiber*)mrb_ptr(o))
 
-#define FIBER_STACK_INIT_SIZE 64
+#define FIBER_STACK_INIT_SIZE 1024
 #define FIBER_CI_INIT_SIZE 8
 #define CI_ACC_RESUMED -3
 
@@ -202,7 +202,22 @@ fiber_switch(mrb_state *mrb, mrb_value self, mrb_int len, const mrb_value *a, mr
     mrb_value *b, *e;
 
     if (len >= c->stend - c->stack) {
-      mrb_raise(mrb, E_FIBER_ERROR, "too many arguments to fiber");
+      /* Attempt to grow the fiber stack to accommodate arguments.
+       * The VM provides mrb_stack_extend which operates on mrb->c,
+       * so temporarily switch mrb->c to the fiber context to grow
+       * its stack. If growth still doesn't provide enough room,
+       * raise the original error.
+       */
+      struct mrb_context *save_c = mrb->c;
+      mrb->c = c;
+      /* request room for len arguments (plus receiver slot)
+       * mrb_stack_extend will increase the stack if necessary.
+       */
+      mrb_stack_extend(mrb, (int)len + 1);
+      mrb->c = save_c;
+      if (len >= c->stend - c->stack) {
+        mrb_raise(mrb, E_FIBER_ERROR, "too many arguments to fiber");
+      }
     }
     b = c->stack+1;
     e = b + len;
@@ -219,6 +234,21 @@ fiber_switch(mrb_state *mrb, mrb_value self, mrb_int len, const mrb_value *a, mr
 
   if (vmexec) {
     c->vmexec = TRUE;
+    /* Ensure the fiber context has enough stack space for the entry
+     * frame before executing the proc. mrb_vm_exec assumes the
+     * stack is large enough for the irep's nregs. Grow the stack if
+     * necessary to avoid heap-buffer-overflow when the VM copies
+     * arguments/locals (OP_ENTER and related ops).
+     */
+    {
+      struct RProc *exec_proc = c->ci[-1].proc;
+      if (exec_proc && exec_proc->body.irep) {
+        int need = exec_proc->body.irep->nregs;
+        if (need > 0) {
+          mrb_stack_extend(mrb, need);
+        }
+      }
+    }
     value = mrb_vm_exec(mrb, c->ci[-1].proc, c->ci->pc);
     mrb->c = old_c;
   }
diff --git a/src/vm.c b/src/vm.c
index 3ebdea31..767c96ae 100644
--- a/src/vm.c
+++ b/src/vm.c
@@ -1777,6 +1777,8 @@ RETRY_TRY_BLOCK:
       /* Ax             arg setup according to flags (23=5:5:1:5:5:1:1) */
       /* number of optional arguments times OP_JMP should follow */
       mrb_aspec ax = GETARG_Ax(i);
+      /* Ensure stack has enough space for callee's registers to avoid overflow when copying arguments */
+      mrb_stack_extend(mrb, irep->nregs);
       int m1 = MRB_ASPEC_REQ(ax);
       int o  = MRB_ASPEC_OPT(ax);
       int r  = MRB_ASPEC_REST(ax);