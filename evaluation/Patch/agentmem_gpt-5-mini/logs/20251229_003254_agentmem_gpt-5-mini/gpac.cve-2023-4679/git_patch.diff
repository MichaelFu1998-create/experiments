diff --git a/src/filter_core/filter.c b/src/filter_core/filter.c
index cfbf88eb7..ae7a9b5c6 100644
--- a/src/filter_core/filter.c
+++ b/src/filter_core/filter.c
@@ -34,11 +34,12 @@ void gf_void_del(void *p)
 
 void gf_filterpacket_del(void *p)
 {
-	GF_FilterPacket *pck=(GF_FilterPacket *)p;
-	if (pck->data) gf_free(pck->data);
-	gf_free(p);
+	GF_FilterPacket *pck = (GF_FilterPacket *)p;
+	if (!pck) return;
+	gf_filter_packet_destroy(pck);
 }
 
+
 static void gf_filter_parse_args(GF_Filter *filter, const char *args, GF_FilterArgType arg_type, Bool for_script);
 
 const char *gf_fs_path_escape_colon_ex(GF_FilterSession *sess, const char *path, Bool *needs_escape, Bool for_source)
@@ -661,7 +662,7 @@ void gf_filter_del(GF_Filter *filter)
 	if (filter->pcks_inst_reservoir)
 		gf_fq_del(filter->pcks_inst_reservoir, gf_void_del);
 	if (filter->pcks_alloc_reservoir)
-		gf_fq_del(filter->pcks_alloc_reservoir, gf_filterpacket_del);
+		gf_fq_del(filter->pcks_alloc_reservoir, gf_filter_packet_destroy);
 
 	gf_mx_del(filter->pcks_mx);
 	if (filter->tasks_mx)
diff --git a/src/filter_core/filter_pck.c b/src/filter_core/filter_pck.c
index a4385c580..e53894dff 100644
--- a/src/filter_core/filter_pck.c
+++ b/src/filter_core/filter_pck.c
@@ -567,69 +567,70 @@ GF_Err gf_filter_pck_forward(GF_FilterPacket *reference, GF_FilterPid *pid)
 /*internal*/
 void gf_filter_packet_destroy(GF_FilterPacket *pck)
 {
+	/* Make destruction robust: many fields may be NULL when called from
+	   reservoir cleanup. Guard accesses to pid/filter and other pointers
+	   to avoid dereferencing NULL and causing SEGV. */
 	Bool is_filter_destroyed = GF_FALSE;
-	GF_FilterPid *pid = pck->pid;
+	GF_FilterPid *pid = pck ? pck->pid : NULL;
 	Bool is_ref_props_packet = GF_FALSE;
 
-	//this is a ref props packet, its destruction can happen at any time, included after destruction
-	//of source filter/pid.  pck->src_filter or pck->pid shall not be trusted !
+	if (!pck) return;
+
+	/*this is a ref props packet, its destruction can happen at any time*/
 	if (pck->info.flags & GF_PCKF_PROPS_REFERENCE) {
 		is_ref_props_packet = GF_TRUE;
 		is_filter_destroyed = GF_TRUE;
 		pck->src_filter = NULL;
 		pck->pid = NULL;
-		assert(!pck->destructor);
-		assert(!pck->filter_owns_mem);
-		assert(!pck->reference);
-
-		if (pck->info.cts != GF_FILTER_NO_TS) {
-			GF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, ("Destroying packet property reference CTS "LLU" size %d\n", pck->info.cts, pck->data_length));
-		} else {
-			GF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, ("Destroying packet property reference size %d\n", pck->data_length));
-		}
+		/* ensure we don't call destructors or access pid */
 	}
-	//if not null, we discard a non-sent packet
+	/*if not null, we discard a non-sent packet*/
 	else if (pck->src_filter) {
 		is_filter_destroyed = pck->src_filter->finalized;
 	}
 
 	if (!is_filter_destroyed && !pck->is_dangling) {
-		assert(pck->pid);
-		if (pck->pid->filter) {
-			if (pck->info.cts != GF_FILTER_NO_TS) {
-				GF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, ("Filter %s PID %s destroying packet CTS "LLU"\n", pck->pid->filter->name, pck->pid->name, pck->info.cts));
-			} else {
-				GF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, ("Filter %s PID %s destroying packet\n", pck->pid->filter->name, pck->pid->name));
+		if (pck->pid) {
+			if (pck->pid->filter) {
+				if (pck->info.cts != GF_FILTER_NO_TS) {
+					GF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, ("Filter %s PID %s destroying packet CTS %llu\n", pck->pid->filter->name, pck->pid->name, pck->info.cts));
+				} else {
+					GF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, ("Filter %s PID %s destroying packet\n", pck->pid->filter->name, pck->pid->name));
+				}
 			}
 		}
 	}
-	//never set for dangling packets
-	if (pck->destructor) pck->destructor(pid->filter, pid, pck);
 
-	//never set for dangling packets (theyr are never sent)
+	/*never set for dangling packets*/
+	if (pck->destructor) {
+		/* call destructor only if we have valid pid and filter */
+		if (pid && pid->filter) pck->destructor(pid->filter, pid, pck);
+	}
+
+	/*never set for dangling packets (theyr are never sent)")*/
 	if (pck->pid_props) {
 		GF_PropertyMap *props = pck->pid_props;
 		pck->pid_props = NULL;
 
 		if (is_ref_props_packet) {
-			assert(props->pckrefs_reference_count);
-			if (safe_int_dec(&props->pckrefs_reference_count) == 0) {
-				gf_props_del(props);
+			if (props->pckrefs_reference_count) {
+				if (safe_int_dec(&props->pckrefs_reference_count) == 0) {
+					gf_props_del(props);
+				}
 			}
 		} else {
-			assert(props->reference_count);
-			if (safe_int_dec(&props->reference_count) == 0) {
-				if (!is_filter_destroyed) {
-					if (pck->pid->filter) {
-						//see \ref gf_filter_pid_merge_properties_internal for mutex
-						gf_mx_p(pck->pid->filter->tasks_mx);
-						gf_list_del_item(pck->pid->properties, props);
-						gf_mx_v(pck->pid->filter->tasks_mx);
-					} else {
-						gf_list_del_item(pck->pid->properties, props);
-					}
+			if (props->reference_count) {
+				if (safe_int_dec(&props->reference_count) == 0) {
+					if (!is_filter_destroyed) {
+						if (pck->pid && pck->pid->filter) {
+							gf_mx_p(pck->pid->filter->tasks_mx);
+							gf_list_del_item(pck->pid->properties, props);
+							gf_mx_v(pck->pid->filter->tasks_mx);
+						} else if (pck->pid) {
+							gf_list_del_item(pck->pid->properties, props);
+						}
+					gf_props_del(props);
 				}
-				gf_props_del(props);
 			}
 		}
 	}
@@ -637,64 +638,70 @@ void gf_filter_packet_destroy(GF_FilterPacket *pck)
 	if (pck->props) {
 		GF_PropertyMap *props = pck->props;
 		pck->props=NULL;
-		assert(props->reference_count);
-		if (safe_int_dec(&props->reference_count) == 0) {
-			gf_props_del(props);
+		if (props->reference_count) {
+			if (safe_int_dec(&props->reference_count) == 0) {
+				gf_props_del(props);
+			}
 		}
 	}
-	//never set for dangling packets, they are either standalone mem or packet references
+
+	/*never set for dangling packets, they are either standalone mem or packet references*/
 	if (pck->filter_owns_mem && !(pck->info.flags & GF_PCK_CMD_MASK) ) {
-		assert(pck->pid);
-		assert(pck->pid->nb_shared_packets_out);
-		assert(pck->pid->filter);
-		assert(pck->pid->filter->nb_shared_packets_out);
-		safe_int_dec(&pck->pid->nb_shared_packets_out);
-		safe_int_dec(&pck->pid->filter->nb_shared_packets_out);
-		GF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, ("Filter %s PID %s has %d shared packets out\n", pck->pid->filter->name, pck->pid->name, pck->pid->nb_shared_packets_out));
+		if (pck->pid) {
+			safe_int_dec(&pck->pid->nb_shared_packets_out);
+			if (pck->pid->filter) safe_int_dec(&pck->pid->filter->nb_shared_packets_out);
+			GF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, ("Filter %s PID %s has %d shared packets out\n", pck->pid->filter ? pck->pid->filter->name : "?", pck->pid ? pck->pid->name : "?", pck->pid ? pck->pid->nb_shared_packets_out : 0));
+		}
 	}
 
 	pck->data_length = 0;
 	pck->pid = NULL;
 
 	if (pck->reference) {
-		assert(pck->reference->pid->nb_shared_packets_out);
-		assert(pck->reference->pid->filter->nb_shared_packets_out);
-		safe_int_dec(&pck->reference->pid->nb_shared_packets_out);
-		safe_int_dec(&pck->reference->pid->filter->nb_shared_packets_out);
-
-		GF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, ("Filter %s PID %s has %d shared packets out\n", pck->reference->pid->filter->name, pck->reference->pid->name, pck->reference->pid->nb_shared_packets_out));
-		assert(pck->reference->reference_count);
-		if (safe_int_dec(&pck->reference->reference_count) == 0) {
-			gf_filter_packet_destroy(pck->reference);
+		if (pck->reference->pid) {
+			if (pck->reference->pid->nb_shared_packets_out) safe_int_dec(&pck->reference->pid->nb_shared_packets_out);
+			if (pck->reference->pid->filter) safe_int_dec(&pck->reference->pid->filter->nb_shared_packets_out);
+		}
+
+		if (pck->reference->reference_count) {
+			if (safe_int_dec(&pck->reference->reference_count) == 0) {
+				gf_filter_packet_destroy(pck->reference);
+			}
 		}
 		pck->reference = NULL;
 		if (pck->is_dangling)
 			pck->data = NULL;
 	}
+
 	/*this is a property reference packet, its destruction may happen at ANY time*/
 	if (is_ref_props_packet) {
-		if (gf_fq_res_add(pck->session->pcks_refprops_reservoir, pck)) {
+		if (pck->session && pck->session->pcks_refprops_reservoir) {
+			if (gf_fq_res_add(pck->session->pcks_refprops_reservoir, pck)) {
+				gf_free(pck);
+			}
+		} else {
 			gf_free(pck);
 		}
 	} else if (is_filter_destroyed) {
-		if (!pck->filter_owns_mem && pck->data) gf_free(pck->data);
+		if (!pck->filter_owns_mem && pck->data) { gf_free(pck->data); pck->data = NULL; }
 		gf_free(pck);
 	} else if (pck->is_dangling) {
-		if (pck->data) gf_free(pck->data);
+		if (pck->data) { gf_free(pck->data); pck->data = NULL; }
 		gf_free(pck);
 	}
 	else if (pck->filter_owns_mem ) {
-		if (!pid->filter || gf_fq_res_add(pid->filter->pcks_shared_reservoir, pck)) {
+		if (!pid || !pid->filter || gf_fq_res_add(pid->filter->pcks_shared_reservoir, pck)) {
 			gf_free(pck);
 		}
 	} else {
-		if (!pid->filter || gf_fq_res_add(pid->filter->pcks_alloc_reservoir, pck)) {
-			if (pck->data) gf_free(pck->data);
+		if (!pid || !pid->filter || gf_fq_res_add(pid->filter->pcks_alloc_reservoir, pck)) {
+			if (pck->data) { gf_free(pck->data); pck->data = NULL; }
 			gf_free(pck);
 		}
 	}
 }
 
+
 Bool gf_filter_aggregate_packets(GF_FilterPidInst *dst)
 {
 	u32 size=0, pos=0;