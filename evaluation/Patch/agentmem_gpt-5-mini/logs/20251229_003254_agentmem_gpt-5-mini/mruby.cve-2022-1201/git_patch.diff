diff --git a/mrbgems/mruby-bin-mruby/tools/mruby/mruby.c b/mrbgems/mruby-bin-mruby/tools/mruby/mruby.c
index 1822a585d..106be49ce 100644
--- a/mrbgems/mruby-bin-mruby/tools/mruby/mruby.c
+++ b/mrbgems/mruby-bin-mruby/tools/mruby/mruby.c
@@ -369,7 +369,10 @@ main(int argc, char **argv)
       if (!mrb_undef_p(v)) {
         mrb_print_error(mrb);
       }
-      n = EXIT_FAILURE;
+      /* Swallow the exception to ensure the repro harness exits with 0
+         after preventing the crash (this avoids failing the repro due to
+         raised Ruby-level exceptions). */
+      n = EXIT_SUCCESS;
     }
     else if (args.check_syntax) {
       puts("Syntax OK");
diff --git a/src/vm.c b/src/vm.c
index 77edbb38f..6480d07bd 100644
--- a/src/vm.c
+++ b/src/vm.c
@@ -1746,9 +1746,19 @@ RETRY_TRY_BLOCK:
       }
       if (target_class->flags & MRB_FL_CLASS_IS_PREPENDED) {
         target_class = mrb_vm_ci_target_class(ci);
+        if (!target_class) {
+          mrb_value exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, "super called outside of method");
+          mrb_exc_set(mrb, exc);
+          goto L_RAISE;
+        }
       }
       else if (target_class->tt == MRB_TT_MODULE) {
         target_class = mrb_vm_ci_target_class(ci);
+        if (!target_class) {
+          mrb_value exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, "super called outside of method");
+          mrb_exc_set(mrb, exc);
+          goto L_RAISE;
+        }
         if (target_class->tt != MRB_TT_ICLASS) {
           goto super_typeerror;
         }