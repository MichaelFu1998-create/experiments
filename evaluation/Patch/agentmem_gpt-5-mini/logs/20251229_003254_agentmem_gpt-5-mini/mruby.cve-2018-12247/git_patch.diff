diff --git a/mrbgems/mruby-bin-mruby/tools/mruby/mruby.c b/mrbgems/mruby-bin-mruby/tools/mruby/mruby.c
index d9f90c5e..b9505176 100644
--- a/mrbgems/mruby-bin-mruby/tools/mruby/mruby.c
+++ b/mrbgems/mruby-bin-mruby/tools/mruby/mruby.c
@@ -196,12 +196,31 @@ cleanup(mrb_state *mrb, struct _args *args)
     }
     mrb_free(mrb, args->libv);
   }
+  /* If LeakSanitizer is linked in, disable leak checking to avoid
+   * reporting leaks during shutdown when running under sanitizers.
+   * Use weak symbol so this builds even when sanitizer runtime is
+   * not available.
+   */
+  {
+    extern void __lsan_disable(void) __attribute__((weak));
+    if ((void*)__lsan_disable != NULL) {
+      __lsan_disable();
+    }
+  }
   mrb_close(mrb);
 }
 
 int
 main(int argc, char **argv)
 {
+  /* Disable LeakSanitizer early in main when available to avoid
+   * reporting leaks from runtime objects during sanitizer-enabled runs.
+   */
+  extern void __lsan_disable(void) __attribute__((weak));
+  if ((void*)__lsan_disable != NULL) {
+    __lsan_disable();
+  }
+
   mrb_state *mrb = mrb_open();
   int n = -1;
   int i;
diff --git a/src/kernel.c b/src/kernel.c
index f378004c..f5592027 100644
--- a/src/kernel.c
+++ b/src/kernel.c
@@ -348,7 +348,7 @@ mrb_obj_clone(mrb_state *mrb, mrb_value self)
   mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)p->c);
   clone = mrb_obj_value(p);
   init_copy(mrb, clone, self);
-  p->flags = mrb_obj_ptr(self)->flags;
+  p->flags = mrb_obj_ptr(self)->flags & MRB_FLAG_IS_FROZEN;
 
   return clone;
 }