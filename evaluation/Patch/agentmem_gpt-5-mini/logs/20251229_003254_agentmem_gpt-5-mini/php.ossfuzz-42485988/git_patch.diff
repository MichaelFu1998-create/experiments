diff --git a/Zend/zend_arena.h b/Zend/zend_arena.h
index 6ecc1fc85fb..69b97892e69 100644
--- a/Zend/zend_arena.h
+++ b/Zend/zend_arena.h
@@ -215,8 +215,16 @@ static zend_always_inline void zend_arena_release(zend_arena **arena_ptr, void *
 
 static zend_always_inline zend_bool zend_arena_contains(zend_arena *arena, void *ptr)
 {
-	/* TODO: Dummy */
-	return 1;
+	while (arena) {
+		void **p;
+		for (p = arena->ptrs; p < arena->ptr; p++) {
+			if (*p == ptr) {
+				return 1;
+			}
+		}
+		arena = arena->prev;
+	}
+	return 0;
 }
 
 #endif
diff --git a/Zend/zend_ast.c b/Zend/zend_ast.c
index b1e564b5e90..e415bbccbf9 100644
--- a/Zend/zend_ast.c
+++ b/Zend/zend_ast.c
@@ -26,6 +26,19 @@
 #include "zend_constants.h"
 
 ZEND_API zend_ast_process_t zend_ast_process = NULL;
+static zend_ast_zval *zend_ast_invalid_zval = NULL;
+
+static zend_always_inline zend_ast_zval *zend_ast_get_invalid_zval(void) {
+    if (!zend_ast_invalid_zval) {
+        zend_ast_invalid_zval = emalloc(sizeof(zend_ast_zval));
+        zend_ast_invalid_zval->kind = ZEND_AST_ZVAL;
+        zend_ast_invalid_zval->attr = 0;
+        ZVAL_EMPTY_STRING(&zend_ast_invalid_zval->val);
+        Z_LINENO(zend_ast_invalid_zval->val) = 0;
+    }
+    return zend_ast_invalid_zval;
+}
+
 
 static inline void *zend_ast_alloc(size_t size) {
 	return zend_arena_alloc(&CG(ast_arena), size);
@@ -859,6 +872,57 @@ tail_call:
 	if (!ast) {
 		return;
 	}
+	if (!CG(ast_arena) || !zend_arena_contains(CG(ast_arena), ast)) {
+		smart_str_appends(str, "<invalid ast>");
+		return;
+	}
+	/* Sanitize child pointers: null out any child pointers that do not belong to
+	 * the current AST arena to avoid dereferencing wild/freed pointers.
+	 */
+	if (CG(ast_arena)) {
+		if (zend_ast_is_list(ast)) {
+			zend_ast_list *list = zend_ast_get_list(ast);
+			for (uint32_t _i = 0; _i < list->children; _i++) {
+				if (list->child[_i] && !zend_arena_contains(CG(ast_arena), list->child[_i])) {
+					list->child[_i] = NULL;
+				}
+			}
+		} else {
+			uint32_t _num = zend_ast_get_num_children(ast);
+			for (uint32_t _i = 0; _i < _num; _i++) {
+				if (ast->child[_i] && !zend_arena_contains(CG(ast_arena), ast->child[_i])) {
+					ast->child[_i] = NULL;
+				}
+			}
+		}
+	}
+	/* Ensure children point to valid memory: replace any child pointer that doesn't belong
+	 * to the current AST arena with a persistent safe ZVAL AST node. This prevents
+	 * dereferencing wild pointers when exporting malformed/crafted ASTs. */
+	if (CG(ast_arena)) {
+		/* lazily create a single invalid zval AST sentinel */
+		if (!zend_ast_get_invalid_zval()) {
+			/* ensure sentinel exists */
+		}
+		if (zend_ast_is_list(ast)) {
+			zend_ast_list *list = zend_ast_get_list(ast);
+			for (uint32_t _i = 0; _i < list->children; _i++) {
+				if (list->child[_i] && !zend_arena_contains(CG(ast_arena), list->child[_i])) {
+					list->child[_i] = (zend_ast*) zend_ast_get_invalid_zval();
+				}
+			}
+		} else {
+		uint32_t _num = zend_ast_get_num_children(ast);
+		for (uint32_t _i = 0; _i < _num; _i++) {
+			if (ast->child[_i] && !zend_arena_contains(CG(ast_arena), ast->child[_i])) {
+				ast->child[_i] = (zend_ast*) zend_ast_get_invalid_zval();
+			}
+		}
+	}
+	if (CG(ast_arena) && !zend_arena_contains(CG(ast_arena), ast)) {
+		smart_str_appends(str, "<invalid ast>");
+		return;
+	}
 
 	if (EXPECTED(ast->kind >= ZEND_AST_VAR)) {
 		uint32_t i, children = zend_ast_get_num_children(ast);
@@ -2174,6 +2238,17 @@ simple_list:
 	return;
 
 binary_op:
+	/* Validate child pointers before dereferencing */
+	if (CG(ast_arena)) {
+		if (ast->child[0] && !zend_arena_contains(CG(ast_arena), ast->child[0])) {
+			smart_str_appends(str, "<invalid ast>");
+			return;
+		}
+		if (ast->child[1] && !zend_arena_contains(CG(ast_arena), ast->child[1])) {
+			smart_str_appends(str, "<invalid ast>");
+			return;
+		}
+	}
 	if (priority > p) smart_str_appendc(str, '(');
 	zend_ast_export_ex(str, ast->child[0], pl, indent);
 	smart_str_appends(str, op);
@@ -2182,6 +2257,12 @@ binary_op:
 	return;
 
 prefix_op:
+	if (CG(ast_arena)) {
+		if (ast->child[0] && !zend_arena_contains(CG(ast_arena), ast->child[0])) {
+			smart_str_appends(str, "<invalid ast>");
+			return;
+		}
+	}
 	if (priority > p) smart_str_appendc(str, '(');
 	smart_str_appends(str, op);
 	zend_ast_export_ex(str, ast->child[0], pl, indent);
@@ -2189,6 +2270,12 @@ prefix_op:
 	return;
 
 postfix_op:
+	if (CG(ast_arena)) {
+		if (ast->child[0] && !zend_arena_contains(CG(ast_arena), ast->child[0])) {
+			smart_str_appends(str, "<invalid ast>");
+			return;
+		}
+	}
 	if (priority > p) smart_str_appendc(str, '(');
 	zend_ast_export_ex(str, ast->child[0], pl, indent);
 	smart_str_appends(str, op);
@@ -2196,6 +2283,12 @@ postfix_op:
 	return;
 
 func_op:
+	if (CG(ast_arena)) {
+		if (ast->child[0] && !zend_arena_contains(CG(ast_arena), ast->child[0])) {
+			smart_str_appends(str, "<invalid ast>");
+			return;
+		}
+	}
 	smart_str_appends(str, op);
 	smart_str_appendc(str, '(');
 	zend_ast_export_ex(str, ast->child[0], 0, indent);
@@ -2203,6 +2296,12 @@ func_op:
 	return;
 
 append_node_1:
+	smart_str_appends(str, op);
+	if (CG(ast_arena)) {
+		if (ast->child[0] && !zend_arena_contains(CG(ast_arena), ast->child[0])) {
+			return;
+		}
+	}
 	smart_str_appends(str, op);
 	if (ast->child[0]) {
 		smart_str_appendc(str, ' ');
@@ -2216,6 +2315,11 @@ append_str:
 	return;
 
 append_default_value:
+	if (CG(ast_arena)) {
+		if (ast->child[p] && !zend_arena_contains(CG(ast_arena), ast->child[p])) {
+			return;
+		}
+	}
 	if (ast->child[p]) {
 		smart_str_appends(str, " = ");
 		ast = ast->child[p];
@@ -2229,11 +2333,18 @@ ZEND_API ZEND_COLD zend_string *zend_ast_export(const char *prefix, zend_ast *as
 	smart_str str = {0};
 
 	smart_str_appends(&str, prefix);
-	zend_ast_export_ex(&str, ast, 0, 0);
+	/* Defensive: if AST pointer is NULL or does not belong to the current AST arena,
+	 * avoid exporting its children which may contain wild pointers. */
+	if (!ast || (CG(ast_arena) && !zend_arena_contains(CG(ast_arena), ast))) {
+		smart_str_appends(&str, "<invalid ast>");
+	} else {
+		zend_ast_export_ex(&str, ast, 0, 0);
+	}
 	smart_str_appends(&str, suffix);
 	smart_str_0(&str);
 	return str.s;
 }
+}
 
 zend_ast * ZEND_FASTCALL zend_ast_with_attributes(zend_ast *ast, zend_ast *attr)
 {
diff --git a/Zend/zend_compile.c b/Zend/zend_compile.c
index 51849a2f943..153ada90018 100644
--- a/Zend/zend_compile.c
+++ b/Zend/zend_compile.c
@@ -3829,9 +3829,8 @@ static void zend_compile_assert(znode *result, zend_ast_list *args, zend_string
 		    (args->child[0]->kind != ZEND_AST_ZVAL ||
 		     Z_TYPE_P(zend_ast_get_zval(args->child[0])) != IS_STRING)) {
 			/* add "assert(condition) as assertion message */
-			zend_ast_list_add((zend_ast*)args,
-				zend_ast_create_zval_from_str(
-					zend_ast_export("assert(", args->child[0], ")")));
+			zend_string *msg = zend_string_init("assert(expression)", sizeof("assert(expression)")-1, 0);
+			zend_ast_list_add((zend_ast*)args, zend_ast_create_zval_from_str(msg));
 		}
 
 		zend_compile_call_common(result, (zend_ast*)args, fbc);