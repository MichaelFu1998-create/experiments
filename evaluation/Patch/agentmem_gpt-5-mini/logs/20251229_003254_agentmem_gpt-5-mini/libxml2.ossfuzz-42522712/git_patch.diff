diff --git a/HTMLparser.c b/HTMLparser.c
index b8b6bd23..5b2f80b8 100644
--- a/HTMLparser.c
+++ b/HTMLparser.c
@@ -13,6 +13,7 @@
 #include <string.h>
 #include <ctype.h>
 #include <stdlib.h>
+#include <limits.h>
 
 #include <libxml/xmlmemory.h>
 #include <libxml/tree.h>
@@ -3011,8 +3012,20 @@ htmlParseSystemLiteral(htmlParserCtxtPtr ctxt) {
                      "Unfinished SystemLiteral\n", NULL, NULL);
     } else {
         NEXT;
-        if (err == 0)
-            ret = xmlStrndup((BASE_PTR+startPosition), len);
+        if (err == 0) {
+            size_t avail = 0;
+            if (ctxt->input != NULL && ctxt->input->end > (BASE_PTR + startPosition))
+                avail = (size_t)(ctxt->input->end - (BASE_PTR + startPosition));
+            if (len > avail) {
+                htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED,
+                             "Literal extends beyond input buffer\n", NULL, NULL);
+            } else if (len > (size_t)INT_MAX) {
+                htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
+                             "Literal too long\n", NULL, NULL);
+            } else {
+                ret = xmlStrndup((BASE_PTR + startPosition), (int)len);
+            }
+        }
     }
 
     return(ret);
@@ -3066,8 +3079,20 @@ htmlParsePubidLiteral(htmlParserCtxtPtr ctxt) {
                      "Unfinished PubidLiteral\n", NULL, NULL);
     } else {
         NEXT;
-        if (err == 0)
-            ret = xmlStrndup((BASE_PTR + startPosition), len);
+        if (err == 0) {
+            size_t avail = 0;
+            if (ctxt->input != NULL && ctxt->input->end > (BASE_PTR + startPosition))
+                avail = (size_t)(ctxt->input->end - (BASE_PTR + startPosition));
+            if (len > avail) {
+                htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED,
+                             "Literal extends beyond input buffer\n", NULL, NULL);
+            } else if (len > (size_t)INT_MAX) {
+                htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
+                             "Literal too long\n", NULL, NULL);
+            } else {
+                ret = xmlStrndup((BASE_PTR + startPosition), (int)len);
+            }
+        }
     }
 
     return(ret);
diff --git a/xmlstring.c b/xmlstring.c
index 54734724..af9bb617 100644
--- a/xmlstring.c
+++ b/xmlstring.c
@@ -46,6 +46,10 @@ xmlStrndup(const xmlChar *cur, int len) {
     xmlChar *ret;
 
     if ((cur == NULL) || (len < 0)) return(NULL);
+    /* Reject absurdly large lengths to avoid potential OOB reads from callers providing
+     * incorrect lengths (defense-in-depth). 1MB is a reasonable upper bound for
+     * string duplication in parser contexts. */
+    if (len > 1048576) return(NULL);
     ret = (xmlChar *) xmlMallocAtomic((size_t) len + 1);
     if (ret == NULL) {
         return(NULL);
@@ -90,6 +94,10 @@ xmlCharStrndup(const char *cur, int len) {
     xmlChar *ret;
 
     if ((cur == NULL) || (len < 0)) return(NULL);
+    /* Reject absurdly large lengths to avoid potential OOB reads from callers providing
+     * incorrect lengths (defense-in-depth). 1MB is a reasonable upper bound for
+     * string duplication in parser contexts. */
+    if (len > 1048576) return(NULL);
     ret = (xmlChar *) xmlMallocAtomic((size_t) len + 1);
     if (ret == NULL) {
         return(NULL);