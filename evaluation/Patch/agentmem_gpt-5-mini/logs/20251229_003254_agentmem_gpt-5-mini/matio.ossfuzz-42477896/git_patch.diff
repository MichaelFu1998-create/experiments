diff --git a/src/mat.c b/src/mat.c
index 4227c9c..446bbb4 100644
--- a/src/mat.c
+++ b/src/mat.c
@@ -163,8 +163,14 @@ ComplexMalloc(size_t nbytes)
 void
 ComplexFree(mat_complex_split_t* complex_data)
 {
-    free(complex_data->Re);
-    free(complex_data->Im);
+    if ( complex_data == NULL )
+        return;
+
+    if ( complex_data->Re != NULL )
+        free(complex_data->Re);
+    if ( complex_data->Im != NULL )
+        free(complex_data->Im);
+
     free(complex_data);
 }
 
@@ -1027,8 +1033,12 @@ Mat_VarCreate(const char *name,enum matio_classes class_type,
         mat_sparse_t *sparse_data, *sparse_data_in;
 
         sparse_data_in = (mat_sparse_t*)data;
-        sparse_data    = (mat_sparse_t*)malloc(sizeof(mat_sparse_t));
+        sparse_data    = (mat_sparse_t*)calloc(1,sizeof(mat_sparse_t));
         if ( NULL != sparse_data ) {
+            sparse_data->ir = NULL;
+            sparse_data->jc = NULL;
+            sparse_data->data = NULL;
+
             sparse_data->nzmax = sparse_data_in->nzmax;
             sparse_data->nir   = sparse_data_in->nir;
             sparse_data->njc   = sparse_data_in->njc;
@@ -1351,7 +1361,7 @@ Mat_VarDuplicate(const matvar_t *in, int opt)
             inflateCopy(out->internal->z,in->internal->z);
         if ( in->internal->data != NULL ) {
             if ( in->class_type == MAT_C_SPARSE ) {
-                out->internal->data = malloc(sizeof(mat_sparse_t));
+                out->internal->data = calloc(1,sizeof(mat_sparse_t));
                 if ( out->internal->data != NULL ) {
                     mat_sparse_t *out_sparse = (mat_sparse_t*)out->internal->data;
                     mat_sparse_t *in_sparse  = (mat_sparse_t*)in->internal->data;
@@ -1433,9 +1443,14 @@ Mat_VarDuplicate(const matvar_t *in, int opt)
             }
         }
     } else if ( (in->data != NULL) && (in->class_type == MAT_C_SPARSE) ) {
-        out->data = malloc(sizeof(mat_sparse_t));
+        out->data = calloc(1,sizeof(mat_sparse_t));
         if ( out->data != NULL ) {
             mat_sparse_t *out_sparse = (mat_sparse_t*)out->data;
+            out_sparse->ir = NULL;
+            out_sparse->jc = NULL;
+            out_sparse->data = NULL;
+
+            
             mat_sparse_t *in_sparse  = (mat_sparse_t*)in->data;
             out_sparse->nzmax = in_sparse->nzmax;
             out_sparse->nir = in_sparse->nir;
diff --git a/src/mat5.c b/src/mat5.c
index 82508e7..e280089 100644
--- a/src/mat5.c
+++ b/src/mat5.c
@@ -194,6 +194,10 @@ GetTypeBufSize(matvar_t *matvar, size_t *size)
         case MAT_C_SPARSE:
         {
             mat_sparse_t *sparse = (mat_sparse_t*)matvar->data;
+            /* Initialize sparse fields to NULL to avoid freeing uninitialized pointers on error */
+            sparse->ir = NULL;
+            sparse->jc = NULL;
+            sparse->data = NULL;
 
             err = SafeMul(&data_bytes, sparse->nir, sizeof(mat_uint32_t));
             if ( data_bytes % 8 )
@@ -1831,6 +1835,10 @@ WriteType(mat_t *mat,matvar_t *matvar)
         case MAT_C_SPARSE:
         {
             mat_sparse_t *sparse = (mat_sparse_t*)matvar->data;
+            /* Initialize sparse fields to NULL to avoid freeing uninitialized pointers on error */
+            sparse->ir = NULL;
+            sparse->jc = NULL;
+            sparse->data = NULL;
 
             nBytes = WriteData(mat,sparse->ir,sparse->nir,MAT_T_UINT32);
             if ( nBytes % 8 )
@@ -2210,6 +2218,10 @@ WriteCompressedType(mat_t *mat,matvar_t *matvar,z_streamp z)
         case MAT_C_SPARSE:
         {
             mat_sparse_t *sparse = (mat_sparse_t*)matvar->data;
+            /* Initialize sparse fields to NULL to avoid freeing uninitialized pointers on error */
+            sparse->ir = NULL;
+            sparse->jc = NULL;
+            sparse->data = NULL;
 
             byteswritten += WriteCompressedData(mat,z,sparse->ir,
                 sparse->nir,MAT_T_UINT32);
@@ -3020,13 +3032,17 @@ Mat_VarRead5(mat_t *mat, matvar_t *matvar)
             mat_sparse_t *sparse;
 
             matvar->data_size = sizeof(mat_sparse_t);
-            matvar->data      = malloc(matvar->data_size);
+            matvar->data      = calloc(1, matvar->data_size);
             if ( matvar->data == NULL ) {
                 Mat_Critical("Mat_VarRead5: Allocation of data pointer failed");
                 err = 1;
                 break;
             }
             sparse = (mat_sparse_t*)matvar->data;
+            /* Initialize sparse fields to NULL to avoid freeing uninitialized pointers on error */
+            sparse->ir = NULL;
+            sparse->jc = NULL;
+            sparse->data = NULL;
             sparse->nzmax  = matvar->nbytes;
             (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
             /*  Read ir    */