diff --git a/src/singledocparser.cpp b/src/singledocparser.cpp
index a27c1c3..dce9466 100644
--- a/src/singledocparser.cpp
+++ b/src/singledocparser.cpp
@@ -18,7 +18,7 @@ SingleDocParser::SingleDocParser(Scanner& scanner, const Directives& directives)
     : m_scanner(scanner),
       m_directives(directives),
       m_pCollectionStack(new CollectionStack),
-      m_curAnchor(0) {}
+      m_curAnchor(0), m_depth(0) {}
 
 SingleDocParser::~SingleDocParser() {}
 
@@ -46,6 +46,14 @@ void SingleDocParser::HandleDocument(EventHandler& eventHandler) {
 }
 
 void SingleDocParser::HandleNode(EventHandler& eventHandler) {
+  // recursion depth guard to prevent stack exhaustion on malicious inputs
+  const int YAML_MAX_PARSE_DEPTH = 128;
+  if (m_depth >= YAML_MAX_PARSE_DEPTH)
+    throw ParserException(m_scanner.mark(), ErrorMsg::END_OF_MAP_FLOW);
+  ++m_depth;
+  struct DepthDec { SingleDocParser* p; DepthDec(SingleDocParser* p):p(p){} ~DepthDec(){ --p->m_depth; } };
+  DepthDec _depthDec(this);
+
   // an empty node *is* a possibility
   if (m_scanner.empty()) {
     eventHandler.OnNull(m_scanner.mark(), NullAnchor);
@@ -291,8 +299,15 @@ void SingleDocParser::HandleFlowMap(EventHandler& eventHandler) {
 
     // grab key (if non-null)
     if (token.type == Token::KEY) {
+      // pop the key token and parse the node.  After returning from
+      // HandleNode the scanner may be empty (or in an inconsistent
+      // state) for malformed inputs; detect that and fail early rather
+      // than continuing which can lead to unbounded recursion/stack
+      // exhaustion on crafted inputs.
       m_scanner.pop();
       HandleNode(eventHandler);
+      if (m_scanner.empty())
+        throw ParserException(m_scanner.mark(), ErrorMsg::END_OF_MAP_FLOW);
     } else {
       eventHandler.OnNull(mark, NullAnchor);
     }
diff --git a/src/singledocparser.h b/src/singledocparser.h
index 2b92067..3a5b64c 100644
--- a/src/singledocparser.h
+++ b/src/singledocparser.h
@@ -59,6 +59,8 @@ class SingleDocParser : private noncopyable {
   Anchors m_anchors;
 
   anchor_t m_curAnchor;
+  // current recursion depth for parsing nodes.
+  int m_depth;
 };
 }